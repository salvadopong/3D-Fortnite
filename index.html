<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Battle Royale: V18.0 - Final Overhaul</title>
    <style>
        /* ======================================= */
        /* === V18.0 CLEAN & POLISHED UI/UX === */
        /* ======================================= */
        
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Verdana', sans-serif; 
            user-select: none; 
            background: #000;
            touch-action: none; 
        }

        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            color: white;
        }

        /* --- PRE-GAME START SCREEN MODAL (Polished) --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e); 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 1000;
            text-align: center;
        }
        #start-screen h1 { 
            font-size: 80px; 
            margin-bottom: 30px; 
            color: #00d2ff; 
            text-shadow: 0 0 15px rgba(0, 210, 255, 0.8), 0 0 30px rgba(0, 210, 255, 0.5);
            font-weight: 900;
        }
        #start-screen p { 
            font-size: 20px; 
            margin-bottom: 40px; 
            color: #ccc;
        }
        .start-button {
            padding: 15px 40px; margin: 15px; font-size: 22px;
            background: #28a745; color: white; border: none; 
            border-radius: 8px; cursor: pointer;
            transition: background 0.2s, transform 0.1s, box-shadow 0.2s;
            font-family: 'Verdana', sans-serif; font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            min-width: 250px;
        }
        .start-button:hover { background: #1e7e34; box-shadow: 0 6px 15px rgba(0, 0, 0, 0.6); }
        .start-button:active { transform: scale(0.98); }
        .start-button.mobile-option { 
            background: #ffaa00; 
            border: 2px solid #fff;
        }
        .start-button.mobile-option:hover { background: #cc8800; }
        
        #victory-royales-stat {
            position: absolute; bottom: 40px; font-size: 18px;
            color: #ffd700; font-weight: bold;
            text-shadow: 1px 1px 5px #000;
        }
        
        /* --- Crosshair --- */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 20px; height: 20px; 
            transform: translate(-50%, -50%); 
            transition: all 0.1s;
            opacity: 0.8;
            z-index: 10;
        }
        .ch-line { position: absolute; background: #ff4d4d; box-shadow: 0 0 3px #ff4d4d; border-radius: 1px; }
        .ch-h { width: 100%; height: 2px; top: 50%; left: 0; margin-top: -1px; }
        .ch-v { height: 100%; width: 2px; left: 50%; top: 0; margin-left: -1px; }

        /* Scope */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 10%, black 12%);
            display: none; pointer-events: none; z-index: 100; 
            border: 2px solid #333;
        }
        /* Red Dot Scope for DMR, Scoped SMG */
        #red-dot-scope {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            width: 100%; height: 100%;
            display: none;
            pointer-events: none;
        }
        .red-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: #ff0000; box-shadow: 0 0 5px #ff0000;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .red-line {
            position: absolute; background: #ff0000; opacity: 0.5;
        }
        .red-line.h { width: 100%; height: 1px; top: 50%; }
        .red-line.v { height: 100%; width: 1px; left: 50%; }
        
        /* Storm Visuals (Fog Effect) */
        #storm-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            /* Purple fog gradient mix-blend-mode for the storm */
            background: radial-gradient(circle at center, rgba(138, 43, 226, 0.0) 30%, rgba(75, 0, 130, 0.4) 60%, rgba(75, 0, 130, 0.8) 100%);
            mix-blend-mode: multiply; 
            display: none; pointer-events: none; 
            transition: opacity 0.5s;
            z-index: 50; 
        }


        /* --- HUD Top (Revised for no minimap) --- */
        #top-hud { 
            position: absolute; top: 15px; width: 100%; 
            display: flex; justify-content: center; 
            padding: 0 20px; box-sizing: border-box; 
            align-items: flex-start;
            gap: 20px;
        }

        .hud-box {
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(8px);
            color: white; 
            padding: 10px 20px;
            border-bottom: 3px solid #00d2ff;
            border-radius: 6px;
            font-size: 18px; 
            font-weight: 700;
            text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            text-shadow: 1px 1px 0 #000;
            font-family: 'Verdana', sans-serif;
            text-align: center;
        }
        
        /* --- Player Stats (Bottom Left) --- */
        #status-area { 
            position: absolute; bottom: 30px; left: 30px; 
            width: 320px; 
            display: flex; flex-direction: column; gap: 10px;
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(8px);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            font-family: 'Verdana', sans-serif;
            border-left: 4px solid #38ef7d;
        }
        .stat-row { display: flex; align-items: center; gap: 15px; }
        .bar-wrap {
            flex-grow: 1; height: 25px; background: rgba(0,0,0,0.5);
            border-radius: 12px; overflow: hidden; position: relative;
        }
        .bar-fill { height: 100%; transition: width 0.3s; }
        #shield-bar { background: linear-gradient(90deg, #00d2ff, #0072ff); }
        #health-bar { background: linear-gradient(90deg, #11998e, #38ef7d); }
        .stat-icon { font-size: 28px; width: 30px; text-align: center; }
        .stat-val { position: absolute; right: 10px; top: 0; font-size: 14px; line-height: 25px; font-weight: 800; color: white; text-shadow: 1px 1px 2px black;}

        .resource-row { display: flex; gap: 20px; margin-top: 10px; }
        .resource-item { display: flex; align-items: center; gap: 5px; font-size: 16px; font-weight: 700; }
        .resource-icon { font-size: 24px; }
        #wood-val { color: #deb887; }
        
        /* Healing Bar */
        #healing-bar-wrap {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 30px; background: rgba(0, 0, 0, 0.7);
            border-radius: 15px; overflow: hidden; display: none;
            border: 2px solid #00d2ff;
        }
        #healing-bar-fill {
            height: 100%; background: linear-gradient(90deg, #0072ff, #00d2ff);
            transition: width 1s linear;
        }
        #healing-bar-text {
            position: absolute; top: 0; left: 0; width: 100%; text-align: center;
            line-height: 30px; color: white; font-weight: bold;
            text-shadow: 1px 1px 2px black; font-family: 'Verdana', sans-serif;
        }


        /* --- Interaction Prompt --- */
        #interact-msg { 
            position: absolute; top: 65%; left: 50%; 
            transform: translate(-50%, -50%); 
            background: rgba(255, 215, 0, 0.95); 
            color: black; 
            padding: 12px 25px; 
            border-radius: 5px; 
            font-size: 18px; 
            font-weight: 800; 
            display: none;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            pointer-events: none;
            text-transform: uppercase;
        }
        
        /* Reload Indicator */
        #reload-msg {
            position: absolute; bottom: 150px; left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.9);
            color: white; padding: 8px 20px; border-radius: 5px;
            font-size: 16px; font-weight: 800;
            display: none;
            text-transform: uppercase;
        }


        /* --- Inventory --- */
        #inventory { 
            position: absolute; bottom: 30px; right: 30px; 
            display: flex; gap: 10px; 
        }
        /* Mobile adjustment for inventory */
        #inventory.mobile {
            top: 20px; 
            bottom: auto;
            right: 20px;
            z-index: 20;
        }
        .slot { 
            width: 75px; height: 75px; 
            background: rgba(30, 30, 40, 0.95); 
            border: 3px solid rgba(255,255,255,0.2); 
            border-radius: 10px;
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            color: white; position: relative; 
            transition: transform 0.1s, border-color 0.1s; 
            pointer-events: auto;
            overflow: hidden;
            font-family: 'Verdana', sans-serif;
        }
        .slot.active { 
            border: 3px solid #ffaa00; 
            transform: scale(1.05) translateY(-5px); 
            background: rgba(50, 50, 60, 0.98);
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            z-index: 5;
        }
        .slot-key { 
            position: absolute; top: 2px; left: 5px; 
            font-size: 12px; color: #888; 
            font-weight: 700;
        }
        .slot-icon { font-size: 32px; margin-bottom: 2px; }
        .slot-name { 
            font-size: 10px; 
            font-weight: 700; 
            color: #ddd; 
            text-transform: uppercase; 
            max-width: 70px; 
            overflow: hidden; 
            white-space: nowrap; 
            text-overflow: ellipsis;
            padding: 0 5px;
            text-align: center;
        }
        
        /* Rarity Colors */
        .rarity-common { border-bottom: 4px solid #b0b0b0; }
        .rarity-uncommon { border-bottom: 4px solid #28a745; }
        .rarity-rare { border-bottom: 4px solid #007bff; }
        .rarity-epic { border-bottom: 4px solid #a335ee; }
        .rarity-legendary { border-bottom: 4px solid #ffd700; }
        .rarity-mythic { border-bottom: 4px solid #ff4d4d; } 

        /* Damage Text */
        .dmg-txt {
            position: absolute; color: white; font-weight: 900; font-size: 24px;
            text-shadow: 2px 2px 3px black; pointer-events: none;
            animation: popUp 1s forwards;
            font-family: 'Verdana', sans-serif;
            text-align: center;
        }
        .dmg-txt.headshot { color: #ff0000; font-size: 30px; text-shadow: 0 0 10px red; }
        @keyframes popUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-50px) scale(1.2); } }

        /* --- MOBILE CONTROLS --- */
        #mobile-controls {
            display: none; 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
        }
        
        #stick-left { position: absolute; top: 0; left: 0; width: 50%; height: 100%; pointer-events: auto; }
        #stick-right { position: absolute; top: 0; right: 0; width: 50%; height: 100%; background: none; pointer-events: auto; z-index: 1; } 

        /* Movement Zone Visuals */
        #movement-zone-visual {
            position: absolute; bottom: 50px; left: 40px; 
            width: 150px; height: 150px;
            background: rgba(255,255,255,0.05); border-radius: 50%;
            border: 2px dashed rgba(255,255,255,0.2);
            pointer-events: none; 
        }
        
        .stick-thumb {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255,255,255,0.3); border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        .action-btn {
            position: absolute; width: 65px; height: 65px;
            border-radius: 50%; background: rgba(20, 20, 20, 0.7);
            border: 2px solid rgba(255,255,255,0.5);
            color: white; font-weight: bold; font-size: 14px;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; 
            backdrop-filter: blur(4px);
            text-align: center;
            font-family: 'Verdana', sans-serif;
            text-transform: uppercase;
            z-index: 5; 
        }
        .action-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }

        #btn-fire { bottom: 100px; right: 20px; width: 80px; height: 80px; border-color: #ff4444; background: rgba(255,0,0,0.3); font-size: 18px; }
        #btn-jump { bottom: 200px; right: 30px; }
        #btn-interact { bottom: 160px; right: 100px; border-color: #ffd700; color: #ffd700; } 
        #btn-build { bottom: 240px; right: 100px; border-color: #8B4513; }
        #btn-ads { bottom: 60px; right: 120px; width: 55px; height: 55px; font-size: 12px; }


        /* --- Game Over (Standard) --- */
        #game-over {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 999; pointer-events: auto;
            font-family: 'Verdana', sans-serif;
        }
        
        /* --- VICTORY ROYALE ANIMATION (Enhanced) --- */
        #victory-overlay {
            display: none; 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(0deg, rgba(255, 215, 0, 0.2), rgba(255, 0, 0, 0.3)); 
            backdrop-filter: blur(5px);
            z-index: 1000;
            flex-direction: column; justify-content: center; align-items: center;
            pointer-events: none;
            overflow: hidden;
            font-family: 'Verdana', sans-serif;
            animation: fadeIn 0.5s ease-out forwards;
        }
        
        #victory-text {
            font-size: 0px; 
            color: #ffd700; 
            text-shadow: 0 0 50px #ffaa00, 0 0 100px #ff0000; 
            font-weight: 900;
            animation: textGrow 2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards, 
                       pulse 1.5s infinite alternate 2s;
            position: relative;
            transform: scale(0);
            pointer-events: auto;
            letter-spacing: -10px;
            opacity: 0;
            white-space: nowrap;
        }
        
        #victory-text::after {
            content: '#1!';
            display: inline-block;
            font-size: 0.5em;
            vertical-align: top;
            opacity: 0;
            animation: fadeUp 1s ease-out 2.5s forwards;
            color: #ff4d4d;
            text-shadow: 0 0 10px #ff0000;
            margin-left: 10px;
        }

        @keyframes fadeIn { 0% { opacity: 0; } 100% { opacity: 1; } }
        @keyframes textGrow {
            0% { font-size: 0px; transform: scale(0) rotate(-10deg); opacity: 0; letter-spacing: 50px; }
            50% { font-size: 150px; transform: scale(1.1) rotate(5deg); opacity: 1; letter-spacing: 0px; }
            100% { font-size: 100px; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0px; }
        }
        @keyframes pulse {
            0% { text-shadow: 0 0 40px orange, 0 0 80px red; transform: scale(1); }
            100% { text-shadow: 0 0 50px yellow, 0 0 90px crimson; transform: scale(1.05); }
        }
        @keyframes fadeUp {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        button.restart-btn { 
            margin-top: 30px; padding: 15px 50px; font-size: 22px; 
            background: #007bff; color: white; border: none; 
            border-radius: 8px; cursor: pointer; 
            font-family: 'Verdana', sans-serif; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.5);
            transition: background 0.2s;
            pointer-events: auto;
            opacity: 0;
            animation: fadeUp 1s ease-out 3s forwards;
        }
        button.restart-btn:hover { background: #0056b3; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>FORTNITE</h1>
        <p>Select your mode and platform:</p>
        <div>
            <button class="start-button mobile-option" onclick="startGame(true)">Mobile Mode (21 Bots)</button>
            <button class="start-button" onclick="startGame(false)">PC / Laptop Mode (26 Bots)</button>
        </div>
        <div id="victory-royales-stat">Victory Royales: 0</div>
    </div>
    
    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="crosshair">
            <div class="ch-line ch-h"></div>
            <div class="ch-line ch-v"></div>
        </div>
        
        <div id="scope-overlay">
            <div id="scope-lines"></div>
        </div>
        
        <div id="red-dot-scope">
             <div class="red-line h"></div>
             <div class="red-line v"></div>
             <div class="red-dot"></div>
        </div>

        <div id="storm-overlay"></div>

        <div id="top-hud">
            
            <div class="hud-box">Alive: <span id="alive-count">21</span></div>
            <div class="hud-box" style="border-bottom-color: #a335ee;">
                <span id="storm-status">WAITING...</span>: <span id="storm-timer">04:00</span>
            </div>
            
        </div>

        <div id="interact-msg">Interact (E)</div>
        <div id="reload-msg">RELOADING...</div>
        
        <div id="healing-bar-wrap">
            <div id="healing-bar-fill"></div>
            <div id="healing-bar-text">USING SHIELD...</div>
        </div>

        <div id="status-area">
            <div class="stat-row">
                <div class="stat-icon">üõ°Ô∏è</div>
                <div class="bar-wrap"><div id="shield-bar" class="bar-fill" style="width: 50%;"></div><div class="stat-val" id="shield-val">50</div></div>
            </div>
            <div class="stat-row">
                <div class="stat-icon">‚ù§Ô∏è</div>
                <div class="bar-wrap"><div id="health-bar" class="bar-fill" style="width: 100%;"></div><div class="stat-val" id="health-val">100</div></div>
            </div>
            <div class="resource-row">
                <div class="resource-item">
                    <div class="resource-icon">ü™µ</div>
                    <span id="wood-val">0</span>
                </div>
            </div>
        </div>

        <div id="inventory">
            <div class="slot" id="slot-0" onclick="selectSlot(0)" ontouchstart="selectSlot(0)"></div>
            <div class="slot" id="slot-1" onclick="selectSlot(1)" ontouchstart="selectSlot(1)"></div>
            <div class="slot" id="slot-2" onclick="selectSlot(2)" ontouchstart="selectSlot(2)"></div>
            <div class="slot" id="slot-3" onclick="selectSlot(3)" ontouchstart="selectSlot(3)"></div>
            <div class="slot" id="slot-4" onclick="selectSlot(4)" ontouchstart="selectSlot(4)"></div>
        </div>

        <div id="mobile-controls">
            <div id="stick-left">
                <div id="movement-zone-visual"><div class="stick-thumb" id="thumb-left"></div></div>
            </div>
            <div id="stick-right"></div>

            <div id="btn-fire" class="action-btn">FIRE</div>
            <div id="btn-jump" class="action-btn">JUMP</div>
            <div id="btn-interact" class="action-btn">INTERACT</div> 
            <div id="btn-build" class="action-btn">BUILD</div>
            <div id="btn-ads" class="action-btn">AIM</div>
        </div>
    </div>

    <div id="victory-overlay">
        <div id="victory-text">VICTORY ROYALE</div>
        <button class="restart-btn" onclick="location.reload()">RETURN TO LOBBY</button>
    </div>
    
    <div id="game-over">
        <h1 id="go-title">GAME OVER</h1>
        <h3 id="go-stats">Eliminations: 0</h3>
        <button class="restart-btn" onclick="location.reload()" style="animation: none; opacity: 1;">RETURN TO LOBBY</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ===============================================================
        // === CORE CONSTANTS AND CONFIGURATION (V18.0) ===================
        // ===============================================================
        
        const WORLD_SIZE = 600;
        let BOT_COUNT = 21; // Default for mobile
        const GRAVITY = 40.0; 
        const WALK_SPEED = 10; 
        const SPRINT_SPEED = 20; 
        const JUMP_FORCE = 15;
        const PLAYER_HEIGHT = 1.8;
        const SHOTGUN_PELLETS = 4; // New constant for shotguns
        
        // --- WEAPONS CONFIG ---
        const RARITY_MULTIPLIERS = {
            COMMON: { dmg: 1.0, reload: 1.0, color: '#b0b0b0' },
            UNCOMMON: { dmg: 1.15, reload: 0.9, color: '#28a745' },
            RARE: { dmg: 1.3, reload: 0.8, color: '#007bff' },
            EPIC: { dmg: 1.45, reload: 0.7, color: '#a335ee' },
            LEGENDARY: { dmg: 1.6, reload: 0.6, color: '#ffd700' },
            MYTHIC: { dmg: 1.8, reload: 0.5, color: '#ff4d4d' } 
        };
        const RARITY_KEYS = Object.keys(RARITY_MULTIPLIERS);

        const WEAPONS_BASE = {
            // DMG * 1.5 multiplier for Pump Shotgun
            PUMP: { name: "Pump Shotgun", dmg: 30 * 1.5, head: 35 * 1.5, rate: 1.2, mag: 5, range: 30, spread: 0.25, pellets: SHOTGUN_PELLETS, auto: false, icon: 'üí•', reload: 3000, recoil: 0.0, bulletType: 'hitscan' }, 
            AUTO_SHG: { name: "Auto Shotgun", dmg: 15, head: 25, rate: 0.4, mag: 8, range: 25, spread: 0.3, pellets: SHOTGUN_PELLETS, auto: true, icon: 'üî•', reload: 3500, recoil: 0.0, bulletType: 'hitscan' },
            RFAR: { name: "Rapid Fire AR", dmg: 14, head: 21, rate: 0.1, mag: 30, range: 150, spread: 0.04, pellets: 1, auto: true, icon: 'üí®', reload: 2500, recoil: 0.0, bulletType: 'hitscan' }, 
            DMR: { name: "DMR", dmg: 25, head: 40, rate: 0.35, mag: 15, range: 250, spread: 0.015, pellets: 1, auto: false, icon: 'üéØ', reload: 2800, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            STINGER: { name: "Stinger SMG", dmg: 12, head: 18, rate: 0.07, mag: 20, range: 70, spread: 0.07, pellets: 1, auto: true, icon: '‚ö°', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            BURST_SMG: { name: "Burst SMG", dmg: 18, head: 30, rate: 0.15, mag: 30, burst: 2, burstDelay: 300, range: 80, spread: 0.05, pellets: 1, auto: false, icon: '‚ú®', reload: 2000, recoil: 0.0, bulletType: 'hitscan' },
            BOLT_SNIPER: { name: "Bolt Sniper", dmg: 85, head: 105, rate: 2.5, mag: 2, range: 600, spread: 0.001, pellets: 1, auto: false, icon: 'üíÄ', reload: 4000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            SCOPED_SMG: { name: "Scoped SMG", dmg: 12, head: 18, rate: 0.1, mag: 40, range: 100, spread: 0.03, pellets: 1, auto: true, icon: 'üëÅÔ∏è', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            DRUM_SMG: { name: "Drum SMG", dmg: 10, head: 15, rate: 0.08, mag: 50, range: 80, spread: 0.08, pellets: 1, auto: true, icon: 'ü•Å', reload: 1200, recoil: 0.0, bulletType: 'hitscan' },
            FALCON_SNIPER: { name: "Falcon Sniper", dmg: 65, head: 90, rate: 0.7, mag: 3, range: 500, spread: 0.005, pellets: 1, auto: false, icon: 'ü¶Ö', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            STRANGLED_RIFLE: { name: "Strangled Rifle", dmg: 35, head: 55, rate: 0.45, mag: 30, range: 180, spread: 0.02, pellets: 1, auto: false, icon: '‚õìÔ∏è', reload: 2500, recoil: 0.0, bulletType: 'hitscan' },
            // Sniper Base Damage: 100 Body, 130 Head on common
            SNIPER:{name: "Sniper", dmg: 100,head: 130,rate: 1.5, mag: 1,  range: 600,spread: 0.001,pellets:1, auto: false,icon:'üî≠', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            PISTOL: { name: "Pistol", dmg: 12, head: 18, rate: 0.5, mag: 15, range: 100, spread: 0.05, pellets: 1, auto: false, icon: 'üí£', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
        };
        const MYTHIC_WEAPON_KEY = 'STRANGLED_RIFLE'; 
        
        // --- CONSUMABLES CONFIG ---
        const CONSUMABLES = {
            MINI: { name: "Small Shield", val: 25, type: 'shield', max: 50, icon: 'üíß', time: 1, continuous: false, instant: true, maxStack: 6 },
            BIG:  { name: "Big Shield", val: 50, type: 'shield', max: 100, icon: '‚öóÔ∏è', time: 5000, continuous: false, instant: false, maxStack: 3 },
            CHUG: { name: "Chug Jug", val: 3, shieldVal: 3, type: 'continuous', max: 100, icon: 'ü•§', time: 20000, continuous: true, instant: false, maxStack: 1 },
            MEDKIT: { name: "Med Kit", val: 100, type: 'health', max: 100, icon: 'ü©π', time: 10000, continuous: false, instant: false, maxStack: 3 }
        };

        // --- STORM PHASES ---
        const STORM_PHASES = [
            { time: 240, radius: WORLD_SIZE * 0.5, damage: 3, status: "Wait" }, 
            { time: 60, radius: WORLD_SIZE * 0.4, damage: 3, status: "Shrink" }, 
            { time: 120, radius: WORLD_SIZE * 0.4, damage: 3, status: "Hold" }, 
            { time: 60, radius: WORLD_SIZE * 0.3, damage: 5, status: "Shrink" }, 
            { time: 60, radius: 10, damage: 10, status: "Deathmatch" } 
        ];
        const BOT_STORM_DAMAGE = 5; 

        // ===============================================================
        // === GLOBAL STATE VARIABLES ====================================
        // ===============================================================

        let scene, camera, renderer, controls;
        let weaponScene, weaponCamera, viewModel;
        let raycaster, downRay;
        
        let player = { 
            health: 100, shield: 50, wood: 0, 
            inventory: [null, null, null, null, null], slot: 0, 
            dead: false, ads: false, vehicle: null, eliminations: 0,
            isReloading: false,
            isHealing: false,
            healingItem: null,
            healingStartTime: 0,
            lastStormDamage: 0,
            isBursting: false,
            burstCount: 0,
            burstTimer: null
        };
        
        let inputs = { w: false, a: false, s: false, d: false, jump: false, sprint: false, fire: false, reload: false, use: false };
        let velocity = new THREE.Vector3();
        let isGrounded = false;
        let lastTime = performance.now();
        let lastShot = 0;
        let isMobileMode = false; 
        let gameStarted = false;
        let victoryRoyales = 0; // Local storage tracked
        
        // Dynamic Arrays for Entities
        let bots = [];
        let objects = []; 
        let chests = [];
        let cars = [];
        let loot = [];
        let buildings = []; 
        let projectiles = []; 
        let doors = []; 

        // Storm State
        let stormRadius = STORM_PHASES[0].radius;
        let stormCenter = new THREE.Vector2(0, 0);
        let stormDamageRate = STORM_PHASES[0].damage;
        let stormPhaseTime = STORM_PHASES[0].time; 
        let stormPhaseTimer = stormPhaseTime;
        let stormPhase = 0;
        let stormActive = false;
        let stormTimerInterval;

        // ===============================================================
        // === SOUND EFFECT UTILITIES (PLACEHOLDER) =======================
        // ===============================================================

        function playSound(type) {
            // Note: These are placeholders. In a full environment, you would use:
            // new Audio('path/to/sound.mp3').play();
            // console.log(`[SOUND]: Playing ${type} sound.`); 
        }

        // ===============================================================
        // === UTILITY FUNCTIONS =========================================
        // ===============================================================

        function getTerrainHeight(x, z) {
            const scale1 = 0.02;
            const scale2 = 0.05;
            let y = (Math.sin(x * scale1) * 10 + Math.cos(z * scale1) * 10) + 
                    (Math.sin(x * scale2 + z * scale2) * 5);
            const dist = Math.sqrt(x*x + z*z);
            if (dist > WORLD_SIZE * 0.45) y += (dist - WORLD_SIZE * 0.45) * 0.2;
            return y;
        }
        
        function createBox(x, y, z, w, h, d, col, type='solid') {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: col}));
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh); 
            buildings.push({ mesh: mesh, type: type, health: 100 });
            return mesh;
        }

        function createDoor(x, y, z, rotationY) {
            const doorGeo = new THREE.BoxGeometry(1.5, 3, 0.1);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, transparent: true, opacity: 0.8 });
            const doorMesh = new THREE.Mesh(doorGeo, doorMat);
            doorMesh.position.set(x, y + 1.5, z);
            doorMesh.rotation.y = rotationY;
            scene.add(doorMesh);
            
            objects.push(doorMesh); 
            doors.push({ mesh: doorMesh, open: false, initialRotation: rotationY });
            
            return doorMesh;
        }
        
        function checkWin() {
            if (bots.length === 0 && !player.dead) {
                handleGameOver(true);
            }
        }
        
        function handleGameOver(win) {
            player.dead = true;
            if (controls && controls.isLocked) controls.unlock(); 
            
            if (win) {
                // Update Victory Royale count
                victoryRoyales = (parseInt(localStorage.getItem('victoryRoyales')) || 0) + 1;
                localStorage.setItem('victoryRoyales', victoryRoyales);

                document.getElementById('victory-overlay').style.display = 'flex';
                playSound('victory');
            } else {
                document.getElementById('go-title').innerText = "GAME OVER";
                document.getElementById('go-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('game-over').style.display = 'flex';
                playSound('defeat');
            }
        }

        function toggleADS(bool) {
            player.ads = bool;
            const item = player.inventory[player.slot];
            const isClassicScope = item && item.category === 'weapon' && item.stats.scope === 'classic';
            const isRedDotScope = item && item.category === 'weapon' && item.stats.scope === 'red_dot';
            
            const scopeOverlay = document.getElementById('scope-overlay');
            const redDotScope = document.getElementById('red-dot-scope');
            const crosshair = document.getElementById('crosshair');

            scopeOverlay.style.display = 'none';
            redDotScope.style.display = 'none';
            crosshair.style.display = 'block';
            camera.fov = 75;

            if (bool) {
                if (isClassicScope) {
                    scopeOverlay.style.display = 'block';
                    crosshair.style.display = 'none';
                    camera.fov = 15;
                } else if (isRedDotScope) {
                    redDotScope.style.display = 'block';
                    crosshair.style.display = 'none';
                    camera.fov = 45;
                }
            } else {
                // Resetting
            }

            camera.updateProjectionMatrix();
        }

        function showDmg(amount, position, isHeadshot = false) {
            const dmgText = document.createElement('div');
            dmgText.className = 'dmg-txt' + (isHeadshot ? ' headshot' : '');
            dmgText.innerText = Math.round(amount);
            
            const worldPoint = position.clone().project(camera);
            
            const x = (worldPoint.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-worldPoint.y * 0.5 + 0.5) * window.innerHeight;
            
            dmgText.style.left = `${x}px`;
            dmgText.style.top = `${y}px`;
            
            document.getElementById('ui-layer').appendChild(dmgText);
            
            setTimeout(() => {
                dmgText.remove();
            }, 1000);
        }

        function reload() {
            const item = player.inventory[player.slot];
            if (!item || item.category !== 'weapon' || item.stats.currentMag === item.stats.mag || player.isReloading) return;
            
            playSound('reload');

            player.isReloading = true;
            updateUI(); 

            const reloadTime = item.stats.reload * item.rarity.reload;

            setTimeout(() => {
                item.stats.currentMag = item.stats.mag;
                player.isReloading = false;
                updateUI();
            }, reloadTime);
        }

        function buildWall() {
            if (player.wood < 10) return;
            
            playSound('build');

            const wallGeo = new THREE.BoxGeometry(4, 4, 0.1);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, transparent: true, opacity: 0.8 });
            const wall = new THREE.Mesh(wallGeo, wallMat);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0;
            dir.normalize();

            wall.position.copy(camera.position).add(dir.multiplyScalar(5)).setY(getTerrainHeight(camera.position.x, camera.position.z) + 2);
            wall.rotation.y = camera.rotation.y;
            scene.add(wall);
            
            objects.push(wall);
            buildings.push({ mesh: wall, type: 'wall', health: 100 }); 
            player.wood -= 10;
            updateUI();
        }


        // ===============================================================
        // === STORM LOGIC ===============================================
        // ===============================================================

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function startStormTimer() {
            if (stormTimerInterval) clearInterval(stormTimerInterval);

            const nextPhase = STORM_PHASES[stormPhase];
            if (!nextPhase) {
                document.getElementById('storm-status').innerText = "FINAL";
                document.getElementById('storm-timer').innerText = "00:00";
                return;
            }
            
            stormPhaseTimer = nextPhase.time;
            document.getElementById('storm-status').innerText = nextPhase.status;
            stormDamageRate = nextPhase.damage; 
            
            const startRadius = stormRadius;
            const endRadius = nextPhase.radius;
            const startTime = performance.now();

            stormTimerInterval = setInterval(() => {
                if (player.dead) {
                    clearInterval(stormTimerInterval);
                    return;
                }
                
                stormPhaseTimer -= 1;
                document.getElementById('storm-timer').innerText = formatTime(stormPhaseTimer);
                
                if (nextPhase.status === "Shrink") {
                    const elapsed = performance.now() - startTime;
                    const duration = nextPhase.time * 1000;
                    const t = Math.min(1, elapsed / duration);
                    stormRadius = startRadius + (endRadius - startRadius) * t;
                    stormActive = true; 
                } else if (nextPhase.status === "Hold" || nextPhase.status === "Deathmatch") {
                    stormActive = true;
                } else if (nextPhase.status === "Wait") {
                    stormActive = false;
                }

                if (stormPhaseTimer <= 0) {
                    clearInterval(stormTimerInterval);
                    stormPhase++;
                    startStormTimer();
                }
            }, 1000);
        }
        
        function updateStorm(now) {
            const playerPos2D = new THREE.Vector2(camera.position.x, camera.position.z);
            const distToStorm = playerPos2D.distanceTo(stormCenter);

            // Damage Application - Player
            if (stormActive && distToStorm > stormRadius && stormDamageRate > 0) {
                document.getElementById('storm-overlay').style.display = 'block';
                if (now - player.lastStormDamage > 1000) {
                    takeDamage(stormDamageRate, camera.position); 
                    player.lastStormDamage = now;
                    playSound('storm_damage');
                }
            } else {
                document.getElementById('storm-overlay').style.display = 'none';
            }

            // Damage Application - Bots
            bots.forEach(bot => {
                const botPos2D = new THREE.Vector2(bot.mesh.position.x, bot.mesh.position.z);
                const botDistToStorm = botPos2D.distanceTo(stormCenter);
                if (stormActive && botDistToStorm > stormRadius && BOT_STORM_DAMAGE > 0) {
                     if (now - (bot.lastStormDamage || 0) > 1000) {
                        // Bots take damage only to health, not shield
                        bot.health = Math.max(0, bot.health - BOT_STORM_DAMAGE); 
                        bot.lastStormDamage = now;
                    }
                }
            });
        }


        // ===============================================================
        // === WORLD GENERATION & GEOMETRY ===============================
        // ===============================================================

        function generateTerrain() {
            const size = WORLD_SIZE;
            const segments = 128;
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            geometry.rotateX(-Math.PI / 2);

            const position = geometry.attributes.position;
            for (let i = 0; i < position.count; i++) {
                const x = position.getX(i);
                const z = position.getZ(i);
                const y = getTerrainHeight(x, z);
                position.setY(i, y);
            }
            position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50 }); 
            const terrain = new THREE.Mesh(geometry, grassMat);
            terrain.receiveShadow = true;
            scene.add(terrain);
            objects.push(terrain); 
        }

        // --- POI UTILITIES ---
        function createTower(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+10, z, 5, 20, 5, 0x999999);
            createBox(x, h+21, z, 7, 2, 7, 0xAAAAAA);
            spawnChest(x, h+23, z); 
        }
        function createBuilding(x, z, size, height, depth, color, rotation) {
            const h = getTerrainHeight(x, z);
            const mesh = createBox(x, h + height/2, z, size, height, depth, color);
            mesh.rotation.y = rotation;
            spawnChest(x+size/4, h+1, z+depth/4); 
        }
        function createWoodHouse(x, z, size, height, depth) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+height/2, z, size, height, depth, 0x8B4513);
            createBox(x, h+height+1, z, size+2, 2, depth+2, 0x555555); 
            spawnChest(x, h+1, z); 
        }
        function createTree(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+2, z, 0.5, 4, 0.5, 0x8B4513, 'tree'); 
            createBox(x, h+5, z, 3, 3, 3, 0x228B22, 'tree'); 
        }

        // === 13 ORIGINAL & 13 NEW POIs ===
        function createRetailRow(x, z) { createBuilding(x, z, 15, 8, 15, 0xFF7F50, 0); }
        function createLootLake(x, z) { createBox(x, getTerrainHeight(x, z)+0.1, z, 50, 0.2, 50, 0x00BFFF); }
        function createShiftyShafts(x, z) { createBox(x, getTerrainHeight(x, z)-5, z, 30, 10, 30, 0x696969); spawnChest(x, getTerrainHeight(x, z)-4, z); }
        function createPleasantPark(x, z) { createWoodHouse(x, z, 10, 8, 10); }
        function createTomatoTown(x, z) { createBox(x, getTerrainHeight(x, z)+5, z, 10, 10, 10, 0xFF6347); createBox(x, getTerrainHeight(x, z)+11, z, 5, 2, 5, 0xFF0000); }
        function createSaltySprings(x, z) { createBuilding(x, z, 12, 6, 12, 0x808080, Math.PI/4); }
        function createFatalFields(x, z) { createWoodHouse(x, z, 20, 5, 20); }
        function createRiskyReels(x, z) { createBox(x, getTerrainHeight(x, z)+10, z, 2, 20, 10, 0x000000); }
        function createTheGrotto(x, z) { createBox(x, getTerrainHeight(x, z)-10, z, 40, 20, 40, 0x222222); spawnChest(x, getTerrainHeight(x, z)-9, z); }
        function createSlurpySwamp(x, z) { createBox(x, getTerrainHeight(x, z)+0.1, z, 30, 0.2, 30, 0x00FF7F); }
        function createMistyMeadows(x, z) { createBuilding(x, z, 18, 10, 18, 0x9370DB, -Math.PI/4); }
        function createTheFortilla(x, z) { createBox(x, getTerrainHeight(x, z), z, 40, 0.5, 40, 0xADD8E6); createBox(x+10, getTerrainHeight(x, z)+2, z, 5, 4, 5, 0xAAAAAA); }
        function createSteamyStacks(x, z) { createBox(x, getTerrainHeight(x, z)+15, z, 8, 30, 8, 0xEEEEEE); createBox(x+10, getTerrainHeight(x, z)+15, z+10, 8, 30, 8, 0xEEEEEE); }
        function createSweatySands(x, z) { createBox(x, getTerrainHeight(x, z)+0.5, z, 25, 1, 25, 0xF4A460); createWoodHouse(x-5, z-5, 8, 6, 8); }
        function createWeepingWoods(x, z) { for(let i=0; i<5; i++) createTree(x + Math.random()*20-10, z + Math.random()*20-10); }
        function createLazyLake(x, z) { createBuilding(x, z, 20, 10, 10, 0x00FFFF, 0); createBuilding(x+15, z+15, 10, 8, 10, 0xADD8E6, Math.PI/2); }

        // --- NEW POIS ---
        function createEmberIsland(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 10, z, 10, 20, 10, 0xAA0000); 
            spawnChest(x, h+21, z); 
        }
        function createFlushFactory(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 5, z, 20, 10, 20, 0x778899); 
            createBox(x, h + 11, z, 15, 2, 15, 0xAAAAAA); 
            spawnChest(x, h+1, z); 
        }
        function createJunkJunction(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 2, z, 25, 4, 25, 0x666666); 
            spawnChest(x, h+3, z); 
        }
        function createTacoTime(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 3, z, 10, 6, 10, 0xFFFF00); 
            createBox(x, h + 7, z, 8, 2, 8, 0xFF0000); 
            spawnChest(x, h+1, z); 
        }
        function createHauntedHills(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 6, z, 15, 12, 15, 0x333333); 
            createBox(x, h + 1, z, 5, 2, 5, 0xFFFFFF); 
            spawnChest(x, h+1, z); 
        }
        function createPressurePlant(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 10, z, 25, 20, 25, 0xDDDDDD); 
            createBox(x, h + 21, z, 10, 2, 10, 0x0000FF); 
            spawnChest(x, h+1, z); 
        }
        function createTheAuthority(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 15, z, 30, 30, 30, 0x555555); 
            createBox(x, h + 31, z, 20, 2, 20, 0xAAAAAA); 
            spawnChest(x, h+1, z); 
        }
        function createTheBlock(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 2, z, 40, 4, 40, 0xCC7700); 
            spawnChest(x+10, h+3, z-10); 
        }
        function createVikingVillage(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 4, z, 10, 8, 10, 0x8B4513); 
            createBox(x, h + 9, z, 12, 2, 12, 0xAAAAAA); 
            spawnChest(x, h+1, z); 
        }
        function createDustyDepot(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x-10, h + 3, z, 5, 6, 5, 0xAA8800); 
            createBox(x+10, h + 3, z, 5, 6, 5, 0xAA8800); 
            createBox(x, h + 3, z, 5, 6, 5, 0xAA8800); 
            spawnChest(x, h+1, z); 
        }
        function createGraveYard(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 1, z, 20, 2, 20, 0x444444); 
            spawnChest(x, h+2, z); 
        }
        function createParadisePalms(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 5, z, 20, 10, 20, 0xFFA07A); 
            createTree(x+15, z-15); 
            spawnChest(x, h+1, z); 
        }
        function createStarrySuburbs(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h + 4, z, 15, 8, 15, 0x800080); 
            spawnChest(x, h+1, z); 
        }

        function generatePOIs() {
            // POI 1: Tilted Towers (Center)
            for(let i=0; i<3; i++) {
                const x = (Math.random()-0.5)*80;
                const z = (Math.random()-0.5)*80;
                createTower(x, z);
            }

            // Other POIs
            createBuilding(-200, -200, 20, 10, 30, 0x444444, Math.PI/2);
            createWoodHouse(-200, 200, 10, 12, 15); 
            createRetailRow(250, 250);
            createLootLake(-250, 250);
            createShiftyShafts(-250, -250);
            createPleasantPark(-280, 0);
            createTomatoTown(280, 0);
            createSaltySprings(50, 200); 
            createFatalFields(150, -100); 
            createRiskyReels(-150, 100); 
            createTheGrotto(100, -250); 
            createSlurpySwamp(-100, -300); 
            createMistyMeadows(300, 150); 
            createTheFortilla(0, 300); 
            createSteamyStacks(300, -300); 
            createSweatySands(-300, 150); 
            createWeepingWoods(-100, 250); 
            createLazyLake(200, 0); 

            // 13 New POIs
            createEmberIsland(-150, -150);
            createFlushFactory(150, 150);
            createJunkJunction(-300, 50);
            createTacoTime(300, -50);
            createHauntedHills(50, -250);
            createPressurePlant(-50, 300);
            createTheAuthority(-300, -100);
            createTheBlock(100, 300);
            createVikingVillage(250, -150);
            createDustyDepot(-200, -300);
            createGraveYard(200, 250);
            createParadisePalms(-50, -50);
            createStarrySuburbs(0, -200);


            // Trees
            for(let i=0; i<50; i++) {
                const x = (Math.random()-0.5)*400;
                const z = (Math.random()-0.5)*400;
                createTree(x, z);
            }
        }

        function spawnCars() {
            for(let i=0; i<4; i++) {
                const x = (Math.random()-0.5)*200;
                const z = (Math.random()-0.5)*200;
                const h = getTerrainHeight(x, z);
                
                const carGroup = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 5), new THREE.MeshStandardMaterial({color: Math.random() * 0xffffff}));
                body.position.y = 1;
                carGroup.add(body);
                
                carGroup.position.set(x, h, z); 
                scene.add(carGroup);
                
                cars.push({ mesh: carGroup, speed: 0, rotationY: carGroup.rotation.y, driving: false, raycaster: new THREE.Raycaster() });
            }
        }

        function spawnChest(x, y, z) {
            const chest = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1), new THREE.MeshStandardMaterial({color: 0xFFD700}));
            chest.position.set(x, y, z);
            scene.add(chest);
            chests.push(chest);
        }
        
        function createBotMesh(x, y, z) {
            const group = new THREE.Group();
            
            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({color: 0xFFA07A}));
            head.position.y = 2.4; 
            group.add(head);

            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.5), new THREE.MeshStandardMaterial({color: 0x007bff}));
            body.position.y = 1.6;
            group.add(body);

            // Legs (simple block legs)
            const legGeo = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const legMat = new THREE.MeshStandardMaterial({color: 0x444444});
            const legL = new THREE.Mesh(legGeo, legMat);
            legL.position.set(-0.3, 0.6, 0);
            const legR = new THREE.Mesh(legGeo, legMat);
            legR.position.set(0.3, 0.6, 0);
            group.add(legL);
            group.add(legR);

            group.position.set(x, y, z);
            return group;
        }

        function spawnBots() {
            for(let i=0; i<BOT_COUNT; i++) { 
                let x, z;
                do {
                    x = (Math.random()-0.5)*WORLD_SIZE*0.8;
                    z = (Math.random()-0.5)*WORLD_SIZE*0.8;
                } while (Math.abs(x) < 100 && Math.abs(z) < 100); 

                const h = getTerrainHeight(x, z);
                
                const mesh = createBotMesh(x, h + 1, z);
                scene.add(mesh);
                
                const randomWeaponKey = getRandomWeaponKey();
                const randomRarity = getRandomRarity(); 
                
                bots.push({ 
                    mesh: mesh, 
                    health: 100, // 100 Health
                    shield: 100, // 100 Shield (200 Total HP)
                    target: null, 
                    lastShot: 0, 
                    weapon: createWeaponItem(randomWeaponKey, randomRarity), 
                    lastMove: performance.now(),
                    velocity: new THREE.Vector3(0, 0, 0),
                    lastStormDamage: 0,
                    moveCooldown: 0, 
                    currentDirection: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize() 
                });
            }
        }


        // ===============================================================
        // === ITEM & HEALING LOGIC ======================================
        // ===============================================================

        function useHealingItem() {
            const item = player.inventory[player.slot];
            if (!item || item.category !== 'consumable' || item.count <= 0) return;
            if (player.isHealing && player.healingItem !== item) finishHealing(); 
            
            // 1. Instant use for Small Shields (MINI)
            if (item.instant) {
                 if (item.type === 'shield' && player.shield < item.max) {
                    player.shield = Math.min(item.max, player.shield + item.val);
                    item.count -= 1; 
                    if (item.count <= 0) player.inventory[player.slot] = null;
                    updateUI();
                    playSound('use_mini');
                    return;
                }
            }


            // 2. Timed/Continuous use for others
            if (player.isHealing) {
                if (player.healingItem === item) {
                    if (!item.continuous) finishHealing(); // Cancel non-continuous heal
                    return;
                }
                return;
            }

            let canUse = false;
            if (item.type === 'shield' && player.shield < item.max) canUse = true;
            if (item.type === 'health' && player.health < item.max) canUse = true;
            if (item.type === 'continuous') canUse = (player.health < 100 || player.shield < 100);

            if (canUse) {
                player.isHealing = true;
                player.healingItem = item;
                player.healingStartTime = performance.now();
                document.getElementById('healing-bar-wrap').style.display = 'block';
                document.getElementById('healing-bar-text').innerText = `USING ${item.name.toUpperCase()}...`;
                updateUI();
                
                if (!item.continuous && !item.instant) {
                    playSound('use_timed_start');
                    setTimeout(() => {
                        applyHealing(item);
                        finishHealing();
                        playSound('use_timed_finish');
                    }, item.time);
                } else if (item.continuous) {
                    playSound('use_chug_start');
                }
            }
        }
        
        function applyHealing(item) {
            // Non-continuous, non-instant (Big Shield, Medkit)
            if (item.type === 'shield') {
                player.shield = Math.min(item.max, player.shield + item.val);
            } else if (item.type === 'health') {
                player.health = Math.min(item.max, player.health + item.val);
            } 
            
            item.count -= 1;
            if (item.count <= 0) {
                const slotIndex = player.inventory.findIndex(i => i === item);
                if (slotIndex !== -1) player.inventory[slotIndex] = null;
            }
            updateUI();
        }
        
        function applyContinuousHealing(item, dt) {
            const timeElapsed = performance.now() - player.healingStartTime;
            const percentage = Math.min(1, timeElapsed / item.time);
            document.getElementById('healing-bar-fill').style.width = `${percentage * 100}%`;
            
            const interval = 1000; 
            if (!player.lastHealTick || (performance.now() - player.lastHealTick) >= interval) {
                if(player.shield < 100) {
                    player.shield = Math.min(100, player.shield + item.shieldVal); 
                } else if (player.health < 100) {
                    player.health = Math.min(100, player.health + item.val);
                }
                updateUI();
                player.lastHealTick = performance.now();
            }

            if (timeElapsed >= item.time || (player.health === 100 && player.shield === 100)) {
                finishHealing();
                playSound('use_chug_finish');
            }
        }

        function finishHealing() {
            player.isHealing = false;
            player.healingItem = null;
            player.lastHealTick = 0;
            document.getElementById('healing-bar-wrap').style.display = 'none';
            
            const item = player.inventory[player.slot];
            if (item && item.continuous) {
                 item.count -= 1;
                 if (item.count <= 0) {
                    player.inventory[player.slot] = null;
                 }
            }
            updateUI();
        }

        function tryInteract() {
            if (player.isHealing) {
                if (player.healingItem && !player.healingItem.continuous) {
                    finishHealing();
                    return;
                }
                if (player.healingItem && player.healingItem.continuous) return;
            }

            const pos = camera.position;

            // 1. Check Loot (Pickup/Swap)
            for(let i=loot.length-1; i>=0; i--) {
                const currentLoot = loot[i];
                if(pos.distanceTo(currentLoot.mesh.position) < 4) {
                    const currentItem = player.inventory[player.slot];
                    if (currentItem && currentItem.category === 'consumable' && currentItem.name === currentLoot.data.name) {
                        if (currentItem.count < currentItem.maxStack) {
                            currentItem.count = Math.min(currentItem.maxStack, currentItem.count + currentLoot.data.count);
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            return;
                        }
                    }

                    if (currentItem) {
                        dropItem(player.slot, currentLoot.mesh.position.clone().add(new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2)));
                    }
                    
                    if(giveItem(currentLoot.data, player.slot)) {
                        scene.remove(currentLoot.mesh);
                        loot.splice(i, 1);
                        updateUI();
                        playSound('pickup_item');
                        return;
                    }
                }
            }
            
            // 2. Check Chests
            for(let i=chests.length-1; i>=0; i--) {
                if(pos.distanceTo(chests[i].position) < 4) {
                    scene.remove(chests[i]);
                    chests.splice(i, 1);
                    spawnLoot(pos.x+1, pos.y, pos.z, 'weapon', 'RARE');
                    spawnLoot(pos.x-1, pos.y, pos.z, 'consumable', 'MINI'); 
                    playSound('open_chest');
                    return;
                }
            }

            // 3. Check Doors
            for(let door of doors) {
                if(pos.distanceTo(door.mesh.position) < 5) {
                    door.open = !door.open;
                    const rotation = door.open ? door.initialRotation + Math.PI / 2 : door.initialRotation;
                    door.mesh.rotation.y = rotation;
                    
                    const shiftDir = new THREE.Vector3();
                    shiftDir.setFromEuler(new THREE.Euler(0, door.initialRotation + Math.PI / 4, 0));
                    door.mesh.position.sub(shiftDir.multiplyScalar(0.75)); 
                    playSound('open_door');
                    return;
                }
            }

            // 4. Check Cars (Entry/Exit)
            for(let c of cars) {
                if(pos.distanceTo(c.mesh.position) < 5) {
                    if(player.vehicle) {
                        player.vehicle.driving = false;
                        player.vehicle = null;
                        camera.position.y += 2; 
                        camera.position.x = c.mesh.position.x + 5; 
                        camera.position.z = c.mesh.position.z + 5; 
                        playSound('exit_vehicle');
                    } else {
                        player.vehicle = c;
                        c.driving = true;
                        playSound('enter_vehicle');
                    }
                    updateUI();
                    return;
                }
            }
            
            // 5. Check Resources (Harvesting)
            for (let b of buildings) {
                if (b.type === 'tree' && pos.distanceTo(b.mesh.position) < 5) {
                    player.wood += 5;
                    updateUI();
                    
                    b.health -= 50; 
                    if (b.health <= 0) {
                        scene.remove(b.mesh);
                        objects = objects.filter(obj => obj !== b.mesh);
                        buildings = buildings.filter(bldg => bldg !== b);
                        playSound('harvest_break');
                    } else {
                        playSound('harvest_hit');
                    }
                    return;
                }
            }
        }
        
        function dropItem(slotIndex, position) {
            const itemToDrop = player.inventory[slotIndex];
            if (!itemToDrop) return;
            
            spawnLoot(position.x, position.y + 1, position.z, itemToDrop);
            player.inventory[slotIndex] = null;
            playSound('drop_item');
        }

        /**
         * Creates a weapon item object with rarity scaling.
         */
        function createWeaponItem(typeKey, rarityKey) {
            const base = WEAPONS_BASE[typeKey];
            const rar = RARITY_MULTIPLIERS[rarityKey];
            
            return {
                category: 'weapon',
                name: base.name,
                rarity: rar,
                stats: { 
                    ...base, 
                    dmg: base.dmg * rar.dmg, 
                    head: base.head * rar.dmg, 
                    reload: base.reload * rar.reload, 
                    currentMag: base.mag 
                }, 
                maxAmmo: base.mag
            };
        }
        
        function getRandomRarity() {
            // Skew drop chances
            const rarityPool = ['COMMON', 'COMMON', 'UNCOMMON', 'UNCOMMON', 'RARE', 'EPIC', 'LEGENDARY'];
            const index = Math.floor(Math.random() * rarityPool.length);
            return rarityPool[index];
        }

        function getRandomWeaponKey() {
            // Include Strangled Rifle only if we are forced to spawn a Mythic
            const keys = Object.keys(WEAPONS_BASE).filter(k => k !== MYTHIC_WEAPON_KEY);
            return keys[Math.floor(Math.random()*keys.length)];
        }

        function getRandomConsumableKey() {
            const keys = Object.keys(CONSUMABLES);
            return keys[Math.floor(Math.random() * keys.length)];
        }

        function giveItem(itemData, slot) {
            if (itemData.category === 'weapon') {
                player.inventory[slot] = itemData;
            } else if (itemData.category === 'consumable') {
                const existing = player.inventory.find(i => i && i.name === itemData.name);
                if (existing) {
                    existing.count = Math.min(existing.maxStack, existing.count + itemData.count);
                } else if (player.inventory[slot] === null) {
                    player.inventory[slot] = itemData;
                } else {
                    return false; // Can't auto-stack and slot is full
                }
            } else if (itemData === 'mythic') {
                const mythicWeapon = createWeaponItem(MYTHIC_WEAPON_KEY, 'MYTHIC');
                player.inventory[slot] = mythicWeapon;
            }
            return true;
        }

        function spawnLoot(x, y, z, type, rarity = null) {
            let item;
            if(type === 'weapon' || type === 'mythic') {
                const typeKey = type === 'mythic' ? MYTHIC_WEAPON_KEY : getRandomWeaponKey();
                const rarityKey = type === 'mythic' ? 'MYTHIC' : (rarity || getRandomRarity());
                item = createWeaponItem(typeKey, rarityKey);
            } else if (type === 'consumable') {
                const consKey = rarity || getRandomConsumableKey();
                const base = CONSUMABLES[consKey];
                item = { category: 'consumable', ...base, count: 1 };
            } else if (typeof type === 'object') {
                item = type; // Drop existing item object
            } else {
                return;
            }

            let color = 0x808080;
            if (item.rarity) color = parseInt(item.rarity.color.substring(1), 16);
            else if (item.category === 'consumable') color = 0x00d2ff;

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({color: color}));
            mesh.position.set(x, y, z);
            scene.add(mesh);
            loot.push({ mesh: mesh, data: item });
        }


        // ===============================================================
        // === SHOOTING & DAMAGE SYSTEM ==================================
        // ===============================================================

        function shoot(item, isBurst = false) {
            if (item.stats.currentMag <= 0 || player.isReloading || player.isHealing) {
                if (!player.isReloading) reload();
                return;
            }
            
            if (item.stats.burst && !isBurst) {
                if (player.isBursting) return;
                player.isBursting = true;
                player.burstCount = 0;
                
                const burstShot = () => {
                    if (player.burstCount < item.stats.burst && item.stats.currentMag > 0) {
                        doSingleShot(item);
                        player.burstCount++;
                        player.burstTimer = setTimeout(burstShot, 100); 
                    } else {
                        player.isBursting = false;
                        if (item.stats.currentMag > 0) {
                             player.burstTimer = setTimeout(() => {
                                 // Allow next burst after cooldown
                             }, item.stats.burstDelay);
                        }
                    }
                };
                burstShot();
                return;
            } else if (item.stats.burst && isBurst) {
                doSingleShot(item);
                return;
            }
            
            doSingleShot(item);
        }
        
        function doSingleShot(item) {
             const fireOrigin = camera.position.clone();
            const fireDirection = new THREE.Vector3();
            camera.getWorldDirection(fireDirection);

            playSound('shoot');
            
            if (item.stats.bulletType === 'hitscan') {
                handleHitscan(item, fireOrigin, fireDirection, player);
            } // else if (item.stats.bulletType === 'projectile') { ... }
            
            item.stats.currentMag -= 1;
            lastShot = performance.now();
            updateUI();
        }

        /**
         * @param {object} item - The weapon stats.
         * @param {THREE.Vector3} fireOrigin - The world position where the shot originates.
         * @param {THREE.Vector3} fireDirection - The normalized vector of the initial shot direction.
         * @param {object} shooter - The player object or bot object that is shooting.
         */
        function handleHitscan(item, fireOrigin, fireDirection, shooter) {
            const spread = shooter === player ? (player.ads ? 0.005 : item.stats.spread) : item.stats.spread; 
            
            for(let p = 0; p < item.stats.pellets; p++) {
                
                const ray = new THREE.Raycaster(fireOrigin);
                const spreadDir = fireDirection.clone();
                
                // Add spread
                const randomX = (Math.random() - 0.5) * spread;
                const randomY = (Math.random() - 0.5) * spread;
                spreadDir.x += randomX;
                spreadDir.y += randomY;
                spreadDir.normalize();

                // Bot miss chance (30% chance)
                if (shooter !== player && Math.random() < 0.3) { 
                    spreadDir.x += (Math.random() - 0.5) * 0.5;
                    spreadDir.y += (Math.random() - 0.5) * 0.5;
                    spreadDir.normalize();
                }

                ray.ray.direction.copy(spreadDir);

                const targets = bots.map(b => b.mesh).concat(objects).concat(cars.map(c=>c.mesh));
                const hits = ray.intersectObjects(targets, true);
                
                if(hits.length > 0) {
                    const hit = hits[0];
                    let hitBot = null;
                    let hitPlayer = false;
                    let isHeadshot = false;

                    // Find the root bot mesh 
                    let obj = hit.object;
                    while(obj && obj.parent && obj.parent.type !== 'Scene') {
                        const b = bots.find(bot => bot.mesh === obj.parent);
                        if(b) { hitBot = b; break; }
                        obj = obj.parent;
                    }
                    if(!hitBot) hitBot = bots.find(bot => bot.mesh === hit.object);
                    
                    // Check if player was hit
                    if (shooter !== player) {
                        const playerDist = hit.point.distanceTo(camera.position);
                        if (playerDist < 2 && hit.distance < item.stats.range) hitPlayer = true; 
                    }

                    if(hitBot && hitBot !== shooter) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > hitBot.mesh.position.y + 2.2) { 
                            dmg = item.stats.head; 
                            isHeadshot = true;
                        }
                        applyDamage(hitBot, dmg, hit.point, shooter, isHeadshot);
                    } else if (hitPlayer) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > camera.position.y + 0.5) { 
                            dmg = item.stats.head; 
                        }
                        takeDamage(dmg, hit.point); 
                        playSound('player_hit');
                    } else {
                        // Hit a building/object
                        playSound('impact_hit');
                    }
                }
            }
        }
        
        function applyDamage(target, amount, hitPoint, source, isHeadshot = false) {
            amount = Math.round(amount);
            let remainingDmg = amount;

            if(target.shield > 0) {
                target.shield -= remainingDmg;
                if(target.shield < 0) { 
                    remainingDmg = -target.shield; 
                    target.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            } 
            
            if (remainingDmg > 0) {
                target.health -= remainingDmg;
            }
            
            showDmg(amount, hitPoint, isHeadshot);
            
            if(target.health <= 0) {
                if (bots.includes(target)) {
                    if (source === player) player.eliminations += 1;
                    scene.remove(target.mesh);
                    bots = bots.filter(b => b !== target);
                    
                    const botWeapon = target.weapon;
                    const dropConsumableKey = getRandomConsumableKey();
                    const consumableBase = CONSUMABLES[dropConsumableKey];
                    const healingItemDrop = { category: 'consumable', ...consumableBase, count: 1 };
                    
                    spawnLoot(hitPoint.x + 1, hitPoint.y, hitPoint.z, botWeapon); 
                    spawnLoot(hitPoint.x - 1, hitPoint.y, hitPoint.z, healingItemDrop); 
                    
                    playSound('elimination');
                    checkWin();
                }
            }
        }
        
        function takeDamage(amount, sourcePoint) {
            amount = Math.floor(amount);
            if (amount <= 0 || player.dead) return;
            
            let remainingDmg = amount;

            if(player.shield > 0) {
                player.shield -= remainingDmg;
                if(player.shield < 0) { 
                    remainingDmg = -player.shield; 
                    player.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            } 
            
            if (remainingDmg > 0) {
                player.health -= remainingDmg;
            }
            
            showDmg(amount, camera.position.clone().setY(camera.position.y - 0.5)); 
            updateUI();
            
            if(player.health <= 0) {
                player.dead = true;
                handleGameOver(false);
            }
        }


        // ===============================================================
        // === BOT AI & LIFE CYCLE (Improved) ============================
        // ===============================================================

        function findClosestTarget(bot) {
            if (player.health > 0 && !player.dead) {
                return player;
            } else {
                return null; 
            }
        }

        function updateBots(dt, now) {
            document.getElementById('alive-count').innerText = bots.length + 1;
            const BOT_MOVE_SPEED = WALK_SPEED * 0.3; 
            const BOT_MOVE_COOLDOWN_RANGE = 2000; 

            for(let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];
                if (bot.health <= 0) continue;

                // 1. Gravity and Grounding
                const h = getTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                bot.mesh.position.y = h + 1; 

                // 2. Target Selection 
                const target = findClosestTarget(bot);
                
                if(target) {
                    const targetPos = camera.position; 
                    const dist = bot.mesh.position.distanceTo(targetPos);
                    
                    // Face the target
                    bot.mesh.lookAt(targetPos.x, bot.mesh.position.y + 2.4, targetPos.z);
                    
                    // 3. Combat Movement (Move towards or slightly away)
                    if(dist > 50) {
                        bot.mesh.translateZ(BOT_MOVE_SPEED * dt * 2); 
                    } else if (dist < 10) {
                        bot.mesh.rotation.y += Math.PI/2 * (Math.random() > 0.5 ? 1 : -1) * dt;
                        bot.mesh.translateZ(BOT_MOVE_SPEED * dt);
                    } else {
                        bot.mesh.translateZ(BOT_MOVE_SPEED * dt * 0.5);
                    }

                    // 4. Shoot Logic 
                    const weaponStats = bot.weapon.stats; 
                    if(dist < weaponStats.range && now - bot.lastShot > weaponStats.rate * 1000) { 
                        bot.lastShot = now;
                        
                        const fireOrigin = bot.mesh.position.clone().setY(bot.mesh.position.y + 2.4);
                        const fireDirection = new THREE.Vector3();
                        fireDirection.subVectors(targetPos.clone().setY(targetPos.y - 0.5), fireOrigin).normalize();

                        handleHitscan(bot.weapon, fireOrigin, fireDirection, bot);
                    }
                } else {
                    // 3. Constant World Movement (Wander, even when not close)
                    bot.moveCooldown -= dt * 1000;
                    if (bot.moveCooldown <= 0) {
                        // Pick new direction and set a new cooldown
                        bot.currentDirection = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                        bot.mesh.lookAt(bot.mesh.position.clone().add(bot.currentDirection));
                        bot.moveCooldown = Math.random() * BOT_MOVE_COOLDOWN_RANGE + 1000;
                    }

                    bot.mesh.translateZ(BOT_MOVE_SPEED * dt);
                }
            }
        }


        // ===============================================================
        // === VEHICLE LOGIC =============================================
        // ===============================================================

        function updateCars(dt) {
            for(const car of cars) {
                if(car.driving) {
                    const speed = inputs.w ? 15 : inputs.s ? -5 : 0;
                    car.speed = THREE.MathUtils.lerp(car.speed, speed, 0.1);

                    if (inputs.a || inputs.d) {
                        const rotationSpeed = dt * 1.5 * (inputs.d ? -1 : 1);
                        car.mesh.rotation.y += rotationSpeed * Math.sign(car.speed || 1);
                    }
                    
                    car.mesh.translateZ(car.speed * dt);
                    
                    // Car Hit Damage
                    if (Math.abs(car.speed) > 5) {
                        const currentPos = car.mesh.position;
                        
                        bots.forEach(bot => {
                            if (currentPos.distanceTo(bot.mesh.position) < 3) {
                                applyDamage(bot, 100, bot.mesh.position, player);
                            }
                        });
                    }

                    // Keep car on ground
                    const h = getTerrainHeight(car.mesh.position.x, car.mesh.position.z);
                    car.mesh.position.y = h;

                    // Update player position if driving
                    if(player.vehicle === car) {
                        camera.position.copy(car.mesh.position).add(new THREE.Vector3(0, PLAYER_HEIGHT + 1, 0));
                    }
                }
            }
        }


        // ===============================================================
        // === UI & RENDER FUNCTIONS =====================================
        // ===============================================================
        
        function updateUI() {
            player.health = Math.max(0, player.health);
            player.shield = Math.max(0, player.shield);
            document.getElementById('health-val').innerText = Math.ceil(player.health);
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('shield-val').innerText = Math.ceil(player.shield);
            document.getElementById('shield-bar').style.width = player.shield + '%';
            document.getElementById('wood-val').innerText = player.wood;
            
            document.getElementById('reload-msg').style.display = player.isReloading ? 'block' : 'none';

            player.inventory.forEach((item, i) => {
                const el = document.getElementById('slot-'+i);
                el.innerHTML = `<div class="slot-key">${i+1}</div>`;
                if(item) {
                    const icon = item.category === 'weapon' ? item.stats.icon : item.icon;
                    // Removed rarity letter from slot name (e.g., just "SMG")
                    const name = item.name; 
                    const count = item.category === 'consumable' ? item.count : '';

                    el.innerHTML += `<div class="slot-icon">${icon}</div><div class="slot-name">${name} ${count ? '['+count+']' : ''}</div>`;
                    let rarityKey = 'common';
                    if (item.rarity) {
                        rarityKey = Object.keys(RARITY_MULTIPLIERS).find(key => RARITY_MULTIPLIERS[key] === item.rarity).toLowerCase();
                    }
                    el.className = `slot ${i===player.slot ? 'active' : ''} rarity-${rarityKey}`;
                } else {
                    el.className = `slot ${i===player.slot ? 'active' : ''}`;
                }
            });
            
            let msg = player.vehicle ? "Exit Vehicle (E)" : "Interact (E)";
            if(!player.vehicle && player.inventory[player.slot]) {
                const currentItem = player.inventory[player.slot];
                if (currentItem.category === 'consumable' && (currentItem.type === 'health' || currentItem.type === 'shield' || currentItem.type === 'continuous')) {
                     msg = `Use ${currentItem.name} (E/X)`;
                } else {
                    msg = "Swap/Interact (E)";
                }
            }

            document.getElementById('interact-msg').innerText = msg;
            
            const showInteract = player.vehicle || chests.some(c => camera.position.distanceTo(c.position) < 6) || loot.some(l => camera.position.distanceTo(l.mesh.position) < 4) || doors.some(d => camera.position.distanceTo(d.mesh.position) < 5);
            const currentItem = player.inventory[player.slot];
            const showHealingPrompt = currentItem && currentItem.category === 'consumable' && currentItem.count > 0;
            
            document.getElementById('interact-msg').style.display = (showInteract || showHealingPrompt) ? 'block' : 'none';
        }
        
        function switchSlot(idx) {
            if (player.isHealing) {
                const currentHealingSlot = player.inventory.findIndex(i => i === player.healingItem);
                if (currentHealingSlot === player.slot) {
                    if (player.healingItem.continuous) return; 
                    finishHealing();
                }
            }
            if(idx < 0 || idx > 4) return;
            player.slot = idx;
            
            document.querySelectorAll('.slot').forEach((el, i) => {
                el.classList.toggle('active', i === idx);
            });
            
            if(viewModel) weaponScene.remove(viewModel);
            const item = player.inventory[idx];
            
            if(item && item.category === 'weapon') {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
                const mat = new THREE.MeshStandardMaterial({ color: item.rarity.color });
                viewModel = new THREE.Mesh(geo, mat);
                viewModel.position.set(0.2, -0.2, -0.5);
                weaponScene.add(viewModel);
                
                // Handle Crosshair/Scope for the new weapon
                let scopeType = item.stats.scope;
                const crosshair = document.getElementById('crosshair');
                const redDotScope = document.getElementById('red-dot-scope');
                
                crosshair.style.display = (scopeType) ? 'none' : 'block';
                redDotScope.style.display = 'none';

                if (player.ads) {
                    // Re-apply ads state based on the new weapon
                    toggleADS(true); 
                } else {
                    // Ensure FOV is reset if not ADS
                    camera.fov = 75;
                    camera.updateProjectionMatrix();
                }

            } else {
                document.getElementById('crosshair').style.display = 'block';
                toggleADS(false);
            }
            updateUI(); 
        }

        // ===============================================================
        // === INPUT & CONTROL MANAGEMENT (Mobile Fix) ====================
        // ===============================================================
        
        function setMobileMode(enable) {
            isMobileMode = enable;
            const mobileControls = document.getElementById('mobile-controls');
            const inventory = document.getElementById('inventory');
            const gameContainer = document.getElementById('game-container');

            if (enable) {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'block';
                inventory.classList.add('mobile');
                gameContainer.removeEventListener('mousedown', lockPointer);
            } else {
                if (controls) controls.enabled = true;
                mobileControls.style.display = 'none';
                inventory.classList.remove('mobile');
                gameContainer.addEventListener('mousedown', lockPointer);
            }
        }
        
        function lockPointer() {
            if (controls && !isMobileMode) {
                controls.lock();
                inputs.fire = false; 
            }
        }

        function setupPCLock() {
            if (controls) controls.enabled = true;
            document.getElementById('game-container').addEventListener('mousedown', lockPointer);
        }

        function setupInputs() {
            const gameContainer = document.getElementById('game-container');
            
            // 1. PC Mode: Keyboard
            const onKey = (e, v) => {
                if (!isMobileMode && controls.isLocked) {
                    if(e.code === 'KeyW') inputs.w = v;
                    if(e.code === 'KeyS') inputs.s = v;
                    if(e.code === 'KeyA') inputs.a = v;
                    if(e.code === 'KeyD') inputs.d = v;
                    if(e.code === 'ShiftLeft') inputs.sprint = v;
                    
                    if(e.code === 'Space' && v) inputs.jump = true; 
                    if(e.code === 'KeyR' && v) inputs.reload = true; 
                    if(e.code === 'KeyX' && v) useHealingItem(); 
                }
            };
            document.addEventListener('keydown', e => {
                onKey(e, true);
                if(!isMobileMode && controls.isLocked) {
                    if(e.code === 'Digit1') switchSlot(0);
                    if(e.code === 'Digit2') switchSlot(1);
                    if(e.code === 'Digit3') switchSlot(2);
                    if(e.code === 'Digit4') switchSlot(3);
                    if(e.code === 'Digit5') switchSlot(4);
                    if(e.code === 'KeyE') tryInteract(); 
                    if(e.code === 'KeyB') buildWall(); 
                }
            });
            document.addEventListener('keyup', e => onKey(e, false));
            
            // 2. PC Mode: Mouse buttons
            document.addEventListener('mousedown', e => {
                if(player.dead || isMobileMode || !controls.isLocked) return;
                if(e.button === 0) inputs.fire = true;
                if(e.button === 2) toggleADS(true);
            });
            document.addEventListener('mouseup', e => {
                if(player.dead || isMobileMode) return;
                if(e.button === 0) inputs.fire = false;
                if(e.button === 2) toggleADS(false);
            });

            // 3. Mobile Touch Logic (Left for Movement, Right for Camera)
            const touchZoneLeft = document.getElementById('stick-left');
            const touchZoneRight = document.getElementById('stick-right');
            const thumbLeft = document.getElementById('thumb-left');
            const sensitivity = 0.005; 

            const handleJoystickLeft = (e) => {
                if (!isMobileMode) return;
                
                const rect = document.getElementById('movement-zone-visual').getBoundingClientRect();
                let touch = Array.from(e.changedTouches).find(t => t.clientX < window.innerWidth / 2);
                if (!touch) return;
                
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                
                const maxDist = 40;
                let dx = touch.clientX - cx;
                let dy = touch.clientY - cy;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio; dy *= ratio;
                }
                
                thumbLeft.style.transform = `translate(${dx}px, ${dy}px)`;
                
                inputs.w = dy < -10; inputs.s = dy > 10;
                inputs.a = dx < -10; inputs.d = dx > 10;
                inputs.sprint = dist > 30; 
            };

            const resetStickLeft = () => {
                if (!isMobileMode) return;
                thumbLeft.style.transform = `translate(-50%, -50%)`; 
                inputs.w=false; inputs.s=false; inputs.a=false; inputs.d=false; inputs.sprint = false;
            };

            const activeTouchesRight = new Map();
            const handleLookRight = (e) => {
                if (!isMobileMode) return;
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    if (touch.clientX >= window.innerWidth / 2) { 
                        if (!activeTouchesRight.has(touch.identifier)) {
                            activeTouchesRight.set(touch.identifier, { x: touch.clientX, y: touch.clientY });
                        } else {
                            const lastTouch = activeTouchesRight.get(touch.identifier);
                            const dx = touch.clientX - lastTouch.x;
                            const dy = touch.clientY - lastTouch.y;
                            
                            // *** MOBILE CAMERA FIX: Apply rotation directly for smooth, non-janky control ***
                            camera.rotation.y -= dx * sensitivity; 
                            camera.rotation.x -= dy * sensitivity; 
                            camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x)); // Clamp pitch
                            
                            // Update the last position for differential calculation
                            lastTouch.x = touch.clientX;
                            lastTouch.y = touch.clientY;
                        }
                    }
                }
            };
            
            const handleTouchEnd = (e) => {
                if (!isMobileMode) return;
                for (let touch of e.changedTouches) {
                    if (activeTouchesRight.has(touch.identifier)) {
                        activeTouchesRight.delete(touch.identifier);
                    }
                }
                if (Array.from(e.changedTouches).some(t => t.clientX < window.innerWidth / 2)) {
                    resetStickLeft();
                }
            };


            // Left Zone: Movement
            touchZoneLeft.addEventListener('touchstart', handleJoystickLeft, { passive: true });
            touchZoneLeft.addEventListener('touchmove', handleJoystickLeft, { passive: true });
            touchZoneLeft.addEventListener('touchend', handleTouchEnd);
            touchZoneLeft.addEventListener('touchcancel', handleTouchEnd);
            
            // Right Zone: Camera Look
            touchZoneRight.addEventListener('touchstart', handleLookRight, { passive: false }); 
            touchZoneRight.addEventListener('touchmove', handleLookRight, { passive: false });
            touchZoneRight.addEventListener('touchend', handleTouchEnd);
            touchZoneRight.addEventListener('touchcancel', handleTouchEnd);


            // 4. Mobile Buttons
            document.getElementById('btn-fire').addEventListener('touchstart', (e) => { 
                if (isMobileMode) { 
                    e.preventDefault(); 
                    inputs.fire = true; 
                } 
            });
            document.getElementById('btn-fire').addEventListener('touchend', (e) => { 
                if (isMobileMode) { 
                    e.preventDefault(); 
                    inputs.fire = false; 
                } 
            });
            document.getElementById('btn-jump').addEventListener('touchstart', (e) => { if (isMobileMode) { e.preventDefault(); inputs.jump = true; } });
            document.getElementById('btn-jump').addEventListener('touchend', (e) => { if (isMobileMode) { e.preventDefault(); inputs.jump = false; } });
            
            document.getElementById('btn-interact').addEventListener('touchstart', (e) => { 
                if (isMobileMode) { 
                    e.preventDefault(); 
                    tryInteract();     
                    useHealingItem(); 
                } 
            });
            
            document.getElementById('btn-build').addEventListener('touchstart', (e) => { if (isMobileMode) { e.preventDefault(); buildWall(); } });
            document.getElementById('btn-ads').addEventListener('touchstart', (e) => { if (isMobileMode) { e.preventDefault(); toggleADS(true); } });
            document.getElementById('btn-ads').addEventListener('touchend', (e) => { if (isMobileMode) { e.preventDefault(); toggleADS(false); } });
            
            // 5. Mobile Inventory Touch Handling
            for(let i=0; i<5; i++) {
                const slot = document.getElementById(`slot-${i}`);
                if (slot) {
                    slot.ontouchstart = (e) => {
                        if (isMobileMode) {
                            e.preventDefault(); 
                            switchSlot(i);
                        }
                    };
                }
            }
        }


        // ===============================================================
        // === INITIALIZATION & START GAME ===============================
        // ===============================================================

        function init() {
            // Load Victory Royales from Local Storage
            victoryRoyales = parseInt(localStorage.getItem('victoryRoyales')) || 0;
            document.getElementById('victory-royales-stat').innerText = `Victory Royales: ${victoryRoyales}`;
            
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            // Weapon Viewmodel Layer
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.autoClear = false; 
            const gameContainer = document.getElementById('game-container');
            gameContainer.appendChild(renderer.domElement);
            
            // 2. Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(100, 200, 100);
            sun.castShadow = true;
            sun.shadow.camera.right = 200; sun.shadow.camera.left = -200;
            sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            scene.add(sun);
            weaponScene.add(ambient.clone());
            weaponScene.add(sun.clone());
            
            // 3. Controls (Instantiated, but not enabled/locked yet)
            controls = new PointerLockControls(camera, document.body);
            setupInputs(); 

            // 4. Raycasters
            raycaster = new THREE.Raycaster();
            downRay = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, PLAYER_HEIGHT + 0.1);
            
            // 5. Starter Loot & UI (Initial State)
            giveItem(createWeaponItem('RFAR', 'COMMON'), 0);
            giveItem({ category: 'consumable', ...CONSUMABLES.MINI, count: 5 }, 1); 
            giveItem({ category: 'consumable', ...CONSUMABLES.CHUG, count: 1 }, 2);
            player.wood = 50; 
            updateUI();
            
            // The game loop starts immediately to render the world behind the start screen
            animate();
        }

        window.startGame = (isMobile) => {
            document.getElementById('start-screen').style.display = 'none';
            gameStarted = true;
            
            isMobileMode = isMobile;
            BOT_COUNT = isMobile ? 20 : 25; // Player + 20 bots = 21 total, Player + 25 bots = 26 total
            
            if (isMobile) {
                setMobileMode(true);
            } else {
                setMobileMode(false);
                setupPCLock(); 
            }
            
            // 6. World Generation (Needs to happen AFTER BOT_COUNT is set)
            generateTerrain(); 
            generatePOIs(); 
            spawnBots();
            spawnCars();
            // Ensure the rare Strangled Rifle spawns
            spawnLoot(10, getTerrainHeight(10, 10) + 1, 10, 'mythic'); 

            // Set player starting height
            camera.position.set(0, getTerrainHeight(0, 0) + PLAYER_HEIGHT + 2, 0);
            
            // 7. Start Storm Timer
            startStormTimer(); 
        };

        // ===============================================================
        // === CORE GAME LOOP (ANIMATE) ==================================
        // ===============================================================

        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            if(!gameStarted || player.dead) {
                renderer.clear();
                renderer.render(scene, camera);
                return;
            }

            // 0. Healing Update
            if (player.isHealing && player.healingItem) {
                if (player.healingItem.continuous) {
                    applyContinuousHealing(player.healingItem, dt);
                } else if (!player.healingItem.instant) {
                    inputs.fire = false;
                    inputs.w = inputs.a = inputs.s = inputs.d = false;
                }
            }


            // 1. Player Physics & Movement
            if(player.vehicle) {
                updateCars(dt);
            } else {
                const canMove = isMobileMode || controls.isLocked; 
                if (canMove) {
                    const currentSpeed = inputs.sprint ? SPRINT_SPEED : WALK_SPEED;
                    
                    const direction = new THREE.Vector3();
                    direction.setFromMatrixColumn(camera.matrix, 0); 
                    direction.crossVectors(camera.up, direction);
                    direction.y = 0;
                    direction.normalize();
                    
                    const right = new THREE.Vector3(-direction.z, 0, direction.x);

                    const yVelocity = velocity.y; 
                    velocity.set(0, yVelocity, 0); 

                    if(inputs.w) velocity.add(direction.clone().multiplyScalar(currentSpeed));
                    if(inputs.s) velocity.add(direction.clone().multiplyScalar(-currentSpeed));
                    if(inputs.a) velocity.add(right.clone().multiplyScalar(-currentSpeed));
                    if(inputs.d) velocity.add(right.clone().multiplyScalar(currentSpeed));
                    
                    camera.position.x += velocity.x * dt;
                    camera.position.z += velocity.z * dt;
                    velocity.y -= GRAVITY * dt; 
                    
                    const groundY = getTerrainHeight(camera.position.x, camera.position.z);
                    let floorY = groundY;
                    
                    downRay.ray.origin.copy(camera.position);
                    const hits = downRay.intersectObjects(objects.filter(obj => !doors.map(d=>d.mesh).includes(obj)), false); 
                    
                    if(hits.length > 0) {
                        const closestHit = hits[0];
                        if (closestHit.point.y > groundY + 0.1) { 
                            floorY = closestHit.point.y;
                        }
                    }
                    
                    if (camera.position.y <= floorY + PLAYER_HEIGHT && velocity.y <= 0) {
                        camera.position.y = floorY + PLAYER_HEIGHT;
                        velocity.y = 0;
                        isGrounded = true;
                    } else {
                        isGrounded = false;
                    }
                    
                    if(inputs.jump && isGrounded) {
                        velocity.y = JUMP_FORCE;
                        isGrounded = false;
                        inputs.jump = false; 
                        playSound('jump');
                    }
                    
                    camera.position.y += velocity.y * dt;
                } else {
                    velocity.x = 0; 
                    velocity.z = 0;
                }
            }


            // 2. Shooting & Projectiles
            const canFire = isMobileMode || controls.isLocked; 
            if(inputs.fire && !player.vehicle && !player.isHealing && canFire) {
                const item = player.inventory[player.slot];
                if(item && item.category === 'weapon') {
                    if (item.stats.burst) {
                        if (now - lastShot > item.stats.burstDelay) {
                            shoot(item);
                        }
                    } else if(now - lastShot > item.stats.rate * 1000) {
                        shoot(item);
                    }
                }
            } else if (inputs.reload) {
                reload();
                inputs.reload = false;
            }
            
            // updateProjectiles(dt); // Placeholder

            // 3. AI Update
            updateBots(dt, now);
            updateStorm(now); 

            // 4. Render
            renderer.clear();
            renderer.render(scene, camera);
            renderer.clearDepth();
            renderer.render(weaponScene, weaponCamera);
            
            // 5. UI Updates
            updateUI();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            weaponCamera.aspect = window.innerWidth / window.innerHeight;
            weaponCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.selectSlot = switchSlot;
        
        // Final call to start the game
        init();
    </script>
</body>
</html>
