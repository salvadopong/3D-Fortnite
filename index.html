<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Battle Royale: V19.8 - Ultimate Edition</title>
    <style>
        /* ======================================= */
        /* === V19.8 ULTIMATE UI REDESIGN === */
        /* ======================================= */
        
        * {
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Poppins', 'Verdana', sans-serif; 
            user-select: none; 
            background: #000;
            touch-action: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            color: white;
        }

        /* --- PRE-GAME START SCREEN (Ultimate Design) --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a2a 0%, #1a1a4a 50%, #0a0a2a 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 1000;
            text-align: center;
            animation: fadeIn 0.8s ease-out;
            overflow: hidden;
        }
        
        /* Animated background particles */
        .particles {
            position: absolute;
            width: 100%; height: 100%;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            background: rgba(0, 210, 255, 0.1);
            border-radius: 50%;
            animation: float 20s infinite linear;
        }
        
        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); }
            100% { transform: translateY(-100px) rotate(360deg); }
        }

        #start-screen h1 { 
            font-size: 5rem; 
            margin-bottom: 1rem; 
            background: linear-gradient(135deg, #00d2ff 0%, #0072ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            letter-spacing: 2px;
            animation: slideDown 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            z-index: 2;
            text-shadow: 0 10px 30px rgba(0, 210, 255, 0.3);
        }
        
        #start-screen h1::after {
            content: 'V19.8';
            display: block;
            font-size: 1.5rem;
            color: #ffd700;
            margin-top: 0.5rem;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            animation: glow 3s infinite alternate;
        }
        
        @keyframes glow {
            0% { text-shadow: 0 0 10px rgba(255, 215, 0, 0.7); }
            100% { text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 50px rgba(255, 215, 0, 0.5); }
        }

        #start-screen .subtitle { 
            font-size: 1.3rem; 
            margin-bottom: 3rem; 
            color: rgba(255,255,255,0.8);
            animation: fadeIn 1s ease-out 0.5s backwards;
            position: relative;
            z-index: 2;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
            z-index: 2;
            animation: scaleIn 0.8s ease-out 0.8s backwards;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            margin-bottom: 2rem;
        }
        
        .game-button {
            padding: 1.2rem 2.5rem; 
            margin: 0; 
            font-size: 1.3rem;
            background: linear-gradient(135deg, #00d2ff, #0072ff);
            color: white; 
            border: none; 
            border-radius: 15px; 
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Poppins', sans-serif; 
            font-weight: 600;
            box-shadow: 
                0 10px 30px rgba(0, 114, 255, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        .game-button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.6s;
        }
        
        .game-button:hover::before {
            left: 100%;
        }
        
        .game-button:hover { 
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 15px 40px rgba(0, 114, 255, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        .game-button:active { 
            transform: scale(0.98) translateY(0); 
            box-shadow: 0 5px 20px rgba(0, 114, 255, 0.3);
            transition: transform 0.1s;
        }
        
        .game-button.mobile { 
            background: linear-gradient(135deg, #ffaa00, #ff6600);
        }
        
        .game-button.mobile:hover { 
            background: linear-gradient(135deg, #ff8800, #ff4400); 
        }
        
        .game-button.controller { 
            background: linear-gradient(135deg, #8a2be2, #4b0082);
        }
        
        .game-button.controller:hover { 
            background: linear-gradient(135deg, #7a1bd2, #3b0072); 
        }
        
        /* Controller Connected Notification */
        .controller-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #8a2be2, #4b0082);
            color: white;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-weight: 600;
            z-index: 1001;
            display: none;
            animation: slideInRight 0.5s ease-out;
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.4);
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        @keyframes slideInRight {
            0% { transform: translateX(100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }
        
        /* Stats display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 2rem;
            animation: fadeIn 1s ease-out 1s backwards;
            position: relative;
            z-index: 2;
            max-width: 800px;
            width: 100%;
        }
        
        .stat-item {
            background: rgba(0, 0, 0, 0.6);
            padding: 1.2rem;
            border-radius: 12px;
            border: 2px solid rgba(0, 210, 255, 0.2);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
        }
        
        .stat-item:hover {
            transform: translateY(-5px);
            border-color: rgba(0, 210, 255, 0.4);
            box-shadow: 0 10px 30px rgba(0, 210, 255, 0.2);
        }
        
        .stat-item h3 {
            margin: 0 0 0.5rem 0;
            color: #00d2ff;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-item p {
            margin: 0;
            color: #ffd700;
            font-size: 1.8rem;
            font-weight: 700;
        }
        
        /* === NEW LEVELING SYSTEM UI === */
        #level-stats {
            position: absolute; 
            bottom: 2rem; 
            font-size: 1.1rem;
            color: #ffd700; 
            font-weight: 600;
            background: rgba(0,0,0,0.7);
            padding: 1rem 2rem;
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            z-index: 2;
            animation: fadeIn 1s ease-out 1.5s backwards;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .level-display {
            font-size: 1.4rem;
            color: #00d2ff;
            text-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }
        
        .progress-bar {
            width: 200px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.3rem;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d2ff, #0072ff);
            transition: width 0.5s ease;
            border-radius: 4px;
        }
        
        .progress-text {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.8);
            margin-top: 0.3rem;
        }

        /* === NEW ULTIMATE CROSSHAIR === */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 32px; height: 32px; 
            transform: translate(-50%, -50%); 
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.95;
            z-index: 10;
            pointer-events: none;
            filter: drop-shadow(0 0 8px rgba(255, 77, 77, 0.7));
        }
        
        .crosshair-dot {
            position: absolute;
            width: 6px; height: 6px;
            background: #ff4d4d;
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 12px #ff4d4d,
                0 0 24px rgba(255, 77, 77, 0.7);
            animation: crosshairPulse 2s infinite alternate;
        }
        
        @keyframes crosshairPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            100% { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        .crosshair-line {
            position: absolute;
            background: #ff4d4d;
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(255, 77, 77, 0.9);
        }
        
        .ch-h { 
            width: 100%; height: 3px; 
            top: 50%; left: 0; 
            margin-top: -1.5px; 
        }
        
        .ch-v { 
            height: 100%; width: 3px; 
            left: 50%; top: 0; 
            margin-left: -1.5px; 
        }

        /* Enhanced Scopes */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 18%, rgba(0, 0, 0, 0.98) 19%, black 100%);
            display: none; pointer-events: none; z-index: 100; 
        }
        
        #scope-lines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(to right, rgba(255,255,255,0.1) 1px, transparent 1px) 0 0 / 25px 25px,
                linear-gradient(to bottom, rgba(255,255,255,0.1) 1px, transparent 1px) 0 0 / 25px 25px;
            opacity: 0.5;
        }
        
        #red-dot-scope {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none;
            pointer-events: none;
            background: radial-gradient(circle, transparent 45%, rgba(0,0,0,0.85) 46%, rgba(0,0,0,0.95) 100%);
        }
        
        .red-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: #ff0000; 
            box-shadow: 
                0 0 20px #ff0000,
                0 0 40px #ff0000,
                0 0 60px rgba(255, 0, 0, 0.5);
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            animation: pulseRed 0.8s infinite alternate;
        }
        
        @keyframes pulseRed {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.4); opacity: 0.8; }
        }
        
        .red-line {
            position: absolute; background: rgba(255, 0, 0, 0.2);
        }
        .red-line.h { width: 100%; height: 1px; top: 50%; }
        .red-line.v { height: 100%; width: 1px; left: 50%; }

        /* Storm Visuals */
        #storm-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, 
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.15) 40%,
                rgba(75, 0, 130, 0.25) 60%,
                rgba(75, 0, 130, 0.35) 80%,
                rgba(75, 0, 130, 0.45) 100%);
            mix-blend-mode: multiply; 
            pointer-events: none; 
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 50; 
        }
        
        #storm-overlay.in-storm {
            background: radial-gradient(circle at 50% 50%,
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.25) 30%,
                rgba(75, 0, 130, 0.45) 50%,
                rgba(75, 0, 130, 0.65) 70%,
                rgba(75, 0, 130, 0.85) 100%);
            animation: stormPulse 2s infinite alternate;
        }
        
        @keyframes stormPulse {
            0% { opacity: 0.9; }
            100% { opacity: 1; }
        }

        /* === REDESIGNED ULTIMATE HUD === */
        #hud-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        /* === UPDATED: Smaller Top Bar === */
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1.5rem;
            background: rgba(10, 10, 30, 0.9);
            backdrop-filter: blur(25px);
            padding: 0.8rem 1.5rem;
            border-radius: 15px;
            border: 2px solid rgba(0, 210, 255, 0.4);
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.7),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 20px rgba(0, 210, 255, 0.3);
            z-index: 20;
        }
        
        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 110px;
        }
        
        .hud-label {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.8);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 0.3rem;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        
        .hud-value {
            font-size: 1.8rem;
            font-weight: 900;
            color: white;
            text-shadow: 
                0 2px 8px rgba(0,0,0,0.5),
                0 0 15px currentColor;
            letter-spacing: 0.5px;
        }
        
        #alive-count { 
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        #storm-timer { 
            color: #a335ee;
            text-shadow: 0 0 15px rgba(163, 53, 238, 0.5);
        }
        #storm-status {
            color: #00d2ff;
            text-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
        }

        /* === UPDATED: Smaller Player Stats === */
        #player-stats {
            position: absolute;
            bottom: 2rem;
            left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            width: 250px;
            z-index: 20;
        }
        
        .stat-card {
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, 0.85) 0%,
                rgba(20, 20, 40, 0.85) 100%);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 0.8rem 1.2rem;
            border: 2px solid rgba(255,255,255,0.15);
            box-shadow: 
                0 8px 30px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.1),
                0 0 20px rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.05) 0%,
                transparent 100%);
            z-index: 1;
        }
        
        .stat-card:hover {
            border-color: rgba(0, 210, 255, 0.4);
            transform: translateY(-5px) scale(1.02);
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 30px rgba(0, 210, 255, 0.4);
        }
        
        .stat-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.6rem;
            position: relative;
            z-index: 2;
        }
        
        .stat-icon {
            font-size: 1.1rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.15) 0%,
                rgba(255,255,255,0.05) 100%);
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.1),
                0 3px 12px rgba(0,0,0,0.3);
        }
        
        .stat-title {
            flex: 1;
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(255,255,255,0.95);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        
        .stat-value {
            font-size: 1.2rem;
            font-weight: 900;
            color: #ffd700;
            min-width: 50px;
            text-align: right;
            text-shadow: 
                0 2px 8px rgba(0,0,0,0.5),
                0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        .stat-bar-container {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            z-index: 2;
            box-shadow: 
                inset 0 1px 3px rgba(0,0,0,0.5),
                0 2px 5px rgba(0,0,0,0.3);
        }
        
        .stat-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.4), 
                transparent);
            animation: barShine 2.5s infinite linear;
        }
        
        .stat-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.2) 0%,
                transparent 50%,
                rgba(255,255,255,0.1) 100%);
        }
        
        @keyframes barShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #health-bar { 
            background: linear-gradient(90deg, 
                #ff4d4d 0%, 
                #ff8888 50%, 
                #ffaaaa 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(255, 77, 77, 0.5);
        }
        
        #shield-bar { 
            background: linear-gradient(90deg, 
                #0072ff 0%, 
                #00a8ff 50%, 
                #00d2ff 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(0, 114, 255, 0.5);
        }
        
        #overshield-bar { 
            background: linear-gradient(90deg, 
                #ffaa00 0%, 
                #ffcc00 50%, 
                #ffff00 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(255, 170, 0, 0.5);
        }

        /* === UPDATED: Smaller Resources Bar === */
        #resources-bar {
            display: flex;
            gap: 1rem;
            margin-top: 0.8rem;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.6rem 1rem;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.1) 0%,
                rgba(255,255,255,0.05) 100%);
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.15);
            box-shadow: 
                0 5px 15px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .resource-item:hover {
            transform: translateY(-3px);
            border-color: rgba(222, 184, 135, 0.4);
            box-shadow: 
                0 8px 25px rgba(0,0,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 15px rgba(222, 184, 135, 0.3);
        }
        
        .resource-icon {
            font-size: 1.2rem;
            color: #deb887;
            text-shadow: 0 0 8px rgba(222, 184, 135, 0.5);
        }
        
        .resource-amount {
            font-size: 1.1rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        /* === UPDATED: Smaller Inventory === */
        #inventory-hud {
            position: absolute;
            bottom: 10rem;
            right: 1.5rem;
            display: flex;
            gap: 0.6rem;
            z-index: 20;
        }
        
        .inventory-slot {
            width: 70px;
            height: 85px;
            background: linear-gradient(135deg, 
                rgba(10, 10, 30, 0.95) 0%,
                rgba(20, 20, 40, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 
                0 8px 25px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .inventory-slot::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.05) 0%,
                transparent 100%);
        }
        
        .inventory-slot:hover {
            transform: translateY(-6px) scale(1.08);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 
                0 15px 35px rgba(0,0,0,0.7),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 25px rgba(255,255,255,0.2);
        }
        
        .inventory-slot.active {
            border-color: #ff4d4d;
            transform: translateY(-10px) scale(1.12);
            background: linear-gradient(135deg, 
                rgba(30, 30, 50, 0.98) 0%,
                rgba(40, 40, 60, 0.98) 100%);
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.8),
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 0 30px rgba(255, 77, 77, 0.5);
        }
        
        .slot-key {
            position: absolute;
            top: 6px;
            left: 6px;
            font-size: 0.75rem;
            color: rgba(255,255,255,0.8);
            font-weight: 700;
            background: rgba(0,0,0,0.6);
            padding: 0.2rem 0.5rem;
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.2);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .slot-icon {
            font-size: 1.8rem;
            margin-bottom: 0.4rem;
            text-shadow: 0 0 12px currentColor;
            filter: drop-shadow(0 0 4px currentColor);
        }
        
        .slot-name {
            font-size: 0.6rem;
            font-weight: 700;
            color: rgba(255,255,255,0.95);
            text-transform: uppercase;
            text-align: center;
            max-width: 60px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 0 0.2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .slot-count {
            position: absolute;
            bottom: 6px;
            right: 6px;
            font-size: 0.75rem;
            font-weight: 900;
            color: #ffd700;
            background: rgba(0,0,0,0.6);
            padding: 0.2rem 0.5rem;
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.2);
            text-shadow: 
                0 2px 4px rgba(0,0,0,0.5),
                0 0 8px rgba(255, 215, 0, 0.5);
        }
        
        /* Rarity Borders */
        .rarity-common { 
            border-bottom: 4px solid #b0b0b0;
            box-shadow: 0 0 15px rgba(176, 176, 176, 0.3);
        }
        .rarity-uncommon { 
            border-bottom: 4px solid #28a745;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.3);
        }
        .rarity-rare { 
            border-bottom: 4px solid #007bff;
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.3);
        }
        .rarity-epic { 
            border-bottom: 4px solid #a335ee;
            box-shadow: 0 0 15px rgba(163, 53, 238, 0.3);
        }
        .rarity-legendary { 
            border-bottom: 4px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }
        .rarity-mythic { 
            border-bottom: 4px solid #ff4d4d;
            box-shadow: 0 0 15px rgba(255, 77, 77, 0.3);
        }

        /* Center HUD Elements */
        #center-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.2rem;
            z-index: 15;
        }

        /* Interaction Prompt - Redesigned */
        #interact-prompt {
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.98), 
                rgba(255, 170, 0, 0.98));
            color: #000;
            padding: 1.2rem 2.5rem;
            border-radius: 16px;
            font-size: 1.2rem;
            font-weight: 800;
            display: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 
                0 15px 40px rgba(255, 215, 0, 0.5),
                0 8px 25px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.6);
            border: 4px solid rgba(255,255,255,0.6);
            backdrop-filter: blur(15px);
            animation: pulsePrompt 1.5s infinite alternate;
            pointer-events: none;
            position: relative;
            overflow: hidden;
        }
        
        #interact-prompt::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                transparent 0%,
                rgba(255,255,255,0.3) 50%,
                transparent 100%);
            animation: promptShine 3s infinite linear;
        }
        
        @keyframes promptShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes pulsePrompt {
            0% { transform: translateY(-50%) scale(1); box-shadow: 0 15px 40px rgba(255, 215, 0, 0.5); }
            100% { transform: translateY(-50%) scale(1.08); box-shadow: 0 20px 50px rgba(255, 215, 0, 0.7); }
        }

        /* Reload Indicator - Redesigned */
        #reload-indicator {
            background: linear-gradient(135deg, 
                rgba(255, 0, 0, 0.98), 
                rgba(255, 68, 68, 0.98));
            color: white;
            padding: 1rem 2rem;
            border-radius: 14px;
            font-size: 1.1rem;
            font-weight: 800;
            display: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 
                0 15px 40px rgba(255, 0, 0, 0.5),
                0 8px 25px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            border: 3px solid rgba(255,255,255,0.4);
            backdrop-filter: blur(15px);
            animation: reloadPulse 1s infinite alternate;
        }
        
        @keyframes reloadPulse {
            0% { opacity: 0.9; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.05); }
        }

        /* Healing Progress - Redesigned */
        #healing-progress {
            position: absolute;
            bottom: 12rem;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 45px;
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, 0.9) 0%,
                rgba(20, 20, 40, 0.9) 100%);
            border-radius: 25px;
            display: none;
            overflow: hidden;
            border: 3px solid rgba(0, 210, 255, 0.6);
            box-shadow: 
                0 15px 50px rgba(0, 210, 255, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
            backdrop-filter: blur(15px);
        }
        
        #healing-bar {
            height: 100%;
            background: linear-gradient(90deg, 
                #0072ff 0%, 
                #00d2ff 50%, 
                #00ffff 100%);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        #healing-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.5), 
                transparent);
            animation: healShine 1.2s infinite linear;
        }
        
        #healing-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.3) 0%,
                transparent 50%,
                rgba(255,255,255,0.1) 100%);
        }
        
        @keyframes healShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #healing-text {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 800;
            font-size: 1.2rem;
            text-shadow: 
                0 2px 10px rgba(0,0,0,0.8),
                0 0 20px rgba(0, 210, 255, 0.5);
            letter-spacing: 2px;
        }

        /* Damage Numbers - Redesigned */
        .dmg-number {
            position: absolute;
            color: white;
            font-weight: 900;
            font-size: 2.5rem;
            text-shadow: 
                2px 2px 8px rgba(0,0,0,0.9),
                0 0 20px currentColor,
                0 0 40px currentColor;
            pointer-events: none;
            animation: damageFloat 1.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            z-index: 999;
            font-family: 'Poppins', sans-serif;
            letter-spacing: 1px;
        }
        
        .dmg-number.headshot {
            color: #ff0000;
            font-size: 3rem;
            text-shadow: 
                0 0 25px #ff0000,
                0 0 50px #ff0000,
                0 0 75px rgba(255, 0, 0, 0.7);
        }
        
        .dmg-number.storm {
            color: #a335ee;
            font-size: 2.2rem;
            text-shadow: 
                0 0 25px #a335ee,
                0 0 45px rgba(163, 53, 238, 0.7);
        }
        
        @keyframes damageFloat { 
            0% { opacity: 1; transform: translateY(0) scale(1) rotate(0deg); } 
            30% { opacity: 1; transform: translateY(-20px) scale(1.1) rotate(-5deg); }
            70% { opacity: 1; transform: translateY(-60px) scale(1.3) rotate(5deg); }
            100% { opacity: 0; transform: translateY(-90px) scale(1.4) rotate(0deg); } 
        }

        /* === NEW: VISUAL EFFECTS === */
        .muzzle-flash {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff9900, #ff3300, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            animation: muzzleFlash 0.1s forwards;
            z-index: 100;
        }
        
        @keyframes muzzleFlash {
            0% { opacity: 1; transform: scale(0.5); }
            100% { opacity: 0; transform: scale(2); }
        }
        
        .bullet-trail {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #ff9900, #ff3300, transparent);
            pointer-events: none;
            animation: bulletTrail 0.2s forwards;
            z-index: 99;
        }
        
        @keyframes bulletTrail {
            0% { width: 0; opacity: 1; }
            100% { width: 50px; opacity: 0; }
        }
        
        .impact-effect {
            position: absolute;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, #ff6600, #ff0000, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            animation: impactEffect 0.3s forwards;
            z-index: 98;
        }
        
        @keyframes impactEffect {
            0% { opacity: 1; transform: scale(0.5); }
            100% { opacity: 0; transform: scale(2); }
        }
        
        .blood-effect {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #cc0000, #990000, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            animation: bloodEffect 0.4s forwards;
            z-index: 97;
        }
        
        @keyframes bloodEffect {
            0% { opacity: 1; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1.5); }
            100% { opacity: 0; transform: scale(2); }
        }

        /* === NEW: FPS COUNTER === */
        #fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-family: 'Poppins', monospace;
            font-size: 1rem;
            font-weight: 700;
            z-index: 1000;
            border: 1px solid rgba(0, 255, 0, 0.3);
            backdrop-filter: blur(10px);
            text-shadow: 0 0 10px #00ff00;
        }
        
        #fps-counter::before {
            content: 'FPS: ';
            color: rgba(255, 255, 255, 0.8);
        }

        /* === NEW: MINI-MAP === */
        #mini-map {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid rgba(0, 210, 255, 0.4);
            backdrop-filter: blur(10px);
            z-index: 1000;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }
        
        #mini-map-canvas {
            width: 100%;
            height: 100%;
        }
        
        .map-marker {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff4d4d;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        .map-marker.player {
            background: #00ff00;
            width: 6px;
            height: 6px;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .map-marker.bot {
            background: #ff4d4d;
            width: 4px;
            height: 4px;
        }
        
        .map-marker.chest {
            background: #ffd700;
            width: 4px;
            height: 4px;
        }

        /* === NEW: KILL FEED === */
        #kill-feed {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 999;
            pointer-events: none;
        }
        
        .kill-feed-item {
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, 0.8),
                rgba(20, 20, 40, 0.8));
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            animation: slideInRight 0.3s ease-out;
            border-left: 4px solid #ff4d4d;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transform: translateX(100%);
            animation: slideInKill 0.3s forwards, slideOutKill 0.3s forwards 3s;
        }
        
        @keyframes slideInKill {
            0% { transform: translateX(100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutKill {
            0% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(100%); opacity: 0; }
        }
        
        .kill-feed-item.headshot {
            border-left-color: #ff0000;
        }
        
        .kill-feed-item .killer {
            color: #00d2ff;
            font-weight: 700;
        }
        
        .kill-feed-item .victim {
            color: #ff4d4d;
            font-weight: 700;
        }

        /* === NEW: HIT MARKER === */
        .hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%) scale(0);
            pointer-events: none;
            z-index: 999;
            animation: hitMarker 0.2s forwards;
        }
        
        .hit-marker::before,
        .hit-marker::after {
            content: '';
            position: absolute;
            background: #ffffff;
            border-radius: 1px;
            box-shadow: 0 0 10px #ff0000;
        }
        
        .hit-marker::before {
            width: 4px;
            height: 20px;
            top: 5px;
            left: 13px;
        }
        
        .hit-marker::after {
            width: 20px;
            height: 4px;
            top: 13px;
            left: 5px;
        }
        
        @keyframes hitMarker {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        /* === NEW: SETTINGS MENU === */
        #settings-menu {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            z-index: 2000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .settings-content {
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.95),
                rgba(10, 10, 30, 0.95));
            padding: 2rem 3rem;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid rgba(0, 210, 255, 0.4);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }
        
        .settings-title {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #00d2ff, #0072ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 800;
        }
        
        .settings-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }
        
        .settings-close:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .settings-group {
            margin-bottom: 2rem;
            background: rgba(0,0,0,0.3);
            padding: 1.5rem;
            border-radius: 12px;
        }
        
        .settings-group-title {
            font-size: 1.3rem;
            color: #00d2ff;
            margin-bottom: 1rem;
            font-weight: 700;
        }
        
        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.8rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .settings-item:last-child {
            border-bottom: none;
        }
        
        .settings-label {
            font-size: 1.1rem;
            color: rgba(255,255,255,0.9);
        }
        
        .settings-slider {
            width: 200px;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d2ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }
        
        .settings-select {
            background: rgba(0,0,0,0.5);
            color: white;
            border: 2px solid rgba(0,210,255,0.3);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            font-size: 1rem;
            outline: none;
            cursor: pointer;
        }
        
        .settings-toggle {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255,255,255,0.1);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .settings-toggle.active {
            background: #00d2ff;
        }
        
        .settings-toggle::before {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        
        .settings-toggle.active::before {
            transform: translateX(24px);
        }

        /* === NEW: PAUSE MENU === */
        #pause-menu {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .pause-content {
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.95),
                rgba(10, 10, 30, 0.95));
            padding: 3rem 4rem;
            border-radius: 20px;
            text-align: center;
            border: 2px solid rgba(0, 210, 255, 0.4);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
        }
        
        .pause-title {
            font-size: 3.5rem;
            background: linear-gradient(135deg, #00d2ff, #0072ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
            font-weight: 900;
        }
        
        .pause-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin: 2rem 0;
            padding: 2rem;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
        }
        
        .pause-stat {
            text-align: left;
        }
        
        .pause-stat-label {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .pause-stat-value {
            font-size: 1.5rem;
            color: #ffd700;
            font-weight: 700;
        }

        /* === NEW: DAY/NIGHT CYCLE OVERLAY === */
        #day-night-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 49;
            transition: background 5s linear;
        }

        /* === NEW: WEATHER EFFECTS === */
        #weather-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 48;
        }
        
        .rain-drop {
            position: absolute;
            width: 1px;
            height: 20px;
            background: rgba(255,255,255,0.3);
            animation: rainFall 1s linear infinite;
        }
        
        @keyframes rainFall {
            0% { transform: translateY(-100px); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(100vh); opacity: 0; }
        }

        /* === NEW: CHARACTER CUSTOMIZATION === */
        #character-customization {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            z-index: 2000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .character-content {
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.95),
                rgba(10, 10, 30, 0.95));
            padding: 3rem;
            border-radius: 20px;
            max-width: 800px;
            width: 90%;
            border: 2px solid rgba(0, 210, 255, 0.4);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
        }
        
        .skin-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin: 2rem 0;
        }
        
        .skin-item {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .skin-item:hover {
            border-color: rgba(0,210,255,0.3);
            transform: translateY(-5px);
        }
        
        .skin-item.selected {
            border-color: #00d2ff;
            background: rgba(0,210,255,0.1);
        }
        
        .skin-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }
        
        .skin-name {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.9);
        }

        /* Controller Layout Display - REMOVED as requested */
        #controller-layout {
            display: none !important;
        }

        /* --- MOBILE CONTROLS (IMPROVED: 50/50 split) --- */
        #mobile-controls {
            display: none; 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none;
            z-index: 5;
        }
        
        /* UPDATED: Left side - Movement joystick area (50%) */
        #touch-left {
            position: absolute;
            top: 0; left: 0;
            width: 50%; height: 100%;
            pointer-events: auto;
            touch-action: none;
            z-index: 6;
        }
        
        /* UPDATED: Right side - Camera control area (50%) - invisible joystick */
        #touch-right {
            position: absolute;
            top: 0; right: 0;
            width: 50%; height: 100%;
            background: transparent;
            pointer-events: auto;
            touch-action: none;
            z-index: 6;
        }
        
        /* Movement Zone - Updated */
        #movement-zone {
            position: absolute;
            bottom: 180px;
            left: 80px;
            width: 180px;
            height: 180px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.08) 0%,
                rgba(255,255,255,0.03) 70%,
                transparent 71%);
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.2);
            pointer-events: none;
            box-shadow: 
                0 15px 40px rgba(0,0,0,0.5),
                inset 0 0 30px rgba(255,255,255,0.1);
            z-index: 7;
            opacity: 0.9;
            display: none;
        }
        
        .joystick-thumb {
            position: absolute;
            top: 50%; left: 50%;
            width: 70px; height: 70px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.4) 0%,
                rgba(255,255,255,0.2) 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 8px 25px rgba(0,0,0,0.6),
                inset 0 0 20px rgba(255,255,255,0.3);
            border: 3px solid rgba(255,255,255,0.4);
            pointer-events: none;
            transition: transform 0.08s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 8;
        }

        /* Camera Zone - Improved: Visual feedback for camera area */
        #camera-zone {
            position: absolute;
            top: 0; right: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle at 80% 50%, 
                rgba(0, 210, 255, 0.05) 0%,
                transparent 70%);
            pointer-events: none;
            z-index: 6;
        }

        /* Mobile Action Buttons - UPDATED: Raised position */
        .mobile-button {
            position: absolute;
            width: 85px; height: 85px;
            border-radius: 50%;
            background: linear-gradient(135deg, 
                rgba(30, 30, 40, 0.95),
                rgba(20, 20, 30, 0.95));
            border: 4px solid rgba(255,255,255,0.3);
            color: white;
            font-weight: 800;
            font-size: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            text-align: center;
            text-transform: uppercase;
            z-index: 10;
            box-shadow: 
                0 12px 35px rgba(0,0,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 20px rgba(255,255,255,0.1);
            transition: all 0.12s cubic-bezier(0.4, 0, 0.2, 1);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .mobile-button:active {
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.4),
                rgba(255,255,255,0.3));
            transform: scale(0.88);
            box-shadow: 
                0 6px 20px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 30px rgba(255,255,255,0.3);
        }
        
        #btn-fire { 
            bottom: 180px; right: 40px; 
            width: 100px; height: 100px;
            border-color: #ff4444;
            background: linear-gradient(135deg, 
                rgba(255,0,0,0.6),
                rgba(255,68,68,0.5));
            font-size: 1.3rem;
            box-shadow: 
                0 15px 40px rgba(255,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 30px rgba(255,0,0,0.3);
        }
        
        #btn-fire:active {
            box-shadow: 
                0 8px 25px rgba(255,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 40px rgba(255,0,0,0.5);
        }
        
        #btn-jump { 
            bottom: 300px; right: 50px;
            border-color: #00d2ff;
            background: linear-gradient(135deg,
                rgba(0,210,255,0.6),
                rgba(0,168,255,0.5));
            box-shadow: 0 0 25px rgba(0, 210, 255, 0.4);
        }
        
        #btn-interact { 
            bottom: 250px; right: 140px;
            border-color: #ffd700;
            color: #ffd700;
            background: linear-gradient(135deg,
                rgba(255,215,0,0.4),
                rgba(255,170,0,0.3));
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.3);
        }
        
        #btn-build { 
            bottom: 330px; right: 140px;
            border-color: #8B4513;
            background: linear-gradient(135deg,
                rgba(139,69,19,0.6),
                rgba(160,82,45,0.5));
            box-shadow: 0 0 25px rgba(139, 69, 19, 0.3);
        }
        
        #btn-ads { 
            bottom: 120px; right: 160px;
            width: 75px; height: 75px;
            font-size: 0.9rem;
            border-color: #007bff;
            background: linear-gradient(135deg,
                rgba(0,123,255,0.6),
                rgba(0,82,204,0.5));
            box-shadow: 0 0 20px rgba(0, 123, 255, 0.3);
        }
        
        #btn-reload { 
            top: 200px; right: 40px;
            width: 70px; height: 70px;
            font-size: 0.85rem;
            border-color: #00d2ff;
            background: linear-gradient(135deg,
                rgba(0,210,255,0.6),
                rgba(0,168,255,0.5));
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.3);
            display: none;
        }

        /* === ULTIMATE VICTORY & ELIMINATED SCREENS === */
        #victory-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(255, 215, 0, 0.9),
                rgba(255, 140, 0, 0.95));
            backdrop-filter: blur(30px);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            animation: fadeIn 0.5s ease-out forwards;
            overflow: hidden;
        }
        
        .victory-particles {
            position: absolute;
            width: 100%; height: 100%;
        }
        
        .victory-particle {
            position: absolute;
            width: 12px; height: 12px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            animation: victoryParticleFloat 8s infinite linear;
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.7);
        }
        
        @keyframes victoryParticleFloat {
            0% { transform: translateY(100vh) rotate(0deg) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(90vh) rotate(0deg) scale(1); }
            90% { opacity: 1; transform: translateY(10vh) rotate(360deg) scale(1); }
            100% { transform: translateY(0) rotate(720deg) scale(0); opacity: 0; }
        }
        
        #victory-text {
            font-size: 0;
            background: linear-gradient(135deg, #ffd700, #ffaa00, #ff6600, #ff0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            animation: victoryText 3.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards,
                       victoryPulse 2s infinite alternate 3.5s;
            position: relative;
            text-shadow: 
                0 15px 50px rgba(255, 215, 0, 0.6),
                0 0 80px rgba(255, 170, 0, 0.4),
                0 0 120px rgba(255, 100, 0, 0.3);
            letter-spacing: -10px;
            opacity: 0;
            white-space: nowrap;
            z-index: 2;
        }
        
        #victory-text::after {
            content: 'V19.8';
            display: block;
            font-size: 2.5rem;
            margin-top: 1.5rem;
            color: #ffffff;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.9);
            animation: versionPulse 3s infinite alternate;
        }
        
        @keyframes versionPulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.15); }
        }
        
        @keyframes victoryText {
            0% { font-size: 0; transform: scale(0) rotate(-20deg); opacity: 0; letter-spacing: 100px; }
            30% { font-size: 9rem; transform: scale(1.5) rotate(15deg); opacity: 1; letter-spacing: -10px; }
            50% { font-size: 9rem; transform: scale(1.5) rotate(-5deg); opacity: 1; letter-spacing: -5px; }
            70% { font-size: 9rem; transform: scale(1.3) rotate(5deg); opacity: 1; letter-spacing: -2px; }
            100% { font-size: 7rem; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0; }
        }
        
        @keyframes victoryPulse {
            0% { transform: scale(1); text-shadow: 0 15px 50px rgba(255, 215, 0, 0.6); }
            100% { transform: scale(1.1); text-shadow: 0 20px 60px rgba(255, 215, 0, 0.9), 0 0 100px rgba(255, 170, 0, 0.5); }
        }
        
        #victory-stats {
            font-size: 2.8rem;
            color: white;
            margin-top: 3rem;
            opacity: 0;
            animation: fadeUp 1s ease-out 4s forwards;
            text-shadow: 0 8px 25px rgba(0,0,0,0.7);
            z-index: 2;
        }
        
        /* === NEW: LEVEL UP STATS SCREEN === */
        #level-stats-screen {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(0, 100, 255, 0.95),
                rgba(138, 43, 226, 0.97));
            backdrop-filter: blur(30px);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1001;
            pointer-events: auto;
            text-align: center;
            overflow: hidden;
            animation: fadeIn 0.5s ease-out;
        }
        
        #level-stats-title {
            font-size: 4rem;
            background: linear-gradient(135deg, #00d2ff, #0072ff, #a335ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
            font-weight: 900;
            text-shadow: 0 15px 40px rgba(0, 210, 255, 0.5);
            animation: slideDown 1s ease-out;
        }
        
        .stats-breakdown {
            background: rgba(0, 0, 0, 0.7);
            padding: 2rem;
            border-radius: 20px;
            margin: 2rem 0;
            max-width: 600px;
            width: 90%;
            border: 3px solid rgba(0, 210, 255, 0.5);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            animation: scaleIn 0.8s ease-out 0.5s backwards;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            font-size: 1.2rem;
            color: rgba(255,255,255,0.9);
            text-align: left;
        }
        
        .stat-value {
            font-size: 1.4rem;
            font-weight: 800;
            color: #ffd700;
            text-align: right;
        }
        
        .total-points {
            font-size: 2.5rem;
            color: #00ff00;
            font-weight: 900;
            margin: 1.5rem 0;
            text-shadow: 0 0 30px #00ff00;
            animation: pulse 1s infinite alternate;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }
        
        .level-progress-container {
            margin-top: 2rem;
            width: 80%;
            max-width: 400px;
        }
        
        .level-progress-text {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .level-progress-bar {
            height: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 7px;
            overflow: hidden;
        }
        
        .level-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d2ff, #0072ff, #a335ee);
            transition: width 1s ease-out;
            border-radius: 7px;
        }
        
        #game-over {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(200, 0, 0, 0.97),
                rgba(50, 0, 0, 0.99));
            backdrop-filter: blur(30px);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 999;
            pointer-events: auto;
            text-align: center;
            overflow: hidden;
        }
        
        .eliminated-particles {
            position: absolute;
            width: 100%; height: 100%;
        }
        
        .eliminated-particle {
            position: absolute;
            width: 10px; height: 10px;
            background: rgba(255, 50, 50, 0.7);
            border-radius: 50%;
            animation: eliminatedParticleFall 5s infinite linear;
        }
        
        @keyframes eliminatedParticleFall {
            0% { transform: translateY(-100px) rotate(0deg) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(0) rotate(0deg) scale(1); }
            90% { opacity: 1; transform: translateY(100vh) rotate(360deg) scale(1); }
            100% { transform: translateY(110vh) rotate(720deg) scale(0); opacity: 0; }
        }
        
        #go-title {
            font-size: 0;
            background: linear-gradient(135deg, #ff4d4d, #ff0000, #8b0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
            font-weight: 900;
            animation: eliminatedText 2.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 15px 50px rgba(255, 0, 0, 0.6);
            letter-spacing: -10px;
            opacity: 0;
        }
        
        @keyframes eliminatedText {
            0% { font-size: 0; transform: scale(0) rotate(-10deg); opacity: 0; letter-spacing: 50px; }
            40% { font-size: 8rem; transform: scale(1.4) rotate(5deg); opacity: 1; letter-spacing: -5px; }
            60% { font-size: 8rem; transform: scale(1.2) rotate(-2deg); opacity: 1; letter-spacing: -2px; }
            100% { font-size: 6rem; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0; }
        }
        
        #go-stats {
            font-size: 2.8rem;
            color: rgba(255,255,255,0.95);
            margin-bottom: 4rem;
            animation: slideIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) 2.5s backwards;
            text-shadow: 0 8px 25px rgba(0,0,0,0.7);
            z-index: 2;
        }

        /* Restart Button - Redesigned and raised */
        .restart-btn {
            margin-top: 2rem;
            padding: 1.5rem 3.5rem;
            font-size: 1.6rem;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            box-shadow: 
                0 15px 40px rgba(0, 123, 255, 0.7),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 30px rgba(0, 123, 255, 0.5);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            backdrop-filter: blur(15px);
            border: 3px solid rgba(255,255,255,0.2);
            z-index: 2;
        }
        
        .restart-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.6s;
        }
        
        .restart-btn:hover::before {
            left: 100%;
        }
        
        .restart-btn:hover {
            background: linear-gradient(135deg, #0056b3, #003d82);
            transform: translateY(-5px);
            box-shadow: 
                0 20px 50px rgba(0, 123, 255, 0.9),
                inset 0 1px 0 rgba(255,255,255,0.5),
                0 0 40px rgba(0, 123, 255, 0.7);
        }
        
        #game-over .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 3s forwards;
        }
        
        #victory-overlay .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 4.5s forwards;
        }
        
        #level-stats-screen .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 1s forwards;
        }

        /* Animations */
        @keyframes fadeIn { 
            0% { opacity: 0; } 
            100% { opacity: 1; } 
        }
        
        @keyframes slideDown {
            0% { opacity: 0; transform: translateY(-50px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes scaleIn {
            0% { opacity: 0; transform: scale(0.7) rotate(-5deg); }
            70% { opacity: 1; transform: scale(1.05) rotate(2deg); }
            100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }
        
        @keyframes slideIn {
            0% { opacity: 0; transform: translateY(-50px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes fadeUp {
            0% { transform: translateY(50px) scale(0.8); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        /* Menu Enhancements */
        .menu-background {
            position: absolute;
            width: 100%; height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 210, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 128, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(255, 215, 0, 0.15) 0%, transparent 50%);
            animation: backgroundPulse 10s infinite alternate;
        }
        
        @keyframes backgroundPulse {
            0% { opacity: 0.4; }
            100% { opacity: 0.8; }
        }
        
        .version-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            font-weight: 800;
            font-size: 1rem;
            animation: badgeGlow 2s infinite alternate;
            box-shadow: 
                0 8px 25px rgba(255, 215, 0, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        @keyframes badgeGlow {
            0% { box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4); }
            100% { box-shadow: 0 8px 35px rgba(255, 215, 0, 0.7), 0 0 30px rgba(255, 215, 0, 0.3); }
        }
        
        .menu-title {
            position: relative;
            margin-bottom: 2rem;
        }
        
        .title-glow {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 120%; height: 120%;
            background: radial-gradient(circle, rgba(0, 210, 255, 0.4) 0%, transparent 70%);
            filter: blur(50px);
            z-index: 1;
        }
        
        /* === NEW: STATS DISPLAY === */
        #stats-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 210, 255, 0.4);
            backdrop-filter: blur(10px);
            z-index: 1000;
            font-size: 0.9rem;
            max-width: 200px;
        }
        
        .stats-title {
            color: #00d2ff;
            font-weight: 700;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .stats-label {
            color: rgba(255,255,255,0.8);
        }
        
        .stats-value {
            color: #ffd700;
            font-weight: 600;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>

    <div id="start-screen">
        <div class="menu-background"></div>
        <div class="particles" id="particles-container"></div>
        <div class="version-badge">V19.8  ULTIMATE EDITION</div>
        <div class="menu-title">
            <div class="title-glow"></div>
            <h1>WEB BATTLE ROYALE</h1>
        </div>
        <p class="subtitle">Experience the ultimate browser-based shooter</p>
        <div class="button-container">
            <button class="game-button mobile" onclick="startGame('mobile')"> Mobile Mode</button>
            <button class="game-button" onclick="startGame('desktop')"> Desktop Mode</button>
            <button class="game-button controller" onclick="startGame('controller')"> Controller Mode</button>
            <button class="game-button" onclick="openSettings()"> Settings</button>
            <button class="game-button" onclick="openCharacterCustomization()"> Customize</button>
        </div>
        <div class="stats-grid">
            <div class="stat-item">
                <h3>Active Players</h3>
                <p id="total-players">25</p>
            </div>
            <div class="stat-item">
                <h3>Map Size</h3>
                <p>600x600</p>
            </div>
            <div class="stat-item">
                <h3>Version</h3>
                <p>V19.8</p>
            </div>
        </div>
        <div id="level-stats">
            <div class="level-display">Level <span id="current-level">1</span></div>
            <div class="progress-bar">
                <div class="progress-fill" id="level-progress" style="width: 0%"></div>
            </div>
            <div class="progress-text"><span id="current-points">0</span>/<span id="next-level-points">150</span> Points</div>
        </div>
    </div>
    
    <div id="game-container"></div>

    <div id="ui-layer">
        <!-- Crosshair -->
        <div id="crosshair">
            <div class="crosshair-dot"></div>
            <div class="crosshair-line ch-h"></div>
            <div class="crosshair-line ch-v"></div>
        </div>
        
        <!-- Scopes -->
        <div id="scope-overlay">
            <div id="scope-lines"></div>
        </div>
        
        <div id="red-dot-scope">
            <div class="red-line h"></div>
            <div class="red-line v"></div>
            <div class="red-dot"></div>
        </div>

        <!-- Storm Overlay -->
        <div id="storm-overlay"></div>
        
        <!-- Day/Night Cycle Overlay -->
        <div id="day-night-overlay"></div>
        
        <!-- Weather Effects -->
        <div id="weather-overlay"></div>

        <!-- HUD Container -->
        <div id="hud-container">
            <!-- FPS Counter -->
            <div id="fps-counter">60</div>
            
            <!-- Mini-Map -->
            <div id="mini-map">
                <canvas id="mini-map-canvas"></canvas>
            </div>
            
            <!-- Kill Feed -->
            <div id="kill-feed"></div>
            
            <!-- Stats Display -->
            <div id="stats-display">
                <div class="stats-title">Game Stats</div>
                <div class="stats-item">
                    <span class="stats-label">Accuracy:</span>
                    <span class="stats-value" id="accuracy-stat">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Damage Dealt:</span>
                    <span class="stats-value" id="damage-stat">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Shots Fired:</span>
                    <span class="stats-value" id="shots-stat">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Headshots:</span>
                    <span class="stats-value" id="headshots-stat">0</span>
                </div>
            </div>

            <!-- Top Bar -->
            <div id="top-bar">
                <div class="hud-item">
                    <div class="hud-label">Players Alive</div>
                    <div class="hud-value" id="alive-count">25</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Phase</div>
                    <div class="hud-value" id="storm-status">WAIT</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Timer</div>
                    <div class="hud-value" id="storm-timer">04:00</div>
                </div>
            </div>

            <!-- Player Stats (Left) -->
            <div id="player-stats">
                <!-- Health -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon"></div>
                        <div class="stat-title">Health</div>
                        <div class="stat-value" id="health-value">100</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="health-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Shield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon"></div>
                        <div class="stat-title">Shield</div>
                        <div class="stat-value" id="shield-value">100</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="shield-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Overshield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon"></div>
                        <div class="stat-title">Overshield</div>
                        <div class="stat-value" id="overshield-value">50</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="overshield-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Resources -->
                <div id="resources-bar">
                    <div class="resource-item">
                        <div class="resource-icon"></div>
                        <div class="resource-amount" id="wood-value">0</div>
                    </div>
                </div>
            </div>

            <!-- Inventory (Right) -->
            <div id="inventory-hud">
                <div class="inventory-slot" id="slot-0" onclick="selectSlot(0)" ontouchstart="selectSlotMobile(0)"></div>
                <div class="inventory-slot" id="slot-1" onclick="selectSlot(1)" ontouchstart="selectSlotMobile(1)"></div>
                <div class="inventory-slot" id="slot-2" onclick="selectSlot(2)" ontouchstart="selectSlotMobile(2)"></div>
                <div class="inventory-slot" id="slot-3" onclick="selectSlot(3)" ontouchstart="selectSlotMobile(3)"></div>
                <div class="inventory-slot" id="slot-4" onclick="selectSlot(4)" ontouchstart="selectSlotMobile(4)"></div>
            </div>

            <!-- Center HUD -->
            <div id="center-hud">
                <div id="interact-prompt">Interact (E)</div>
                <div id="reload-indicator">RELOADING...</div>
            </div>

            <!-- Healing Progress -->
            <div id="healing-progress">
                <div id="healing-bar"></div>
                <div id="healing-text">USING SHIELD...</div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div id="touch-left"></div>
            <div id="touch-right"></div>
            
            <div id="movement-zone">
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
            
            <div id="camera-zone"></div>
            
            <div id="btn-fire" class="mobile-button">FIRE</div>
            <div id="btn-jump" class="mobile-button">JUMP</div>
            <div id="btn-interact" class="mobile-button">INTERACT</div>
            <div id="btn-build" class="mobile-button">BUILD</div>
            <div id="btn-ads" class="mobile-button">AIM</div>
            <div id="btn-reload" class="mobile-button">RELOAD</div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-overlay">
        <div class="victory-particles" id="victory-particles"></div>
        <div id="victory-text">VICTORY ROYALE</div>
        <div id="victory-stats">Eliminations: 0</div>
        <button class="restart-btn" onclick="location.reload()"> RETURN TO LOBBY</button>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <div class="eliminated-particles" id="eliminated-particles"></div>
        <h1 id="go-title">ELIMINATED</h1>
        <h3 id="go-stats">Eliminations: 0</h3>
        <button class="restart-btn" onclick="location.reload()"> RETURN TO LOBBY</button>
    </div>
    
    <!-- Level Stats Screen -->
    <div id="level-stats-screen">
        <h1 id="level-stats-title">MATCH RESULTS</h1>
        <div class="stats-breakdown">
            <div class="stat-row">
                <div class="stat-label">Eliminations:</div>
                <div class="stat-value" id="match-kills">0</div>
            </div>
            <div class="stat-row">
                <div class="stat-label">Chests Opened:</div>
                <div class="stat-value" id="match-chests">0</div>
            </div>
            <div class="stat-row">
                <div class="stat-label">Legendary Items Held:</div>
                <div class="stat-value" id="match-legendarys">0</div>
            </div>
            <div class="stat-row">
                <div class="stat-label">Final Placement:</div>
                <div class="stat-value" id="match-placement">25th</div>
            </div>
            <div class="stat-row">
                <div class="stat-label">Accuracy:</div>
                <div class="stat-value" id="match-accuracy">0%</div>
            </div>
            <div class="stat-row">
                <div class="stat-label">Damage Dealt:</div>
                <div class="stat-value" id="match-damage">0</div>
            </div>
        </div>
        <div class="total-points">+ <span id="match-points">0</span> Points</div>
        <div class="level-progress-container">
            <div class="level-progress-text">
                <span>Level <span id="match-level">1</span></span>
                <span><span id="match-progress">0</span>/<span id="match-next-level">150</span></span>
            </div>
            <div class="level-progress-bar">
                <div class="level-progress-fill" id="match-progress-bar" style="width: 0%"></div>
            </div>
        </div>
        <button class="restart-btn" onclick="location.reload()"> PLAY AGAIN</button>
    </div>
    
    <!-- Settings Menu -->
    <div id="settings-menu">
        <div class="settings-content">
            <div class="settings-header">
                <h1 class="settings-title">Settings</h1>
                <button class="settings-close" onclick="closeSettings()"></button>
            </div>
            
            <div class="settings-group">
                <h2 class="settings-group-title">Graphics</h2>
                <div class="settings-item">
                    <span class="settings-label">Quality</span>
                    <select class="settings-select" id="graphics-quality">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                        <option value="ultra">Ultra</option>
                    </select>
                </div>
                <div class="settings-item">
                    <span class="settings-label">Shadows</span>
                    <div class="settings-toggle" id="toggle-shadows" onclick="toggleSetting('shadows')"></div>
                </div>
                <div class="settings-item">
                    <span class="settings-label">Particle Effects</span>
                    <div class="settings-toggle active" id="toggle-particles" onclick="toggleSetting('particles')"></div>
                </div>
                <div class="settings-item">
                    <span class="settings-label">Field of View</span>
                    <input type="range" min="60" max="120" value="75" class="settings-slider" id="fov-slider">
                </div>
            </div>
            
            <div class="settings-group">
                <h2 class="settings-group-title">Audio</h2>
                <div class="settings-item">
                    <span class="settings-label">Master Volume</span>
                    <input type="range" min="0" max="100" value="100" class="settings-slider" id="master-volume">
                </div>
                <div class="settings-item">
                    <span class="settings-label">SFX Volume</span>
                    <input type="range" min="0" max="100" value="100" class="settings-slider" id="sfx-volume">
                </div>
                <div class="settings-item">
                    <span class="settings-label">Music Volume</span>
                    <input type="range" min="0" max="100" value="50" class="settings-slider" id="music-volume">
                </div>
            </div>
            
            <div class="settings-group">
                <h2 class="settings-group-title">Gameplay</h2>
                <div class="settings-item">
                    <span class="settings-label">Mouse Sensitivity</span>
                    <input type="range" min="0.1" max="2" step="0.1" value="1" class="settings-slider" id="mouse-sensitivity">
                </div>
                <div class="settings-item">
                    <span class="settings-label">Invert Y Axis</span>
                    <div class="settings-toggle" id="toggle-invert" onclick="toggleSetting('invert')"></div>
                </div>
                <div class="settings-item">
                    <span class="settings-label">Auto Sprint</span>
                    <div class="settings-toggle" id="toggle-autosprint" onclick="toggleSetting('autosprint')"></div>
                </div>
                <div class="settings-item">
                    <span class="settings-label">Crosshair Style</span>
                    <select class="settings-select" id="crosshair-style">
                        <option value="default">Default</option>
                        <option value="dot">Dot</option>
                        <option value="circle">Circle</option>
                        <option value="cross">Cross</option>
                    </select>
                </div>
            </div>
            
            <div class="settings-group">
                <h2 class="settings-group-title">Controls</h2>
                <div class="settings-item">
                    <span class="settings-label">Mobile Sensitivity</span>
                    <input type="range" min="0.001" max="0.01" step="0.001" value="0.005" class="settings-slider" id="mobile-sensitivity">
                </div>
                <div class="settings-item">
                    <span class="settings-label">Controller Vibration</span>
                    <div class="settings-toggle active" id="toggle-vibration" onclick="toggleSetting('vibration')"></div>
                </div>
            </div>
            
            <button class="restart-btn" onclick="applySettings()" style="width: 100%; margin-top: 2rem;">Apply Settings</button>
        </div>
    </div>
    
    <!-- Pause Menu -->
    <div id="pause-menu">
        <div class="pause-content">
            <h1 class="pause-title">PAUSED</h1>
            <div class="pause-stats">
                <div class="pause-stat">
                    <div class="pause-stat-label">Eliminations</div>
                    <div class="pause-stat-value" id="pause-kills">0</div>
                </div>
                <div class="pause-stat">
                    <div class="pause-stat-label">Accuracy</div>
                    <div class="pause-stat-value" id="pause-accuracy">0%</div>
                </div>
                <div class="pause-stat">
                    <div class="pause-stat-label">Damage Dealt</div>
                    <div class="pause-stat-value" id="pause-damage">0</div>
                </div>
                <div class="pause-stat">
                    <div class="pause-stat-label">Headshots</div>
                    <div class="pause-stat-value" id="pause-headshots">0</div>
                </div>
            </div>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; margin-top: 2rem;">
                <button class="restart-btn" onclick="resumeGame()">Resume Game</button>
                <button class="restart-btn" onclick="openSettings()">Settings</button>
                <button class="restart-btn" onclick="location.reload()">Quit to Menu</button>
            </div>
        </div>
    </div>
    
    <!-- Character Customization -->
    <div id="character-customization">
        <div class="character-content">
            <div class="settings-header">
                <h1 class="settings-title">Character Customization</h1>
                <button class="settings-close" onclick="closeCharacterCustomization()"></button>
            </div>
            
            <div class="settings-group">
                <h2 class="settings-group-title">Select Skin</h2>
                <div class="skin-grid" id="skin-grid">
                    <!-- Skins will be dynamically added here -->
                </div>
            </div>
            
            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="restart-btn" onclick="applySkin()">Apply Skin</button>
                <button class="restart-btn" onclick="closeCharacterCustomization()">Back</button>
            </div>
        </div>
    </div>

    <!-- Controller Notification -->
    <div class="controller-notification" id="controller-notification"> Controller Connected</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ===============================================================
        // === CORE CONSTANTS AND CONFIGURATION (V19.8) ===================
        // ===============================================================
        
        const WORLD_SIZE = 600;
        const BOT_COUNT = 24; // UPDATED: Increased to 24 bots
        const GRAVITY = 40.0; 
        const WALK_SPEED = 10; 
        const SPRINT_SPEED = 20; 
        const JUMP_FORCE = 15;
        const PLAYER_HEIGHT = 1.8;
        const SHOTGUN_PELLETS = 4;
        
        // Player stats
        const OVER_SHIELD_MAX = 50;
        const OVER_SHIELD_REGEN_RATE = 15;
        const OVER_SHIELD_REGEN_DELAY = 7000;
        
        // Leveling System
        const POINTS_PER_KILL = 5;
        const POINTS_TOP_10 = 10;
        const POINTS_TOP_2 = 15;
        const POINTS_PER_CHEST = 1;
        const POINTS_PER_LEGENDARY = 5;
        const BASE_POINTS_PER_LEVEL = 150;
        
        // Weapons configuration with UPDATED sniper damage
        const RARITY_MULTIPLIERS = {
            COMMON: { dmg: 1.0, reload: 1.0, color: '#b0b0b0' },
            UNCOMMON: { dmg: 1.15, reload: 0.9, color: '#28a745' },
            RARE: { dmg: 1.3, reload: 0.8, color: '#007bff' },
            EPIC: { dmg: 1.45, reload: 0.7, color: '#a335ee' },
            LEGENDARY: { dmg: 1.6, reload: 0.6, color: '#ffd700' },
            MYTHIC: { dmg: 1.8, reload: 0.5, color: '#ff4d4d' } 
        };
        const RARITY_KEYS = Object.keys(RARITY_MULTIPLIERS);

        // Weapons configuration with UPDATED sniper damage values
        const WEAPONS_BASE = {
            PUMP: { name: "Pump Shotgun", dmg: 30 * 1.5, head: 35 * 1.5, rate: 1.2, mag: 5, range: 30, spread: 0.25, pellets: SHOTGUN_PELLETS, auto: false, icon: '', reload: 3000, recoil: 0.0, bulletType: 'hitscan' }, 
            AUTO_SHG: { name: "Auto Shotgun", dmg: 30, head: 50, rate: 0.4, mag: 8, range: 25, spread: 0.3, pellets: SHOTGUN_PELLETS, auto: true, icon: '', reload: 3500, recoil: 0.0, bulletType: 'hitscan' },
            RFAR: { name: "Rapid Fire AR", dmg: 14, head: 21, rate: 0.1, mag: 30, range: 150, spread: 0.04, pellets: 1, auto: true, icon: '', reload: 2500, recoil: 0.0, bulletType: 'hitscan' }, 
            DMR: { name: "DMR", dmg: 25, head: 40, rate: 0.35, mag: 15, range: 250, spread: 0.015, pellets: 1, auto: false, icon: '', reload: 2800, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            STINGER: { name: "Stinger SMG", dmg: 15, head: 22.5, rate: 0.07, mag: 20, range: 70, spread: 0.07, pellets: 1, auto: true, icon: '', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            BURST_SMG: { name: "Burst SMG", dmg: 18, head: 30, rate: 0.15, mag: 30, burst: 2, burstDelay: 300, range: 80, spread: 0.05, pellets: 1, auto: false, icon: '', reload: 2000, recoil: 0.0, bulletType: 'hitscan' },
            // UPDATED: Bolt Action Sniper - 129 body, 219 head
            BOLT_SNIPER: { name: "Bolt Sniper", dmg: 129, head: 219, rate: 2.5, mag: 2, range: 600, spread: 0.001, pellets: 1, auto: false, icon: '', reload: 4000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            SCOPED_SMG: { name: "Scoped SMG", dmg: 12, head: 18, rate: 0.1, mag: 40, range: 100, spread: 0.03, pellets: 1, auto: true, icon: '', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            DRUM_SMG: { name: "Drum SMG", dmg: 10, head: 15, rate: 0.08, mag: 50, range: 80, spread: 0.08, pellets: 1, auto: true, icon: '', reload: 1200, recoil: 0.0, bulletType: 'hitscan' },
            // UPDATED: Falcon Eye Sniper - 79 body, 119 head
            FALCON_SNIPER: { name: "Falcon Sniper", dmg: 79, head: 119, rate: 0.7, mag: 3, range: 500, spread: 0.005, pellets: 1, auto: false, icon: '', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' }, 
            STRANGLED_RIFLE: { name: "Strangled Rifle", dmg: 35, head: 55, rate: 0.45, mag: 30, range: 180, spread: 0.02, pellets: 1, auto: false, icon: '', reload: 2500, recoil: 0.0, bulletType: 'hitscan' },
            // UPDATED: Sniper - 131 body, 231 head
            SNIPER:{name: "Sniper", dmg: 131, head: 231, rate: 1.5, mag: 1,  range: 600,spread: 0.001,pellets:1, auto: false,icon:'', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            PISTOL: { name: "Pistol", dmg: 12, head: 18, rate: 0.5, mag: 15, range: 100, spread: 0.05, pellets: 1, auto: false, icon: '', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            ROCKET_LAUNCHER: { name: "R. Launcher", dmg: 50, head: 0, rate: 4.0, mag: 1, range: 300, spread: 0.0, pellets: 1, auto: false, icon: '', reload: 4500, recoil: 0.0, bulletType: 'projectile', explosionRadius: 5, explosionDamage: 200 },
            DUAL_SMG: { name: "Dual Micro SMGS", dmg: 11.25, head: 17.5, rate: 0.05, mag: 130, range: 70, spread: 0.1, pellets: 1, auto: true, icon: '', reload: 2250, recoil: 0.0, bulletType: 'hitscan' },
            HEAVY_AR: { name: "Heavy AR", dmg: 30, head: 55, rate: 0.12, mag: 30, range: 200, spread: 0.035, pellets: 1, auto: false, icon: '', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'holo_twister' }
        };
        const MYTHIC_WEAPON_KEY = 'STRANGLED_RIFLE'; 
        const BOT_WEAPON_KEY = 'RFAR'; 
        
        // Consumables
        const CONSUMABLES = {
            MINI: { name: "Small Shield", val: 25, type: 'shield', max: 50, icon: '', time: 1, continuous: false, instant: true, maxStack: 6, rarity: 'COMMON' },
            BIG:  { name: "Big Shield", val: 50, type: 'shield', max: 100, icon: '', time: 5000, continuous: false, instant: false, maxStack: 3, rarity: 'UNCOMMON' },
            CHUG: { name: "Chug Jug", val: 3, shieldVal: 3, type: 'continuous', max: 100, icon: '', time: 20000, continuous: true, instant: false, maxStack: 1, rarity: 'LEGENDARY' },
            MEDKIT: { name: "Med Kit", val: 100, type: 'health', max: 100, icon: '', time: 10000, continuous: false, instant: false, maxStack: 3, rarity: 'RARE' }
        };
        const CONSUMABLE_KEYS = Object.keys(CONSUMABLES);

        // Storm Phases
        const STORM_PHASES = [
            { time: 60, radius: WORLD_SIZE * 0.5, damage: 3, status: "Wait" }, 
            { time: 60, radius: WORLD_SIZE * 0.4, damage: 3, status: "Shrink" }, 
            { time: 120, radius: WORLD_SIZE * 0.4, damage: 3, status: "Hold" }, 
            { time: 60, radius: WORLD_SIZE * 0.3, damage: 5, status: "Shrink" }, 
            { time: 60, radius: 0, damage: 10, status: "Deathmatch" } 
        ];
        const BOT_STORM_DAMAGE = 5;

        // ===============================================================
        // === GLOBAL STATE VARIABLES ====================================
        // ===============================================================

        let scene, camera, renderer, controls;
        let weaponScene, weaponCamera, viewModel;
        let raycaster, downRay;
        
        // Player stats
        let player = { 
            health: 100, shield: 100, overshield: 50, wood: 0, 
            inventory: [null, null, null, null, null], slot: 0, 
            dead: false, ads: false, vehicle: null, eliminations: 0,
            isReloading: false,
            isHealing: false,
            healingItem: null,
            healingStartTime: 0,
            lastStormDamage: 0,
            isBursting: false,
            burstCount: 0,
            burstTimer: null,
            lastOvershieldDamage: 0, 
            overshieldRegenTimer: null,
            lastOvershieldBreak: 0,
            // Leveling system
            totalPoints: 0,
            level: 1,
            pointsToNextLevel: BASE_POINTS_PER_LEVEL,
            matchPoints: 0,
            chestsOpened: 0,
            legendaryItemsHeld: 0,
            // Game stats
            shotsFired: 0,
            shotsHit: 0,
            headshots: 0,
            totalDamage: 0,
            // Character customization
            skin: 'default'
        };
        
        let inputs = { w: false, a: false, s: false, d: false, jump: false, sprint: false, fire: false, reload: false, use: false };
        let velocity = new THREE.Vector3();
        let isGrounded = false;
        let lastTime = performance.now();
        let lastShot = 0;
        
        // Game mode
        let gameMode = 'desktop';
        let gameStarted = false;
        let gamePaused = false;
        
        // Mobile control variables - IMPROVED sensitivity
        let mobileTouchActive = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let touchDeltaX = 0;
        let touchDeltaY = 0;
        const MOBILE_SENSITIVITY = 0.005; // UPDATED: Increased sensitivity
        const MOBILE_SMOOTHING = 0.05;
        const MAX_CAMERA_ANGLE = Math.PI / 2 - 0.1;
        
        // Controller variables
        let gamepad = null;
        let controllerConnected = false;
        let controllerVibration = true;
        let controllerMapping = {
            leftStick: { x: 0, y: 0 },
            rightStick: { x: 0, y: 0 },
            buttons: {
                l1: false, r1: false,
                l2: 0, r2: 0,
                y: false, b: false, a: false, x: false,
                dpadLeft: false, dpadRight: false, dpadUp: false, dpadDown: false,
                l3: false, r3: false,
                start: false, select: false
            }
        };
        const CONTROLLER_SENSITIVITY = 0.03;
        
        // Dynamic Arrays for Entities
        let bots = [];
        let objects = []; 
        let chests = [];
        let cars = [];
        let loot = [];
        let buildings = []; 
        let projectiles = []; 
        let doors = [];
        
        // Visual effects
        let visualEffects = [];
        let lastFpsUpdate = 0;
        let frameCount = 0;
        let fps = 60;

        // Storm State
        let stormRadius = STORM_PHASES[0].radius;
        let stormCenter = new THREE.Vector2(0, 0);
        let stormDamageRate = STORM_PHASES[0].damage;
        let stormPhaseTime = STORM_PHASES[0].time; 
        let stormPhaseTimer = stormPhaseTime;
        let stormPhase = 0;
        let stormActive = false;
        let stormTimerInterval;

        // Day/Night Cycle
        let dayNightCycle = {
            time: 12, // 0-24 hours
            speed: 0.1, // Speed of time
            sun: null,
            moon: null,
            ambientLight: null
        };

        // Weather
        let weather = {
            type: 'clear', // clear, rain, fog
            intensity: 0,
            rainDrops: []
        };

        // Settings
        let settings = {
            graphicsQuality: 'medium',
            shadows: true,
            particles: true,
            fov: 75,
            masterVolume: 1.0,
            sfxVolume: 1.0,
            musicVolume: 0.5,
            mouseSensitivity: 1.0,
            invertY: false,
            autoSprint: false,
            crosshairStyle: 'default',
            mobileSensitivity: 0.005,
            vibration: true
        };

        // ===============================================================
        // === NEW: MINI-MAP SYSTEM ======================================
        // ===============================================================

        let miniMapCanvas, miniMapCtx;
        
        function initMiniMap() {
            miniMapCanvas = document.getElementById('mini-map-canvas');
            miniMapCtx = miniMapCanvas.getContext('2d');
            miniMapCanvas.width = 180;
            miniMapCanvas.height = 180;
        }
        
        function updateMiniMap() {
            if (!miniMapCtx) return;
            
            // Clear canvas
            miniMapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            miniMapCtx.fillRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
            
            // Draw storm circle
            miniMapCtx.strokeStyle = '#a335ee';
            miniMapCtx.lineWidth = 2;
            miniMapCtx.beginPath();
            const stormRadiusPx = (stormRadius / WORLD_SIZE) * miniMapCanvas.width;
            miniMapCtx.arc(miniMapCanvas.width / 2, miniMapCanvas.height / 2, stormRadiusPx, 0, Math.PI * 2);
            miniMapCtx.stroke();
            
            // Draw player
            const playerX = (camera.position.x / WORLD_SIZE) * miniMapCanvas.width + miniMapCanvas.width / 2;
            const playerY = (camera.position.z / WORLD_SIZE) * miniMapCanvas.height + miniMapCanvas.height / 2;
            
            miniMapCtx.fillStyle = '#00ff00';
            miniMapCtx.beginPath();
            miniMapCtx.arc(playerX, playerY, 4, 0, Math.PI * 2);
            miniMapCtx.fill();
            
            // Draw player direction
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            miniMapCtx.strokeStyle = '#00ff00';
            miniMapCtx.lineWidth = 2;
            miniMapCtx.beginPath();
            miniMapCtx.moveTo(playerX, playerY);
            miniMapCtx.lineTo(playerX + dir.x * 10, playerY + dir.z * 10);
            miniMapCtx.stroke();
            
            // Draw bots
            miniMapCtx.fillStyle = '#ff4d4d';
            bots.forEach(bot => {
                const botX = (bot.mesh.position.x / WORLD_SIZE) * miniMapCanvas.width + miniMapCanvas.width / 2;
                const botY = (bot.mesh.position.z / WORLD_SIZE) * miniMapCanvas.height + miniMapCanvas.height / 2;
                
                // Only show bots within reasonable distance
                const dist = camera.position.distanceTo(bot.mesh.position);
                if (dist < 200) {
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(botX, botY, 2, 0, Math.PI * 2);
                    miniMapCtx.fill();
                }
            });
            
            // Draw chests
            miniMapCtx.fillStyle = '#ffd700';
            chests.forEach(chest => {
                const chestX = (chest.position.x / WORLD_SIZE) * miniMapCanvas.width + miniMapCanvas.width / 2;
                const chestY = (chest.position.z / WORLD_SIZE) * miniMapCanvas.height + miniMapCanvas.height / 2;
                
                const dist = camera.position.distanceTo(chest.position);
                if (dist < 100) {
                    miniMapCtx.fillRect(chestX - 2, chestY - 2, 4, 4);
                }
            });
        }

        // ===============================================================
        // === NEW: KILL FEED SYSTEM =====================================
        // ===============================================================

        function addKillFeedMessage(killer, victim, isHeadshot = false) {
            const killFeed = document.getElementById('kill-feed');
            const message = document.createElement('div');
            message.className = `kill-feed-item ${isHeadshot ? 'headshot' : ''}`;
            message.innerHTML = `<span class="killer">${killer}</span> eliminated <span class="victim">${victim}</span>${isHeadshot ? ' (HEADSHOT!)' : ''}`;
            
            killFeed.appendChild(message);
            
            // Limit to 5 messages
            if (killFeed.children.length > 5) {
                killFeed.removeChild(killFeed.children[0]);
            }
            
            // Auto remove after animation
            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 3500);
        }

        // ===============================================================
        // === NEW: HIT MARKER SYSTEM ====================================
        // ===============================================================

        function showHitMarker(isHeadshot = false) {
            const hitMarker = document.createElement('div');
            hitMarker.className = 'hit-marker';
            if (isHeadshot) {
                hitMarker.style.boxShadow = '0 0 20px #ff0000';
            }
            
            document.getElementById('ui-layer').appendChild(hitMarker);
            
            setTimeout(() => {
                if (hitMarker.parentNode) {
                    hitMarker.parentNode.removeChild(hitMarker);
                }
            }, 200);
        }

        // ===============================================================
        // === NEW: DAY/NIGHT CYCLE SYSTEM ===============================
        // ===============================================================

        function initDayNightCycle() {
            // Create sun
            const sunGeometry = new THREE.SphereGeometry(20, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            dayNightCycle.sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(dayNightCycle.sun);
            
            // Create moon
            const moonGeometry = new THREE.SphereGeometry(15, 32, 32);
            const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
            dayNightCycle.moon = new THREE.Mesh(moonGeometry, moonMaterial);
            scene.add(dayNightCycle.moon);
            
            // Create ambient light that changes with time
            dayNightCycle.ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(dayNightCycle.ambientLight);
            
            updateDayNightCycle();
        }
        
        function updateDayNightCycle() {
            const time = dayNightCycle.time;
            const overlay = document.getElementById('day-night-overlay');
            
            // Calculate sun and moon positions
            const sunAngle = (time / 24) * Math.PI * 2;
            const moonAngle = sunAngle + Math.PI;
            
            const radius = 300;
            dayNightCycle.sun.position.x = Math.cos(sunAngle) * radius;
            dayNightCycle.sun.position.y = Math.sin(sunAngle) * radius + 100;
            dayNightCycle.sun.position.z = Math.sin(sunAngle) * radius * 0.5;
            
            dayNightCycle.moon.position.x = Math.cos(moonAngle) * radius;
            dayNightCycle.moon.position.y = Math.sin(moonAngle) * radius + 100;
            dayNightCycle.moon.position.z = Math.sin(moonAngle) * radius * 0.5;
            
            // Update ambient light intensity
            let lightIntensity = 0.6;
            if (time > 6 && time < 18) {
                // Day time
                lightIntensity = 0.6 + Math.sin((time - 6) / 12 * Math.PI) * 0.2;
            } else {
                // Night time
                lightIntensity = 0.2 + Math.sin((time - 18) / 12 * Math.PI) * 0.1;
            }
            dayNightCycle.ambientLight.intensity = lightIntensity;
            
            // Update overlay for night time
            let nightOpacity = 0;
            if (time < 6 || time > 18) {
                nightOpacity = 0.7;
            } else if (time > 17 || time < 7) {
                nightOpacity = 0.3;
            }
            overlay.style.background = `rgba(0, 0, 50, ${nightOpacity})`;
            
            // Increment time
            dayNightCycle.time += dayNightCycle.speed * 0.01;
            if (dayNightCycle.time >= 24) dayNightCycle.time = 0;
        }

        // ===============================================================
        // === NEW: WEATHER SYSTEM =======================================
        // ===============================================================

        function initWeather() {
            // Randomly choose weather
            const weatherTypes = ['clear', 'rain', 'fog'];
            weather.type = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
            
            if (weather.type === 'rain') {
                createRain();
            } else if (weather.type === 'fog') {
                scene.fog = new THREE.Fog(0x87CEEB, 10, 150);
            }
        }
        
        function createRain() {
            const overlay = document.getElementById('weather-overlay');
            overlay.innerHTML = '';
            
            for (let i = 0; i < 100; i++) {
                const drop = document.createElement('div');
                drop.className = 'rain-drop';
                drop.style.left = `${Math.random() * 100}%`;
                drop.style.animationDelay = `${Math.random()}s`;
                drop.style.animationDuration = `${Math.random() * 0.5 + 0.5}s`;
                overlay.appendChild(drop);
                weather.rainDrops.push(drop);
            }
        }

        // ===============================================================
        // === NEW: CHARACTER CUSTOMIZATION SYSTEM =======================
        // ===============================================================

        const skins = [
            { id: 'default', name: 'Default', icon: '', color: 0x007bff },
            { id: 'commando', name: 'Commando', icon: '', color: 0x8B4513 },
            { id: 'ninja', name: 'Ninja', icon: '', color: 0x000000 },
            { id: 'cyber', name: 'Cyber', icon: '', color: 0x00ff00 },
            { id: 'gold', name: 'Gold', icon: '', color: 0xffd700 },
            { id: 'phantom', name: 'Phantom', icon: '', color: 0x800080 },
            { id: 'tactical', name: 'Tactical', icon: '', color: 0x808080 },
            { id: 'hero', name: 'Hero', icon: '', color: 0xff0000 }
        ];

        function initCharacterCustomization() {
            const skinGrid = document.getElementById('skin-grid');
            skinGrid.innerHTML = '';
            
            skins.forEach(skin => {
                const skinItem = document.createElement('div');
                skinItem.className = `skin-item ${player.skin === skin.id ? 'selected' : ''}`;
                skinItem.dataset.id = skin.id;
                skinItem.innerHTML = `
                    <div class="skin-icon">${skin.icon}</div>
                    <div class="skin-name">${skin.name}</div>
                `;
                skinItem.onclick = () => selectSkin(skin.id);
                skinGrid.appendChild(skinItem);
            });
        }
        
        function selectSkin(skinId) {
            player.skin = skinId;
            
            // Update UI
            document.querySelectorAll('.skin-item').forEach(item => {
                item.classList.remove('selected');
                if (item.dataset.id === skinId) {
                    item.classList.add('selected');
                }
            });
        }
        
        function applySkin() {
            // Here you would apply the skin to the player model
            // For now, we'll just close the customization menu
            closeCharacterCustomization();
        }
        
        function openCharacterCustomization() {
            document.getElementById('character-customization').style.display = 'flex';
            initCharacterCustomization();
        }
        
        function closeCharacterCustomization() {
            document.getElementById('character-customization').style.display = 'none';
        }

        // ===============================================================
        // === NEW: SETTINGS MENU SYSTEM =================================
        // ===============================================================

        function openSettings() {
            document.getElementById('settings-menu').style.display = 'flex';
            gamePaused = true;
            
            // Load current settings into UI
            document.getElementById('graphics-quality').value = settings.graphicsQuality;
            document.getElementById('toggle-shadows').classList.toggle('active', settings.shadows);
            document.getElementById('toggle-particles').classList.toggle('active', settings.particles);
            document.getElementById('fov-slider').value = settings.fov;
            document.getElementById('master-volume').value = settings.masterVolume * 100;
            document.getElementById('sfx-volume').value = settings.sfxVolume * 100;
            document.getElementById('music-volume').value = settings.musicVolume * 100;
            document.getElementById('mouse-sensitivity').value = settings.mouseSensitivity;
            document.getElementById('toggle-invert').classList.toggle('active', settings.invertY);
            document.getElementById('toggle-autosprint').classList.toggle('active', settings.autoSprint);
            document.getElementById('crosshair-style').value = settings.crosshairStyle;
            document.getElementById('mobile-sensitivity').value = settings.mobileSensitivity;
            document.getElementById('toggle-vibration').classList.toggle('active', settings.vibration);
        }
        
        function closeSettings() {
            document.getElementById('settings-menu').style.display = 'none';
            gamePaused = false;
        }
        
        function toggleSetting(setting) {
            const toggle = document.getElementById(`toggle-${setting}`);
            toggle.classList.toggle('active');
        }
        
        function applySettings() {
            // Get values from UI
            settings.graphicsQuality = document.getElementById('graphics-quality').value;
            settings.shadows = document.getElementById('toggle-shadows').classList.contains('active');
            settings.particles = document.getElementById('toggle-particles').classList.contains('active');
            settings.fov = parseInt(document.getElementById('fov-slider').value);
            settings.masterVolume = parseInt(document.getElementById('master-volume').value) / 100;
            settings.sfxVolume = parseInt(document.getElementById('sfx-volume').value) / 100;
            settings.musicVolume = parseInt(document.getElementById('music-volume').value) / 100;
            settings.mouseSensitivity = parseFloat(document.getElementById('mouse-sensitivity').value);
            settings.invertY = document.getElementById('toggle-invert').classList.contains('active');
            settings.autoSprint = document.getElementById('toggle-autosprint').classList.contains('active');
            settings.crosshairStyle = document.getElementById('crosshair-style').value;
            settings.mobileSensitivity = parseFloat(document.getElementById('mobile-sensitivity').value);
            settings.vibration = document.getElementById('toggle-vibration').classList.contains('active');
            
            // Apply settings
            camera.fov = settings.fov;
            camera.updateProjectionMatrix();
            
            // Update crosshair
            updateCrosshairStyle();
            
            closeSettings();
        }

        // ===============================================================
        // === NEW: PAUSE MENU SYSTEM ====================================
        // ===============================================================

        function togglePause() {
            if (!gameStarted || player.dead) return;
            
            gamePaused = !gamePaused;
            document.getElementById('pause-menu').style.display = gamePaused ? 'flex' : 'none';
            
            if (controls && controls.isLocked && gamePaused) {
                controls.unlock();
            }
            
            // Update pause menu stats
            if (gamePaused) {
                const accuracy = player.shotsFired > 0 ? Math.round((player.shotsHit / player.shotsFired) * 100) : 0;
                document.getElementById('pause-kills').textContent = player.eliminations;
                document.getElementById('pause-accuracy').textContent = `${accuracy}%`;
                document.getElementById('pause-damage').textContent = Math.round(player.totalDamage);
                document.getElementById('pause-headshots').textContent = player.headshots;
            }
        }
        
        function resumeGame() {
            gamePaused = false;
            document.getElementById('pause-menu').style.display = 'none';
            
            if (gameMode === 'desktop') {
                setTimeout(() => {
                    if (controls && !controls.isLocked) {
                        controls.lock();
                    }
                }, 100);
            }
        }

        // ===============================================================
        // === NEW: CROSSHAIR STYLES =====================================
        // ===============================================================

        function updateCrosshairStyle() {
            const crosshair = document.getElementById('crosshair');
            crosshair.innerHTML = '';
            
            switch(settings.crosshairStyle) {
                case 'default':
                    crosshair.innerHTML = `
                        <div class="crosshair-dot"></div>
                        <div class="crosshair-line ch-h"></div>
                        <div class="crosshair-line ch-v"></div>
                    `;
                    break;
                case 'dot':
                    crosshair.innerHTML = `
                        <div class="crosshair-dot" style="width: 8px; height: 8px;"></div>
                    `;
                    break;
                case 'circle':
                    const circle = document.createElement('div');
                    circle.style.position = 'absolute';
                    circle.style.top = '50%';
                    circle.style.left = '50%';
                    circle.style.width = '20px';
                    circle.style.height = '20px';
                    circle.style.border = '2px solid #ff4d4d';
                    circle.style.borderRadius = '50%';
                    circle.style.transform = 'translate(-50%, -50%)';
                    crosshair.appendChild(circle);
                    break;
                case 'cross':
                    crosshair.innerHTML = `
                        <div class="crosshair-line ch-h" style="width: 20px; left: calc(50% - 10px);"></div>
                        <div class="crosshair-line ch-v" style="height: 20px; top: calc(50% - 10px);"></div>
                    `;
                    break;
            }
        }

        // ===============================================================
        // === NEW: STATS DISPLAY UPDATER ================================
        // ===============================================================

        function updateStatsDisplay() {
            const accuracy = player.shotsFired > 0 ? Math.round((player.shotsHit / player.shotsFired) * 100) : 0;
            document.getElementById('accuracy-stat').textContent = `${accuracy}%`;
            document.getElementById('damage-stat').textContent = Math.round(player.totalDamage);
            document.getElementById('shots-stat').textContent = player.shotsFired;
            document.getElementById('headshots-stat').textContent = player.headshots;
        }

        // ===============================================================
        // === SOUND EFFECT SYSTEM =======================================
        // ===============================================================

        let audioContext;
        let soundCache = {};

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!audioContext) initAudio();
            
            const now = performance.now();
            const gainNode = audioContext.createGain();
            const oscillator = audioContext.createOscillator();
            
            switch(type) {
                case 'shoot':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'player_hit':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'elimination':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(659.25, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.4 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'reload':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    
                    setTimeout(() => {
                        if (!audioContext) return;
                        const clickOsc = audioContext.createOscillator();
                        const clickGain = audioContext.createGain();
                        clickOsc.type = 'square';
                        clickOsc.frequency.setValueAtTime(150, audioContext.currentTime);
                        clickGain.gain.setValueAtTime(0.15 * settings.sfxVolume, audioContext.currentTime);
                        clickGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                        clickOsc.connect(clickGain);
                        clickGain.connect(audioContext.destination);
                        clickOsc.start();
                        clickOsc.stop(audioContext.currentTime + 0.05);
                    }, 150);
                    break;
                    
                case 'victory':
                    const notes = [523.25, 659.25, 783.99, 1046.50];
                    notes.forEach((freq, i) => {
                        setTimeout(() => {
                            if (!audioContext) return;
                            const noteOsc = audioContext.createOscillator();
                            const noteGain = audioContext.createGain();
                            noteOsc.type = 'sine';
                            noteOsc.frequency.setValueAtTime(freq, audioContext.currentTime);
                            noteGain.gain.setValueAtTime(0.3 * settings.sfxVolume, audioContext.currentTime);
                            noteGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            noteOsc.connect(noteGain);
                            noteGain.connect(audioContext.destination);
                            noteOsc.start();
                            noteOsc.stop(audioContext.currentTime + 0.3);
                        }, i * 200);
                    });
                    break;
                    
                case 'defeat':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(130.81, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(87.31, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.2 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'jump':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'build':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.15 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'storm_damage':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.15 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'open_chest':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(523.25, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.2 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'pickup_item':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'explosion':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(50, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.4 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'impact_hit':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1 * settings.sfxVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
            }
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
        }

        // ===============================================================
        // === CONTROLLER VIBRATION SYSTEM ==============================
        // ===============================================================

        function vibrateController(pattern = 'light') {
            if (!controllerConnected || !controllerVibration || !gamepad || !settings.vibration) return;
            
            let vibrationPattern;
            
            switch(pattern) {
                case 'light':
                    vibrationPattern = { duration: 100, weakMagnitude: 0.3, strongMagnitude: 0.1 };
                    break;
                case 'medium':
                    vibrationPattern = { duration: 150, weakMagnitude: 0.6, strongMagnitude: 0.3 };
                    break;
                case 'strong':
                    vibrationPattern = { duration: 200, weakMagnitude: 1.0, strongMagnitude: 0.7 };
                    break;
                case 'shoot':
                    vibrationPattern = { duration: 80, weakMagnitude: 0.4, strongMagnitude: 0.8 };
                    break;
                case 'hit':
                    vibrationPattern = { duration: 250, weakMagnitude: 0.8, strongMagnitude: 1.0 };
                    break;
                case 'reload':
                    vibrationPattern = { duration: 300, weakMagnitude: 0.2, strongMagnitude: 0.4 };
                    break;
                case 'jump':
                    vibrationPattern = { duration: 100, weakMagnitude: 0.5, strongMagnitude: 0.2 };
                    break;
                default:
                    vibrationPattern = { duration: 100, weakMagnitude: 0.3, strongMagnitude: 0.1 };
            }
            
            try {
                if (gamepad.vibrationActuator) {
                    gamepad.vibrationActuator.playEffect("dual-rumble", {
                        duration: vibrationPattern.duration,
                        weakMagnitude: vibrationPattern.weakMagnitude,
                        strongMagnitude: vibrationPattern.strongMagnitude
                    });
                }
            } catch (e) {
                console.log("Vibration not supported on this controller");
            }
        }

        function showControllerNotification() {
            const notification = document.getElementById('controller-notification');
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // ===============================================================
        // === NEW: VISUAL EFFECTS SYSTEM ================================
        // ===============================================================

        function createMuzzleFlash(position, direction) {
            if (!settings.particles) return;
            
            const flash = document.createElement('div');
            flash.className = 'muzzle-flash';
            
            const worldPoint = position.clone().project(camera);
            const x = (worldPoint.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-worldPoint.y * 0.5 + 0.5) * window.innerHeight;
            
            flash.style.left = `${x}px`;
            flash.style.top = `${y}px`;
            
            document.getElementById('ui-layer').appendChild(flash);
            
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 100);
        }

        function createBulletTrail(startPos, endPos) {
            if (!settings.particles) return;
            
            const trail = document.createElement('div');
            trail.className = 'bullet-trail';
            
            const startWorld = startPos.clone().project(camera);
            const endWorld = endPos.clone().project(camera);
            
            const x1 = (startWorld.x * 0.5 + 0.5) * window.innerWidth;
            const y1 = (-startWorld.y * 0.5 + 0.5) * window.innerHeight;
            const x2 = (endWorld.x * 0.5 + 0.5) * window.innerWidth;
            const y2 = (-endWorld.y * 0.5 + 0.5) * window.innerHeight;
            
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            trail.style.left = `${x1}px`;
            trail.style.top = `${y1}px`;
            trail.style.width = `${length}px`;
            trail.style.transform = `rotate(${angle}deg)`;
            trail.style.transformOrigin = '0 0';
            
            document.getElementById('ui-layer').appendChild(trail);
            
            setTimeout(() => {
                if (trail.parentNode) {
                    trail.parentNode.removeChild(trail);
                }
            }, 200);
        }

        function createImpactEffect(position, isHeadshot = false) {
            if (!settings.particles) return;
            
            const effect = document.createElement('div');
            effect.className = isHeadshot ? 'blood-effect' : 'impact-effect';
            
            const worldPoint = position.clone().project(camera);
            const x = (worldPoint.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-worldPoint.y * 0.5 + 0.5) * window.innerHeight;
            
            effect.style.left = `${x}px`;
            effect.style.top = `${y}px`;
            
            document.getElementById('ui-layer').appendChild(effect);
            
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, isHeadshot ? 400 : 300);
        }

        // ===============================================================
        // === NEW: LEVELING SYSTEM ======================================
        // ===============================================================

        function loadLevelData() {
            const savedLevel = localStorage.getItem('playerLevel');
            const savedPoints = localStorage.getItem('playerPoints');
            const savedSkin = localStorage.getItem('playerSkin');
            
            if (savedLevel && savedPoints) {
                player.level = parseInt(savedLevel);
                player.totalPoints = parseInt(savedPoints);
                player.pointsToNextLevel = BASE_POINTS_PER_LEVEL * player.level;
            }
            
            if (savedSkin) {
                player.skin = savedSkin;
            }
            
            updateLevelDisplay();
        }

        function saveLevelData() {
            localStorage.setItem('playerLevel', player.level);
            localStorage.setItem('playerPoints', player.totalPoints);
            localStorage.setItem('playerSkin', player.skin);
        }

        function updateLevelDisplay() {
            const pointsInCurrentLevel = player.totalPoints % (BASE_POINTS_PER_LEVEL * player.level);
            const progress = (pointsInCurrentLevel / (BASE_POINTS_PER_LEVEL * player.level)) * 100;
            
            document.getElementById('current-level').textContent = player.level;
            document.getElementById('current-points').textContent = pointsInCurrentLevel;
            document.getElementById('next-level-points').textContent = BASE_POINTS_PER_LEVEL * player.level;
            document.getElementById('level-progress').style.width = `${progress}%`;
            
            const pointsToNext = (BASE_POINTS_PER_LEVEL * player.level) - pointsInCurrentLevel;
            document.getElementById('points-to-next').textContent = `${pointsToNext} Points to Next Level`;
        }

        function calculateMatchPoints(placement) {
            let points = 0;
            
            points += player.eliminations * POINTS_PER_KILL;
            points += player.chestsOpened * POINTS_PER_CHEST;
            points += player.legendaryItemsHeld * POINTS_PER_LEGENDARY;
            
            if (placement <= 2) {
                points += POINTS_TOP_2;
            } else if (placement <= 10) {
                points += POINTS_TOP_10;
            }
            
            player.matchPoints = points;
            player.totalPoints += points;
            
            const requiredForNextLevel = BASE_POINTS_PER_LEVEL * player.level;
            if (player.totalPoints >= requiredForNextLevel) {
                player.level++;
            }
            
            saveLevelData();
            return points;
        }

        function showLevelStatsScreen(placement) {
            const points = calculateMatchPoints(placement);
            const pointsInCurrentLevel = player.totalPoints % (BASE_POINTS_PER_LEVEL * player.level);
            const progress = (pointsInCurrentLevel / (BASE_POINTS_PER_LEVEL * player.level)) * 100;
            const totalBots = BOT_COUNT + 1;
            const placementText = placement === 1 ? '1st (Victory Royale!)' : 
                                 placement === 2 ? '2nd' : 
                                 placement === 3 ? '3rd' : 
                                 `${placement}th`;
            
            const accuracy = player.shotsFired > 0 ? Math.round((player.shotsHit / player.shotsFired) * 100) : 0;
            
            document.getElementById('match-kills').textContent = player.eliminations;
            document.getElementById('match-chests').textContent = player.chestsOpened;
            document.getElementById('match-legendarys').textContent = player.legendaryItemsHeld;
            document.getElementById('match-placement').textContent = placementText;
            document.getElementById('match-accuracy').textContent = `${accuracy}%`;
            document.getElementById('match-damage').textContent = Math.round(player.totalDamage);
            document.getElementById('match-points').textContent = points;
            document.getElementById('match-level').textContent = player.level;
            document.getElementById('match-progress').textContent = pointsInCurrentLevel;
            document.getElementById('match-next-level').textContent = BASE_POINTS_PER_LEVEL * player.level;
            document.getElementById('match-progress-bar').style.width = `${progress}%`;
            
            document.getElementById('level-stats-screen').style.display = 'flex';
        }

        // ===============================================================
        // === UTILITY FUNCTIONS =========================================
        // ===============================================================

        function getTerrainHeight(x, z) {
            // UPDATED: More realistic terrain
            const scale1 = 0.015;
            const scale2 = 0.04;
            const scale3 = 0.002;
            
            let y = (Math.sin(x * scale1) * 25 + Math.cos(z * scale1) * 25) + 
                    (Math.sin(x * scale2 + z * scale2) * 10);
            
            const mountain1 = Math.exp(-((x + 200)*(x + 200) + (z + 200)*(z + 200)) / 30000) * 50;
            const mountain2 = Math.exp(-((x - 200)*(x - 200) + (z - 200)*(z - 200)) / 40000) * 60;
            const mountain3 = Math.exp(-((x + 300)*(x + 300) + (z - 300)*(z - 300)) / 50000) * 40;
            
            y += mountain1 + mountain2 + mountain3;
            
            const river1 = Math.sin(x * scale3) * 15;
            const river2 = Math.cos(z * scale3) * 15;
            y -= Math.abs(river1) * 0.3 + Math.abs(river2) * 0.3;
            
            const dist = Math.sqrt(x*x + z*z);
            if (dist > WORLD_SIZE * 0.45) y += (dist - WORLD_SIZE * 0.45) * 0.3;
            
            return y;
        }
        
        function createBox(x, y, z, w, h, d, col, type='solid') {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: col}));
            mesh.position.set(x, y, z);
            mesh.castShadow = settings.shadows;
            mesh.receiveShadow = settings.shadows;
            scene.add(mesh);
            objects.push(mesh); 
            buildings.push({ mesh: mesh, type: type, health: 100 });
            return mesh;
        }

        function createDoor(x, y, z, rotationY) {
            const doorGeo = new THREE.BoxGeometry(1.5, 3, 0.1);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, transparent: true, opacity: 0.8 });
            const doorMesh = new THREE.Mesh(doorGeo, doorMat);
            doorMesh.position.set(x, y + 1.5, z);
            doorMesh.rotation.y = rotationY;
            scene.add(doorMesh);
            
            objects.push(doorMesh); 
            doors.push({ mesh: doorMesh, open: false, initialRotation: rotationY });
            
            return doorMesh;
        }
        
        function checkWin() {
            if (bots.length === 0 && !player.dead) {
                handleGameOver(true);
            }
        }
        
        function handleGameOver(win) {
            player.dead = true;
            if (controls && controls.isLocked) controls.unlock(); 
            
            const placement = win ? 1 : bots.length + 1;
            
            if (win) {
                createVictoryParticles();
                document.getElementById('victory-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('victory-overlay').style.display = 'flex';
                playSound('victory');
                
                setTimeout(() => {
                    document.getElementById('victory-overlay').style.display = 'none';
                    showLevelStatsScreen(placement);
                }, 5000);
            } else {
                createEliminatedParticles();
                document.getElementById('go-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('game-over').style.display = 'flex';
                playSound('defeat');
                
                setTimeout(() => {
                    document.getElementById('game-over').style.display = 'none';
                    showLevelStatsScreen(placement);
                }, 3000);
            }
        }
        
        function createVictoryParticles() {
            const container = document.getElementById('victory-particles');
            container.innerHTML = '';
            for(let i = 0; i < 100; i++) {
                const particle = document.createElement('div');
                particle.className = 'victory-particle';
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 5}s`;
                particle.style.animationDuration = `${Math.random() * 3 + 5}s`;
                particle.style.opacity = Math.random() * 0.5 + 0.5;
                container.appendChild(particle);
            }
        }
        
        function createEliminatedParticles() {
            const container = document.getElementById('eliminated-particles');
            container.innerHTML = '';
            for(let i = 0; i < 80; i++) {
                const particle = document.createElement('div');
                particle.className = 'eliminated-particle';
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 3}s`;
                particle.style.animationDuration = `${Math.random() * 2 + 3}s`;
                particle.style.opacity = Math.random() * 0.4 + 0.3;
                container.appendChild(particle);
            }
        }

        function toggleADS(bool) {
            player.ads = bool;
            const item = player.inventory[player.slot];
            const isClassicScope = item && item.category === 'weapon' && item.stats.scope === 'classic';
            const isRedDotScope = item && item.category === 'weapon' && item.stats.scope === 'red_dot';
            const isHoloScope = item && item.category === 'weapon' && item.stats.scope === 'holo_twister';
            
            const scopeOverlay = document.getElementById('scope-overlay');
            const redDotScope = document.getElementById('red-dot-scope');
            const crosshair = document.getElementById('crosshair');

            scopeOverlay.style.display = 'none';
            redDotScope.style.display = 'none';
            
            const isScoped = isClassicScope || isRedDotScope || isHoloScope;
            
            if (bool && isScoped) {
                crosshair.style.display = 'none';
                if (isClassicScope) {
                    scopeOverlay.style.display = 'block';
                    camera.fov = 10;
                } else if (isRedDotScope || isHoloScope) {
                    redDotScope.style.display = 'block';
                    camera.fov = (item.stats.name === WEAPONS_BASE.FALCON_SNIPER.name) ? 20 : 35;
                }
            } else {
                const isSniperFamily = item && item.category === 'weapon' && (item.stats.scope === 'classic' || item.stats.scope === 'red_dot' || item.stats.scope === 'holo_twister');
                crosshair.style.display = (isSniperFamily && !bool) ? 'none' : 'block';
                camera.fov = settings.fov;
            }

            camera.updateProjectionMatrix();
        }

        function showDamage(amount, position, type = 'body', isHeadshot = false) {
            const dmgNumber = document.createElement('div');
            dmgNumber.className = 'dmg-number' + (isHeadshot ? ' headshot' : '') + (type === 'storm' ? ' storm' : '');
            dmgNumber.innerText = Math.round(amount);
            
            const worldPoint = position.clone().project(camera);
            
            const x = (worldPoint.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-worldPoint.y * 0.5 + 0.5) * window.innerHeight;
            
            dmgNumber.style.left = `${x}px`;
            dmgNumber.style.top = `${y}px`;
            
            document.getElementById('ui-layer').appendChild(dmgNumber);
            
            setTimeout(() => {
                dmgNumber.remove();
            }, 1200);
        }

        function reload() {
            const item = player.inventory[player.slot];
            if (!item || item.category !== 'weapon' || item.stats.currentMag === item.stats.mag || player.isReloading) return;
            
            if (player.isHealing) finishHealing();
            
            playSound('reload');
            if (controllerConnected) vibrateController('reload');

            player.isReloading = true;
            document.getElementById('reload-indicator').style.display = 'block';
            updateUI();

            const reloadTime = item.stats.reload * item.rarity.reload;

            setTimeout(() => {
                item.stats.currentMag = item.stats.mag;
                player.isReloading = false;
                document.getElementById('reload-indicator').style.display = 'none';
                updateUI();
            }, reloadTime);
        }

        function buildWall() {
            if (player.wood < 10) return;
            
            playSound('build');
            if (controllerConnected) vibrateController('light');

            const wallGeo = new THREE.BoxGeometry(4, 4, 0.1);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, transparent: true, opacity: 0.8 });
            const wall = new THREE.Mesh(wallGeo, wallMat);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0;
            dir.normalize();

            wall.position.copy(camera.position).add(dir.multiplyScalar(5)).setY(getTerrainHeight(camera.position.x, camera.position.z) + 2);
            wall.rotation.y = camera.rotation.y;
            scene.add(wall);
            
            objects.push(wall);
            buildings.push({ mesh: wall, type: 'indestructible_wood', health: Infinity }); 
            player.wood -= 10;
            updateUI();
        }

        // ===============================================================
        // === STORM LOGIC ===============================================
        // ===============================================================

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function startStormTimer() {
            if (stormTimerInterval) clearInterval(stormTimerInterval);

            const nextPhase = STORM_PHASES[stormPhase];
            if (!nextPhase) {
                document.getElementById('storm-status').innerText = "FINAL";
                document.getElementById('storm-timer').innerText = "00:00";
                return;
            }
            
            stormPhaseTimer = nextPhase.time;
            document.getElementById('storm-status').innerText = nextPhase.status;
            stormDamageRate = nextPhase.damage; 
            
            const startRadius = stormRadius;
            const endRadius = nextPhase.radius;
            const startTime = performance.now();

            stormTimerInterval = setInterval(() => {
                if (player.dead) {
                    clearInterval(stormTimerInterval);
                    return;
                }
                
                stormPhaseTimer -= 1;
                document.getElementById('storm-timer').innerText = formatTime(stormPhaseTimer);
                
                if (nextPhase.status === "Shrink" || nextPhase.status === "Deathmatch") {
                    const elapsed = performance.now() - startTime;
                    const duration = nextPhase.time * 1000;
                    const t = Math.min(1, elapsed / duration);
                    stormRadius = startRadius + (endRadius - startRadius) * t;
                    stormActive = true; 
                } else if (nextPhase.status === "Hold") {
                    stormActive = true;
                } else if (nextPhase.status === "Wait") {
                    stormActive = false;
                }

                if (stormPhaseTimer <= 0) {
                    clearInterval(stormTimerInterval);
                    stormPhase++;
                    startStormTimer();
                }
            }, 1000);
        }
        
        function updateStorm(now) {
            const playerPos2D = new THREE.Vector2(camera.position.x, camera.position.z);
            const distToStorm = playerPos2D.distanceTo(stormCenter);
            const inStorm = stormActive && distToStorm > stormRadius;

            document.getElementById('storm-overlay').classList.toggle('in-storm', inStorm);

            if (inStorm && stormDamageRate > 0) {
                if (now - player.lastStormDamage > 1000) {
                    takeDamage(stormDamageRate, camera.position, 'storm'); 
                    player.lastStormDamage = now;
                    playSound('storm_damage');
                }
            } 

            bots.forEach(bot => {
                const botPos2D = new THREE.Vector2(bot.mesh.position.x, bot.mesh.position.z);
                const botDistToStorm = botPos2D.distanceTo(stormCenter);
                const botInStorm = stormActive && botDistToStorm > stormRadius;
                
                if (botInStorm && BOT_STORM_DAMAGE > 0) {
                     if (now - (bot.lastStormDamage || 0) > 1000) {
                        bot.health = Math.max(0, bot.health - BOT_STORM_DAMAGE); 
                        bot.lastStormDamage = now;
                        showDamage(BOT_STORM_DAMAGE, bot.mesh.position.clone().setY(bot.mesh.position.y + 1), 'storm');
                        
                        if (bot.health <= 0) {
                            scene.remove(bot.mesh);
                            bots = bots.filter(b => b !== bot);
                            player.wood += 50;
                            checkWin();
                        }
                    }
                }
            });
        }

        // ===============================================================
        // === UPDATED: ENHANCED WORLD GENERATION ========================
        // ===============================================================

        function generateTerrain() {
            const size = WORLD_SIZE;
            const segments = 128;
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            geometry.rotateX(-Math.PI / 2);

            const position = geometry.attributes.position;
            for (let i = 0; i < position.count; i++) {
                const x = position.getX(i);
                const z = position.getZ(i);
                const y = getTerrainHeight(x, z);
                position.setY(i, y);
            }
            position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            // UPDATED: More realistic grass
            const grassMat = new THREE.MeshStandardMaterial({ 
                color: 0x3a8b3a,
                roughness: 0.8,
                metalness: 0.1
            }); 
            const terrain = new THREE.Mesh(geometry, grassMat);
            terrain.receiveShadow = settings.shadows;
            terrain.castShadow = settings.shadows;
            scene.add(terrain);
            objects.push(terrain); 
            
            // Add grass details
            for(let i = 0; i < 200; i++) {
                const x = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;
                const h = getTerrainHeight(x, z);
                if (h > 10) {
                    const grassGeo = new THREE.ConeGeometry(0.5, 2, 3);
                    const grassMat = new THREE.MeshStandardMaterial({ color: 0x2a7a2a });
                    const grass = new THREE.Mesh(grassGeo, grassMat);
                    grass.position.set(x, h, z);
                    grass.rotation.x = Math.random() * 0.5;
                    grass.rotation.z = Math.random() * 0.5;
                    scene.add(grass);
                }
            }
            
            for(let i = 0; i < 5; i++) {
                const snowX = (Math.random() - 0.5) * 400;
                const snowZ = (Math.random() - 0.5) * 400;
                const snowH = getTerrainHeight(snowX, snowZ);
                if (snowH > 30) {
                    const snowGeo = new THREE.SphereGeometry(15 + Math.random() * 20, 16, 16);
                    const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7 });
                    const snow = new THREE.Mesh(snowGeo, snowMat);
                    snow.position.set(snowX, snowH + 10, snowZ);
                    scene.add(snow);
                    objects.push(snow);
                }
            }
            
            for(let i = 0; i < 3; i++) {
                const waterX = (Math.random() - 0.5) * 300;
                const waterZ = (Math.random() - 0.5) * 300;
                const waterH = getTerrainHeight(waterX, waterZ) - 5;
                const waterGeo = new THREE.PlaneGeometry(80, 20);
                waterGeo.rotateX(-Math.PI / 2);
                const waterMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1e90ff,
                    transparent: true,
                    opacity: 0.6,
                    roughness: 0.1,
                    metalness: 0.9
                });
                const water = new THREE.Mesh(waterGeo, waterMat);
                water.position.set(waterX, waterH, waterZ);
                scene.add(water);
                objects.push(water);
            }
        }

        function createTower(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+10, z, 5, 20, 5, 0x999999);
            createBox(x, h+21, z, 7, 2, 7, 0xAAAAAA);
            spawnChest(x, h+23, z); 
        }
        
        function createBuilding(x, z, size, height, depth, color, rotation) {
            const h = getTerrainHeight(x, z);
            const mesh = createBox(x, h + height/2, z, size, height, depth, color);
            mesh.rotation.y = rotation;
            spawnChest(x+size/4, h+1, z+depth/4); 
        }
        
        function createWoodHouse(x, z, size, height, depth) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+height/2, z, size, height, depth, 0x8B4513);
            createBox(x, h+height+1, z, size+2, 2, depth+2, 0x555555); 
            spawnChest(x, h+1, z); 
        }
        
        function createTree(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+2, z, 0.5, 4, 0.5, 0x8B4513, 'tree'); 
            createBox(x, h+5, z, 3, 3, 3, 0x228B22, 'tree'); 
        }

        function generatePOIs() {
            for(let i=0; i<3; i++) {
                const x = (Math.random()-0.5)*80;
                const z = (Math.random()-0.5)*80;
                createTower(x, z);
            }

            createBuilding(-200, -200, 20, 10, 30, 0x444444, Math.PI/2);
            createWoodHouse(-200, 200, 10, 12, 15); 
            createBuilding(250, 250, 15, 8, 15, 0xFF7F50, 0); 
            
            createBox(-250, getTerrainHeight(-250, 250)+0.1, 250, 50, 0.2, 50, 0x00BFFF); 
            createBox(-250, getTerrainHeight(-250, -250)-5, -250, 30, 10, 30, 0x696969); 
            createWoodHouse(-280, 0, 10, 8, 10); 
            
            createBox(280, getTerrainHeight(280, 0)+5, 0, 10, 10, 10, 0xFF6347); 
            createBuilding(50, 200, 12, 6, 12, 0x808080, Math.PI/4); 
            createWoodHouse(150, -100, 20, 5, 20); 
            
            createBox(-150, getTerrainHeight(-150, 100)+10, 100, 2, 20, 10, 0x000000); 
            createBox(100, getTerrainHeight(100, -250)-10, -250, 40, 20, 40, 0x222222); 
            createBox(-100, getTerrainHeight(-100, -300)+0.1, -300, 30, 0.2, 30, 0x00FF7F); 
            
            createBuilding(300, 150, 18, 10, 18, 0x9370DB, -Math.PI/4); 
            createBox(0, getTerrainHeight(0, 300), 300, 40, 0.5, 40, 0xADD8E6); 
            createBox(300, getTerrainHeight(300, -300)+15, -300, 8, 30, 8, 0xEEEEEE); 
            createBox(-300, getTerrainHeight(-300, 150)+0.5, 150, 25, 1, 25, 0xF4A460); 
            createWoodHouse(200, 0, 20, 10, 10); 

            for(let i=0; i<3; i++) {
                for(let j=0; j<3; j++) {
                    const x = -350 + (i*25);
                    const z = -250 + (j*25);
                    createBox(x, getTerrainHeight(x, z)+0.5, z, 8, 6, 8, 0xD2B48C);
                }
            }
            createBox(-325, getTerrainHeight(-325, -225)+10, -225, 5, 20, 5, 0x8B7355);
            
            createBox(350, getTerrainHeight(350, -350)+0.1, -350, 60, 0.5, 60, 0xFF6B6B);
            for(let i=0; i<4; i++) {
                const angle = (i*Math.PI*2)/4;
                const x = 350 + Math.cos(angle)*30;
                const z = -350 + Math.sin(angle)*30;
                createBuilding(x, z, 10, 8, 10, 0xFFD166, angle);
            }
            createBox(350, getTerrainHeight(350, -350)+15, -350, 5, 30, 5, 0x06D6A0);
            
            for(let i=0; i<12; i++) {
                const x = 400 + (Math.random()-0.5)*60;
                const z = 150 + (Math.random()-0.5)*60;
                createTree(x, z);
            }
            createBuilding(400, 150, 25, 12, 25, 0x8B4513, 0);
            createBox(380, getTerrainHeight(380, 170)+6, 170, 20, 2, 20, 0xA0522D);
            
            createBox(-400, getTerrainHeight(-400, 400)+0.1, 400, 80, 0.5, 60, 0x1E90FF);
            for(let i=0; i<5; i++) {
                const x = -430 + (i*20);
                createWoodHouse(x, 380, 8, 7, 8);
            }
            createBox(-420, getTerrainHeight(-420, 420)+12, 420, 4, 24, 4, 0x708090);
            
            createBox(0, getTerrainHeight(0, -400)-10, -400, 50, 20, 50, 0x696969);
            createBuilding(20, -380, 15, 8, 15, 0x333333, Math.PI/4);
            createBuilding(-20, -420, 15, 8, 15, 0x333333, -Math.PI/4);
            createBox(0, getTerrainHeight(0, -400)+5, -400, 10, 10, 10, 0xFFD700);

            for(let i=0; i<40; i++) {
                const x = (Math.random()-0.5)*400;
                const z = (Math.random()-0.5)*400;
                createTree(x, z);
            }
        }

        function spawnCars() {
            for(let i = 0; i < 4; i++) {
                const x = (Math.random()-0.5)*200;
                const z = (Math.random()-0.5)*200;
                const h = getTerrainHeight(x, z);
                
                const carGroup = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 5), new THREE.MeshStandardMaterial({color: Math.random() * 0xffffff}));
                body.position.y = 1;
                carGroup.add(body);
                
                carGroup.position.set(x, h, z); 
                scene.add(carGroup);
                
                cars.push({ mesh: carGroup, speed: 0, rotationY: carGroup.rotation.y, driving: false, raycaster: new THREE.Raycaster() });
            }
        }

        function spawnChest(x, y, z) {
            const chest = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1), new THREE.MeshStandardMaterial({color: 0xFFD700}));
            chest.position.set(x, y, z);
            scene.add(chest);
            chests.push(chest);
        }
        
        function createBotMesh(x, y, z) {
            const group = new THREE.Group();
            
            // UPDATED: More realistic bot model
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({color: 0xFFA07A}));
            head.position.y = 2.4; 
            group.add(head);

            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, 1.2, 16), new THREE.MeshStandardMaterial({color: 0x007bff}));
            body.position.y = 1.6;
            group.add(body);

            const armGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const armMat = new THREE.MeshStandardMaterial({color: 0xFFA07A});
            const armL = new THREE.Mesh(armGeo, armMat);
            armL.position.set(-0.8, 1.6, 0);
            armL.rotation.z = Math.PI / 4;
            const armR = new THREE.Mesh(armGeo, armMat);
            armR.position.set(0.8, 1.6, 0);
            armR.rotation.z = -Math.PI / 4;
            group.add(armL);
            group.add(armR);

            const legGeo = new THREE.CylinderGeometry(0.3, 0.2, 1.2, 8);
            const legMat = new THREE.MeshStandardMaterial({color: 0x444444});
            const legL = new THREE.Mesh(legGeo, legMat);
            legL.position.set(-0.3, 0.6, 0);
            const legR = new THREE.Mesh(legGeo, legMat);
            legR.position.set(0.3, 0.6, 0);
            group.add(legL);
            group.add(legR);

            group.position.set(x, y, z);
            group.castShadow = settings.shadows;
            return group;
        }

        function spawnBots() {
            const botTypes = [
                { aggression: 0.9, accuracy: 0.7, range: 50, speed: 1.2 }, // Aggressive
                { aggression: 0.6, accuracy: 0.8, range: 80, speed: 1.0 }, // Sniper
                { aggression: 0.95, accuracy: 0.5, range: 30, speed: 1.5 },  // Rusher
                { aggression: 0.4, accuracy: 0.9, range: 100, speed: 0.8 } // Defensive
            ];
            
            for(let i = 0; i < BOT_COUNT; i++) { 
                let x, z;
                do {
                    x = (Math.random()-0.5)*WORLD_SIZE*0.8;
                    z = (Math.random()-0.5)*WORLD_SIZE*0.8;
                } while (Math.abs(x) < 100 && Math.abs(z) < 100); 

                const h = getTerrainHeight(x, z);
                
                const mesh = createBotMesh(x, h + 1, z);
                scene.add(mesh);
                
                const randomWeaponKeys = ['RFAR', 'STINGER', 'DRUM_SMG', 'PISTOL', 'BURST_SMG'];
                const botWeaponKey = randomWeaponKeys[Math.floor(Math.random() * randomWeaponKeys.length)];
                const botWeapon = createWeaponItem(botWeaponKey, 'COMMON');
                botWeapon.stats.currentMag = botWeapon.stats.mag; 
                
                const botType = botTypes[Math.floor(Math.random() * botTypes.length)];
                
                bots.push({ 
                    mesh: mesh, 
                    health: 200, 
                    shield: 100, 
                    target: null, 
                    lastShot: 0, 
                    weapon: botWeapon, 
                    lastMove: performance.now(),
                    velocity: new THREE.Vector3(0, 0, 0),
                    lastStormDamage: 0,
                    moveCooldown: 0, 
                    currentDirection: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(),
                    attackRange: botType.range,
                    isAggressive: Math.random() < botType.aggression,
                    accuracy: botType.accuracy,
                    moveSpeed: botType.speed,
                    patrolPoints: [],
                    currentPatrolIndex: 0,
                    lastTargetUpdate: 0,
                    isTakingCover: false,
                    coverTimer: 0,
                    canJump: Math.random() < 0.3,
                    canStrafe: Math.random() < 0.5,
                    strafeDirection: Math.random() < 0.5 ? 1 : -1,
                    strafeTimer: 0,
                    // UPDATED: Bot shooting range
                    maxShootingRange: 50 // Bots will shoot within 50 meters
                });
                
                for(let j = 0; j < 3; j++) {
                    bots[i].patrolPoints.push(new THREE.Vector3(
                        x + (Math.random()-0.5)*50,
                        h,
                        z + (Math.random()-0.5)*50
                    ));
                }
            }
        }

        // ===============================================================
        // === ITEM & HEALING LOGIC ======================================
        // ===============================================================

        function useHealingItem() {
            const item = player.inventory[player.slot];
            
            if (player.isHealing) {
                if (!player.healingItem.continuous) finishHealing();
                return;
            }

            if (!item || item.category !== 'consumable' || item.count <= 0) return;
            
            if (item.instant) {
                 if (item.type === 'shield' && (player.shield < item.max || player.overshield < OVER_SHIELD_MAX)) {
                    if(player.shield < 100) {
                        player.shield = Math.min(item.max, player.shield + item.val);
                    } else if (player.overshield < OVER_SHIELD_MAX) {
                        player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + item.val);
                    } else {
                        return; 
                    }
                    item.count -= 1; 
                    if (item.count <= 0) player.inventory[player.slot] = null;
                    updateUI();
                    playSound('pickup_item');
                    if (player.overshield < OVER_SHIELD_MAX) {
                        player.lastOvershieldDamage = performance.now();
                        player.lastOvershieldBreak = performance.now();
                    }
                    return;
                }
            }

            let canUse = false;
            if (item.type === 'shield' && (player.shield < item.max || player.overshield < OVER_SHIELD_MAX)) canUse = true;
            if (item.type === 'health' && player.health < item.max) canUse = true;
            if (item.type === 'continuous') canUse = (player.health < 100 || player.shield < 100 || player.overshield < OVER_SHIELD_MAX);

            if (canUse) {
                player.isHealing = true;
                player.healingItem = item;
                player.healingStartTime = performance.now();
                document.getElementById('healing-progress').style.display = 'block';
                document.getElementById('healing-text').innerText = `USING ${item.name.toUpperCase()}...`;
                updateUI();
                
                if (!item.continuous && !item.instant) {
                    playSound('open_chest');
                    setTimeout(() => {
                        if(player.isHealing && player.healingItem === item) {
                            applyHealing(item);
                            finishHealing();
                            playSound('pickup_item');
                        }
                    }, item.time);
                } else if (item.continuous) {
                    playSound('open_chest');
                }
            }
        }
        
        function applyHealing(item) {
            if (item.type === 'shield') {
                player.shield = Math.min(item.max, player.shield + item.val); 
            } else if (item.type === 'health') {
                player.health = Math.min(item.max, player.health + item.val);
            } 
            
            item.count -= 1;
            if (item.count <= 0) {
                const slotIndex = player.inventory.findIndex(i => i === item);
                if (slotIndex !== -1) player.inventory[slotIndex] = null;
            }
            updateUI();
        }
        
        function applyContinuousHealing(item, dt) {
            const timeElapsed = performance.now() - player.healingStartTime;
            const percentage = Math.min(1, timeElapsed / item.time);
            document.getElementById('healing-bar').style.width = `${percentage * 100}%`;
            
            const interval = 1000; 
            if (!player.lastHealTick || (performance.now() - player.lastHealTick) >= interval) {
                if(player.overshield < OVER_SHIELD_MAX) {
                    player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + item.shieldVal); 
                    player.lastOvershieldBreak = performance.now();
                } else if(player.shield < 100) {
                    player.shield = Math.min(100, player.shield + item.shieldVal); 
                } else if (player.health < 100) {
                    player.health = Math.min(100, player.health + item.val);
                }
                updateUI();
                player.lastHealTick = performance.now();
            }

            if (timeElapsed >= item.time || (player.health === 100 && player.shield === 100 && player.overshield === OVER_SHIELD_MAX)) {
                finishHealing();
                playSound('pickup_item');
            }
        }

        function finishHealing() {
            if (!player.isHealing) return; 

            player.isHealing = false;
            
            const item = player.healingItem;
            if (item && item.continuous) {
                 item.count -= 1;
                 if (item.count <= 0) {
                    const slotIndex = player.inventory.findIndex(i => i === item);
                    if (slotIndex !== -1) player.inventory[slotIndex] = null;
                 }
            }

            player.healingItem = null;
            player.lastHealTick = 0;
            document.getElementById('healing-progress').style.display = 'none';
            
            updateUI();
        }

        function tryInteract() {
            const pos = camera.position;
            
            for(let door of doors) {
                if(pos.distanceTo(door.mesh.position) < 5) {
                    door.open = !door.open;
                    const rotation = door.open ? door.initialRotation + Math.PI / 2 : door.initialRotation;
                    door.mesh.rotation.y = rotation;
                    
                    const shiftDir = new THREE.Vector3();
                    shiftDir.setFromEuler(new THREE.Euler(0, door.initialRotation + Math.PI / 4, 0));
                    door.mesh.position.sub(shiftDir.multiplyScalar(0.75)); 
                    playSound('open_chest');
                    if (player.isHealing) finishHealing();
                    return;
                }
            }

            for(let c of cars) {
                if(pos.distanceTo(c.mesh.position) < 5) {
                    if(player.vehicle) {
                        player.vehicle.driving = false;
                        player.vehicle = null;
                        camera.position.y += 2; 
                        camera.position.x = c.mesh.position.x + 5; 
                        camera.position.z = c.mesh.position.z + 5; 
                        playSound('pickup_item');
                    } else {
                        if (player.isHealing) finishHealing();
                        player.vehicle = c;
                        c.driving = true;
                        playSound('pickup_item');
                    }
                    updateUI();
                    return;
                }
            }
            
            for(let i = chests.length - 1; i >= 0; i--) {
                if(pos.distanceTo(chests[i].position) < 4) {
                    const chestPos = chests[i].position.clone();
                    scene.remove(chests[i]);
                    chests.splice(i, 1);
                    
                    if (player.isHealing) finishHealing();

                    player.chestsOpened++;
                    
                    const randomWeaponKey = getRandomWeaponKey();
                    const randomRarity = getRandomRarity();
                    spawnLoot(chestPos.x + 0.5, chestPos.y, chestPos.z + 0.5, 'weapon', randomRarity, randomWeaponKey);
                    
                    if (Math.random() < 0.15) {
                        spawnLoot(chestPos.x - 0.5, chestPos.y, chestPos.z - 0.5, 'weapon', randomRarity, 'HEAVY_AR');
                    } else {
                        const randomConsumableKey = getRandomConsumableKey();
                        spawnLoot(chestPos.x - 0.5, chestPos.y, chestPos.z - 0.5, 'consumable', randomConsumableKey);
                    }
                    
                    if (Math.random() < 0.3) {
                        spawnLoot(chestPos.x, chestPos.y, chestPos.z, 'weapon', getRandomRarity(), getRandomWeaponKey());
                    }
                    
                    playSound('open_chest');
                    return;
                }
            }

            for(let i = loot.length - 1; i >= 0; i--) {
                const currentLoot = loot[i];
                if(pos.distanceTo(currentLoot.mesh.position) < 4) {
                    const currentItem = player.inventory[player.slot];
                    
                    if (player.isHealing) finishHealing();

                    if (currentLoot.data.category === 'consumable') {
                        const stackSlot = player.inventory.find(item => item && item.name === currentLoot.data.name && item.count < item.maxStack);
                        if (stackSlot) {
                            stackSlot.count = Math.min(stackSlot.maxStack, stackSlot.count + currentLoot.data.count);
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            return;
                        }
                    }

                    if (currentLoot.data.rarity && currentLoot.data.rarity.color === '#ffd700') {
                        player.legendaryItemsHeld++;
                    }

                    if (currentItem) {
                        if (currentItem.category !== currentLoot.data.category || 
                            (currentLoot.data.category === 'weapon')) {
                            
                            dropItem(player.slot, currentLoot.mesh.position.clone().add(new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2)));
                            giveItem(currentLoot.data, player.slot);
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            playSound('pickup_item');
                            return;
                        }
                    } else {
                        if(giveItem(currentLoot.data, player.slot)) {
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            playSound('pickup_item');
                            return;
                        }
                    }
                }
            }
            
            for (let b of buildings) {
                if (b.type === 'tree' && pos.distanceTo(b.mesh.position) < 5) {
                    player.wood += 5;
                    updateUI();
                    
                    b.health -= 50; 
                    if (b.health <= 0) {
                        scene.remove(b.mesh);
                        objects = objects.filter(obj => obj !== b.mesh);
                        buildings = buildings.filter(bldg => bldg !== b);
                        playSound('impact_hit');
                    } else {
                        playSound('impact_hit');
                    }
                    return;
                }
            }
            
            useHealingItem();
        }
        
        function dropItem(slotIndex, position) {
            const itemToDrop = player.inventory[slotIndex];
            if (!itemToDrop) return;
            
            if (player.isHealing && player.healingItem === itemToDrop) {
                finishHealing();
            }

            spawnLoot(position.x, position.y + 1, position.z, itemToDrop);
            player.inventory[slotIndex] = null;
            playSound('impact_hit');
        }

        function createWeaponItem(typeKey, rarityKey) {
            const base = WEAPONS_BASE[typeKey];
            const rar = RARITY_MULTIPLIERS[rarityKey];
            
            let damageMultiplier = 1;
            if (typeKey === 'AUTO_SHG') damageMultiplier = 2.0;
            if (typeKey === 'STINGER') damageMultiplier = 1.25;
            if (typeKey === 'DUAL_SMG') damageMultiplier = 1.25;
            
            return {
                category: 'weapon',
                name: base.name,
                rarity: rar,
                stats: { 
                    ...base, 
                    dmg: base.dmg * rar.dmg * damageMultiplier, 
                    head: base.head * rar.dmg * damageMultiplier, 
                    reload: base.reload * rar.reload, 
                    currentMag: base.mag 
                }, 
                maxAmmo: base.mag
            };
        }
        
        function getRandomRarity() {
            const rarityPool = ['COMMON', 'COMMON', 'UNCOMMON', 'UNCOMMON', 'RARE', 'EPIC', 'LEGENDARY'];
            return rarityPool[Math.floor(Math.random() * rarityPool.length)];
        }

        function getRandomWeaponKey() {
            const keys = Object.keys(WEAPONS_BASE).filter(k => k !== MYTHIC_WEAPON_KEY && k !== 'ROCKET_LAUNCHER');
            return keys[Math.floor(Math.random() * keys.length)];
        }

        function getRandomConsumableKey() {
            return CONSUMABLE_KEYS[Math.floor(Math.random() * CONSUMABLE_KEYS.length)];
        }

        function giveItem(itemData, slot) {
            if (itemData.category === 'weapon') {
                player.inventory[slot] = itemData;
            } else if (itemData.category === 'consumable') {
                const existing = player.inventory.find(i => i && i.name === itemData.name);
                if (existing) {
                    existing.count = Math.min(existing.maxStack, existing.count + itemData.count);
                } else if (player.inventory[slot] === null) {
                    player.inventory[slot] = itemData;
                } else {
                    return false; 
                }
            } else if (itemData === 'mythic') {
                const mythicWeapon = createWeaponItem(MYTHIC_WEAPON_KEY, 'MYTHIC');
                player.inventory[slot] = mythicWeapon;
            }
            return true;
        }

        function spawnLoot(x, y, z, type, rarity = null, weaponKey = null) {
            let item;
            if(type === 'weapon' || type === 'mythic') {
                const typeKey = type === 'mythic' ? MYTHIC_WEAPON_KEY : (weaponKey || getRandomWeaponKey());
                const rarityKey = type === 'mythic' ? 'MYTHIC' : (rarity || getRandomRarity());
                item = createWeaponItem(typeKey, rarityKey);
            } else if (type === 'consumable') {
                const consKey = rarity; 
                const base = CONSUMABLES[consKey];
                item = { category: 'consumable', ...base, count: 1 };
                item.rarity = RARITY_MULTIPLIERS[base.rarity]; 
            } else if (typeof type === 'object') {
                item = type; 
                if (item.category === 'consumable' && typeof item.rarity === 'string') {
                    item.rarity = RARITY_MULTIPLIERS[item.rarity];
                }
            } else {
                return;
            }

            let color = 0x808080;
            if (item.rarity && item.rarity.color) color = parseInt(item.rarity.color.substring(1), 16);
            else if (item.category === 'consumable') color = 0x00d2ff;

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({color: color}));
            mesh.position.set(x, y, z);
            scene.add(mesh);
            loot.push({ mesh: mesh, data: item });
        }

        // ===============================================================
        // === SHOOTING & DAMAGE SYSTEM ==================================
        // ===============================================================

        function shoot(item, isBurst = false) {
            if (item.stats.currentMag <= 0 || player.isReloading || player.isHealing) {
                if (!player.isReloading) reload();
                return;
            }
            
            if (player.isHealing) finishHealing();

            if (item.stats.burst && !isBurst) {
                if (player.isBursting) return;
                player.isBursting = true;
                player.burstCount = 0;
                
                const burstShot = () => {
                    if (player.burstCount < item.stats.burst && item.stats.currentMag > 0) {
                        doSingleShot(item);
                        player.burstCount++;
                        player.burstTimer = setTimeout(burstShot, 100); 
                    } else {
                        player.isBursting = false;
                        if (item.stats.currentMag > 0) {
                             player.burstTimer = setTimeout(() => {}, item.stats.burstDelay);
                        }
                    }
                };
                burstShot();
                return;
            } else if (item.stats.burst && isBurst) {
                doSingleShot(item);
                return;
            }
            
            doSingleShot(item);
        }
        
        function doSingleShot(item) {
            player.shotsFired++;
            
            const fireOrigin = camera.position.clone();
            const fireDirection = new THREE.Vector3();
            camera.getWorldDirection(fireDirection);

            createMuzzleFlash(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(0.5)), fireDirection);
            
            playSound('shoot');
            if (controllerConnected) vibrateController('shoot');
            
            if (item.stats.bulletType === 'hitscan') {
                handleHitscan(item, fireOrigin, fireDirection, player);
            } else if (item.stats.bulletType === 'projectile') {
                handleProjectile(item, fireOrigin, fireDirection);
            }
            
            item.stats.currentMag -= 1;
            lastShot = performance.now();
            updateUI();
        }

        function handleHitscan(item, fireOrigin, fireDirection, shooter) {
            const spread = shooter === player ? (player.ads ? 0.005 : item.stats.spread) : item.stats.spread * 1.5;
            
            for(let p = 0; p < item.stats.pellets; p++) {
                const ray = new THREE.Raycaster(fireOrigin);
                const spreadDir = fireDirection.clone();
                
                const randomX = (Math.random() - 0.5) * spread;
                const randomY = (Math.random() - 0.5) * spread;
                spreadDir.x += randomX;
                spreadDir.y += randomY;
                spreadDir.normalize();

                if (shooter !== player && Math.random() < 0.5) {
                    spreadDir.x += (Math.random() - 0.5) * 0.3;
                    spreadDir.y += (Math.random() - 0.5) * 0.3;
                    spreadDir.normalize();
                }

                ray.ray.direction.copy(spreadDir);

                const targets = bots.map(b => b.mesh).concat(objects).concat(cars.map(c=>c.mesh));
                const hits = ray.intersectObjects(targets, true);
                
                if(hits.length > 0) {
                    const hit = hits[0];
                    let hitBot = null;
                    let hitPlayer = false;
                    let isHeadshot = false;

                    let obj = hit.object;
                    while(obj && obj.parent && obj.parent.type !== 'Scene') {
                        const b = bots.find(bot => bot.mesh === obj.parent);
                        if(b) { hitBot = b; break; }
                        obj = obj.parent;
                    }
                    if(!hitBot) hitBot = bots.find(bot => bot.mesh === hit.object);
                    
                    // UPDATED: Bot shooting at player within 50 meters
                    if (shooter !== player) {
                        const playerDist = hit.point.distanceTo(camera.position);
                        if (playerDist < 2 && hit.distance < item.stats.range) {
                            hitPlayer = true; 
                        }
                    }

                    if(hitBot && hitBot !== shooter) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > hitBot.mesh.position.y + 2.2) { 
                            dmg = item.stats.head; 
                            isHeadshot = true;
                        }
                        
                        player.shotsHit++;
                        player.totalDamage += dmg;
                        if (isHeadshot) player.headshots++;
                        
                        createBulletTrail(fireOrigin, hit.point);
                        createImpactEffect(hit.point, isHeadshot);
                        
                        applyDamage(hitBot, dmg, hit.point, shooter, isHeadshot);
                    } else if (hitPlayer) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > camera.position.y + 0.5) { 
                            dmg = item.stats.head; 
                            isHeadshot = true;
                        }
                        
                        createBulletTrail(fireOrigin, hit.point);
                        createImpactEffect(hit.point, hit.point.y > camera.position.y + 0.5);
                        
                        takeDamage(dmg, hit.point); 
                        playSound('player_hit');
                        if (controllerConnected) vibrateController('hit');
                        showHitMarker(isHeadshot);
                    } else {
                        const buildingHit = buildings.find(b => b.mesh === hit.object);
                        if (buildingHit) {
                            if (buildingHit.type !== 'indestructible_wood') {
                                buildingHit.health -= 50; 
                                if (buildingHit.health <= 0) {
                                    scene.remove(buildingHit.mesh);
                                    objects = objects.filter(obj => obj !== buildingHit.mesh);
                                    buildings = buildings.filter(bldg => bldg !== buildingHit);
                                }
                            }
                        }
                        
                        createBulletTrail(fireOrigin, hit.point);
                        createImpactEffect(hit.point, false);
                        
                        playSound('impact_hit');
                    }
                } else {
                    const endPoint = fireOrigin.clone().add(spreadDir.clone().multiplyScalar(item.stats.range));
                    createBulletTrail(fireOrigin, endPoint);
                }
            }
        }
        
        function handleProjectile(item, fireOrigin, fireDirection) {
            const rocketGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const rocketMat = new THREE.MeshBasicMaterial({ color: 0xff4d4d });
            const rocketMesh = new THREE.Mesh(rocketGeo, rocketMat);
            rocketMesh.position.copy(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(1))); 
            scene.add(rocketMesh);
            
            createMuzzleFlash(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(0.5)), fireDirection);
            
            projectiles.push({
                mesh: rocketMesh,
                velocity: fireDirection.clone().multiplyScalar(50), 
                damage: item.stats.explosionDamage,
                radius: item.stats.explosionRadius,
                shooter: player,
                isExpired: false
            });
        }
        
        function updateProjectiles(dt) {
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (p.isExpired) continue;
                
                const oldPos = p.mesh.position.clone();
                p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                
                const collisionRay = new THREE.Raycaster(oldPos, p.velocity.clone().normalize(), 0, p.mesh.position.distanceTo(oldPos));
                const targets = bots.map(b => b.mesh).concat(objects).concat(cars.map(c=>c.mesh));
                const hits = collisionRay.intersectObjects(targets, true);

                if (hits.length > 0) {
                    const hit = hits[0];
                    explode(p, hit.point);
                    p.isExpired = true; 
                }

                if (Math.abs(p.mesh.position.x) > WORLD_SIZE / 2 || Math.abs(p.mesh.position.z) > WORLD_SIZE / 2) {
                    explode(p, p.mesh.position);
                    p.isExpired = true;
                }
            }
            
            projectiles = projectiles.filter(p => !p.isExpired);
        }

        function explode(projectile, hitPoint) {
            playSound('explosion');
            
            createImpactEffect(hitPoint, false);
            
            if (hitPoint.distanceTo(camera.position) < projectile.radius) {
                const dist = hitPoint.distanceTo(camera.position);
                const reduction = Math.max(0, dist / projectile.radius);
                const damage = projectile.damage * (1 - reduction);
                takeDamage(damage, hitPoint);
            }

            bots.forEach(bot => {
                if (hitPoint.distanceTo(bot.mesh.position) < projectile.radius) {
                    const dist = hitPoint.distanceTo(bot.mesh.position);
                    const reduction = Math.max(0, dist / projectile.radius);
                    const damage = projectile.damage * (1 - reduction);
                    applyDamage(bot, damage, bot.mesh.position, projectile.shooter, false);
                }
            });
            
            scene.remove(projectile.mesh);
        }
        
        function applyDamage(target, amount, hitPoint, source, isHeadshot = false, type = 'body') {
            amount = Math.round(amount);
            let remainingDmg = amount;

            if(target === player) {
                 takeDamage(amount, hitPoint, type); 
                 return;
            }

            if(target.shield > 0) {
                target.shield -= remainingDmg;
                if(target.shield < 0) { 
                    remainingDmg = -target.shield; 
                    target.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            } 
            
            if (remainingDmg > 0) {
                target.health -= remainingDmg;
            }
            
            showDamage(amount, hitPoint, type, isHeadshot);
            
            if(target.health <= 0) {
                if (bots.includes(target)) {
                    if (source === player) {
                        player.eliminations += 1;
                        addKillFeedMessage("You", "Bot", isHeadshot);
                    } else {
                        addKillFeedMessage("Bot", "Bot", isHeadshot);
                    }
                    scene.remove(target.mesh);
                    bots = bots.filter(b => b !== target);
                    
                    const randomWeaponKey = getRandomWeaponKey();
                    const randomRarity = getRandomRarity(); 
                    const botWeapon = createWeaponItem(randomWeaponKey, randomRarity);
                    
                    const dropConsumableKey = getRandomConsumableKey();
                    const consumableBase = CONSUMABLES[dropConsumableKey];
                    const healingItemDrop = { 
                        category: 'consumable', 
                        ...CONSUMABLES[dropConsumableKey], 
                        count: 1, 
                        rarity: consumableBase.rarity 
                    };
                    
                    spawnLoot(hitPoint.x + 1, hitPoint.y, hitPoint.z, botWeapon); 
                    spawnLoot(hitPoint.x - 1, hitPoint.y, hitPoint.z, healingItemDrop); 
                    player.wood += 50; 
                    
                    playSound('elimination');
                    checkWin();
                }
            }
        }
        
        function takeDamage(amount, sourcePoint, type = 'body') {
            amount = Math.floor(amount);
            if (amount <= 0 || player.dead) return;
            
            let remainingDmg = amount;
            
            const overshieldBefore = player.overshield;
            
            if(player.overshield > 0) {
                player.overshield -= remainingDmg;
                if(player.overshield < 0) { 
                    remainingDmg = -player.overshield; 
                    player.overshield = 0; 
                    
                    if (overshieldBefore > 0) {
                        player.lastOvershieldBreak = performance.now();
                    }
                } else {
                    remainingDmg = 0;
                }
                player.lastOvershieldDamage = performance.now();
            }

            if (remainingDmg > 0 && player.shield > 0) {
                player.shield -= remainingDmg;
                if(player.shield < 0) { 
                    remainingDmg = -player.shield; 
                    player.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            }
            
            if (remainingDmg > 0) {
                player.health -= remainingDmg;
            }
            
            showDamage(amount, camera.position.clone().setY(camera.position.y - 0.5), type); 
            updateUI();
            
            if(player.health <= 0) {
                player.dead = true;
                handleGameOver(false);
            }
        }

        function overshieldRegen(dt) {
             if (player.dead || player.overshield === OVER_SHIELD_MAX) return;

             const timeSinceDamage = performance.now() - player.lastOvershieldDamage;
             const timeSinceBreak = performance.now() - player.lastOvershieldBreak;
             
             if (timeSinceDamage >= OVER_SHIELD_REGEN_DELAY && timeSinceBreak >= OVER_SHIELD_REGEN_DELAY) {
                 player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + (OVER_SHIELD_REGEN_RATE * dt));
                 updateUI();
             }
        }

        // ===============================================================
        // === UPDATED: IMPROVED BOT AI ==================================
        // ===============================================================

        function findClosestTarget(bot) {
            // UPDATED: Bots can see player within 50 meters
            if (player.health > 0 && !player.dead) {
                const dist = bot.mesh.position.distanceTo(camera.position);
                if (dist <= bot.maxShootingRange) {
                    return player;
                }
            }
            
            for(let otherBot of bots) {
                if(otherBot !== bot && otherBot.health > 0) {
                    const dist = bot.mesh.position.distanceTo(otherBot.mesh.position);
                    if(dist < 30 && Math.random() < 0.3) {
                        return otherBot;
                    }
                }
            }
            
            return null;
        }

        function updateBots(dt, now) {
            document.getElementById('alive-count').innerText = bots.length + 1;
            const BOT_MOVE_SPEED = WALK_SPEED * 0.4;

            for(let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];
                if (bot.health <= 0) continue;

                const h = getTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                bot.mesh.position.y = h + 1; 

                if (now - bot.lastTargetUpdate > 2000) {
                    bot.target = findClosestTarget(bot);
                    bot.lastTargetUpdate = now;
                }
                
                const target = bot.target;
                
                if(target && bot.isAggressive) {
                    const targetPos = target === player ? camera.position : target.mesh.position;
                    const dist = bot.mesh.position.distanceTo(targetPos);
                    
                    if (dist <= bot.attackRange) {
                        bot.mesh.lookAt(targetPos.x, targetPos.y, targetPos.z);
                        
                        if(dist > 25) {
                            const moveDir = new THREE.Vector3().subVectors(targetPos, bot.mesh.position).normalize();
                            bot.mesh.translateZ(BOT_MOVE_SPEED * dt * bot.moveSpeed * 2);
                            bot.moveCooldown = 1000;
                            
                            if(bot.canStrafe && bot.strafeTimer <= 0) {
                                bot.strafeDirection *= -1;
                                bot.strafeTimer = 1000 + Math.random() * 1000;
                            }
                            if(bot.strafeTimer > 0) {
                                bot.mesh.translateX(bot.strafeDirection * BOT_MOVE_SPEED * dt * 0.5);
                                bot.strafeTimer -= dt * 1000;
                            }
                            
                        } else if (dist < 8) {
                            bot.mesh.rotation.y += Math.PI/3 * (Math.random() > 0.5 ? 1 : -1) * dt;
                            bot.mesh.translateZ(-BOT_MOVE_SPEED * dt * bot.moveSpeed * 0.8);
                            bot.moveCooldown = 500;
                            bot.isTakingCover = true;
                            bot.coverTimer = 2000;
                        } else {
                            if(bot.canStrafe) {
                                bot.mesh.translateX(bot.strafeDirection * BOT_MOVE_SPEED * dt * 0.3);
                            }
                            bot.mesh.translateZ(BOT_MOVE_SPEED * dt * bot.moveSpeed * 0.5);
                            bot.moveCooldown = 800;
                        }
                        
                        // UPDATED: Bots shoot at player within 50 meters
                        const weaponStats = bot.weapon.stats; 
                        if(dist < Math.min(weaponStats.range, bot.maxShootingRange) && now - bot.lastShot > weaponStats.rate * 1000) { 
                            if(Math.random() < bot.accuracy) {
                                bot.lastShot = now;
                                
                                const fireOrigin = bot.mesh.position.clone().setY(bot.mesh.position.y + 2.4);
                                const fireDirection = new THREE.Vector3();
                                fireDirection.subVectors(targetPos.clone().setY(targetPos.y - 0.5), fireOrigin).normalize();
                                
                                const inaccuracy = (1 - bot.accuracy) * 0.1;
                                fireDirection.x += (Math.random() - 0.5) * inaccuracy;
                                fireDirection.y += (Math.random() - 0.5) * inaccuracy;
                                fireDirection.normalize();
                                
                                createMuzzleFlash(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(0.5)), fireDirection);
                                
                                handleHitscan(bot.weapon, fireOrigin, fireDirection, bot);
                            }
                        }
                    } else {
                        bot.target = null;
                    }
                } else {
                    if(bot.patrolPoints.length > 0) {
                        const currentTarget = bot.patrolPoints[bot.currentPatrolIndex];
                        const distToPoint = bot.mesh.position.distanceTo(currentTarget);
                        
                        if(distToPoint < 5) {
                            bot.currentPatrolIndex = (bot.currentPatrolIndex + 1) % bot.patrolPoints.length;
                            bot.moveCooldown = 1000 + Math.random() * 1000;
                        } else {
                            bot.mesh.lookAt(currentTarget.x, bot.mesh.position.y, currentTarget.z);
                            bot.mesh.translateZ(BOT_MOVE_SPEED * dt * 0.3);
                        }
                    } else {
                        bot.moveCooldown -= dt * 1000;
                        if (bot.moveCooldown <= 0) {
                            bot.currentDirection = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                            bot.mesh.lookAt(bot.mesh.position.clone().add(bot.currentDirection));
                            bot.moveCooldown = Math.random() * 2000 + 1000;
                        }
                        bot.mesh.translateZ(BOT_MOVE_SPEED * dt * 0.3);
                    }
                }
                
                if(bot.canJump && Math.random() < 0.01 && bot.mesh.position.y <= h + 1.1) {
                    bot.velocity.y = JUMP_FORCE * 0.7;
                }
                
                bot.velocity.y -= GRAVITY * dt;
                bot.mesh.position.y += bot.velocity.y * dt;
                
                if(bot.mesh.position.y <= h + 1) {
                    bot.mesh.position.y = h + 1;
                    bot.velocity.y = 0;
                }
                
                if(bot.isTakingCover) {
                    bot.coverTimer -= dt * 1000;
                    if(bot.coverTimer <= 0) {
                        bot.isTakingCover = false;
                    }
                }
            }
        }

        // ===============================================================
        // === VEHICLE LOGIC =============================================
        // ===============================================================

        function updateCars(dt) {
            for(const car of cars) {
                if(car.driving) {
                    const speed = inputs.w ? 15 : inputs.s ? -5 : 0;
                    car.speed = THREE.MathUtils.lerp(car.speed, speed, 0.1);

                    if (inputs.a || inputs.d) {
                        const rotationSpeed = dt * 1.5 * (inputs.d ? -1 : 1);
                        car.mesh.rotation.y += rotationSpeed * Math.sign(car.speed || 1);
                    }
                    
                    car.mesh.translateZ(car.speed * dt);
                    
                    if (Math.abs(car.speed) > 5) {
                        const currentPos = car.mesh.position;
                        
                        bots.forEach(bot => {
                            if (currentPos.distanceTo(bot.mesh.position) < 3) {
                                applyDamage(bot, 100, bot.mesh.position, player);
                            }
                        });
                    }

                    const h = getTerrainHeight(car.mesh.position.x, car.mesh.position.z);
                    car.mesh.position.y = h;

                    if(player.vehicle === car) {
                        camera.position.copy(car.mesh.position).add(new THREE.Vector3(0, PLAYER_HEIGHT + 1, 0));
                    }
                }
            }
        }

        // ===============================================================
        // === REDESIGNED UI FUNCTIONS ===================================
        // ===============================================================
        
        function updateUI() {
            player.health = Math.max(0, Math.min(100, player.health));
            player.shield = Math.max(0, Math.min(100, player.shield));
            player.overshield = Math.max(0, Math.min(OVER_SHIELD_MAX, player.overshield));
            
            document.getElementById('health-value').innerText = Math.ceil(player.health);
            document.getElementById('shield-value').innerText = Math.ceil(player.shield);
            document.getElementById('overshield-value').innerText = Math.ceil(player.overshield);
            document.getElementById('wood-value').innerText = player.wood;
            
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('shield-bar').style.width = player.shield + '%';
            document.getElementById('overshield-bar').style.width = (player.overshield / OVER_SHIELD_MAX) * 100 + '%';
            
            player.inventory.forEach((item, i) => {
                const slot = document.getElementById(`slot-${i}`);
                slot.innerHTML = '';
                
                if(item) {
                    const icon = item.category === 'weapon' ? item.stats.icon : item.icon;
                    const name = item.name; 
                    const count = item.category === 'consumable' ? item.count : '';
                    
                    slot.innerHTML = `
                        <div class="slot-key">${i+1}</div>
                        <div class="slot-icon">${icon}</div>
                        <div class="slot-name">${name}</div>
                        ${count ? `<div class="slot-count">${count}</div>` : ''}
                    `;
                    
                    let rarityKey = '';
                    if (item.rarity && item.rarity.color) {
                        const rarityEntry = Object.entries(RARITY_MULTIPLIERS).find(([, value]) => value === item.rarity);
                        if (rarityEntry) {
                            rarityKey = rarityEntry[0].toLowerCase(); 
                        } else if (typeof item.rarity === 'string') {
                            rarityKey = item.rarity.toLowerCase();
                        }
                    }
                    
                    slot.className = `inventory-slot ${i===player.slot ? 'active' : ''} rarity-${rarityKey}`;
                } else {
                    slot.className = `inventory-slot ${i===player.slot ? 'active' : ''}`;
                    slot.innerHTML = `<div class="slot-key">${i+1}</div>`;
                }
            });
            
            let msg = "Interact (E)";
            const pos = camera.position;
            const nearestChest = chests.some(c => pos.distanceTo(c.position) < 6);
            const nearestLoot = loot.some(l => pos.distanceTo(l.mesh.position) < 4);
            const nearestDoor = doors.some(d => pos.distanceTo(d.mesh.position) < 5);
            const nearestCar = cars.some(c => pos.distanceTo(c.mesh.position) < 5);

            const showInteract = nearestChest || nearestLoot || nearestDoor || nearestCar || player.vehicle;
            
            if (!showInteract) {
                const currentItem = player.inventory[player.slot];
                if (currentItem && currentItem.category === 'consumable' && currentItem.count > 0 && 
                    ((currentItem.type === 'shield' && (player.shield < 100 || player.overshield < OVER_SHIELD_MAX)) || (currentItem.type === 'health' && player.health < 100) || currentItem.type === 'continuous')) {
                     msg = player.isHealing ? `Cancel Healing (E)` : `Use ${currentItem.name} (E)`;
                     document.getElementById('interact-prompt').style.display = 'block';
                } else {
                    document.getElementById('interact-prompt').style.display = 'none';
                }
            } else {
                 if (player.vehicle) msg = "Exit Vehicle (E)";
                 else if (nearestChest) msg = "Open Chest (E)";
                 else if (nearestLoot) msg = "Pickup/Swap (E)";
                 else if (nearestDoor) msg = "Open Door (E)";
                 else if (nearestCar) msg = "Enter Vehicle (E)";
                 document.getElementById('interact-prompt').style.display = 'block';
            }
            
            document.getElementById('interact-prompt').innerText = msg;
            
            const item = player.inventory[player.slot];
            const isWeapon = item && item.category === 'weapon';
            const showReload = isWeapon && item.stats.currentMag < item.stats.mag;
            document.getElementById('btn-reload').style.display = gameMode === 'mobile' && isWeapon && showReload && !player.isReloading ? 'flex' : 'none';
            
            updateStatsDisplay();
        }
        
        function switchSlot(idx) {
            if (player.isHealing) {
                const currentHealingSlot = player.inventory.findIndex(i => i === player.healingItem);
                if (currentHealingSlot === player.slot && !player.healingItem.continuous) {
                    finishHealing();
                } else if (currentHealingSlot !== player.slot) {
                    finishHealing();
                }
            }

            if(idx < 0 || idx > 4) return;
            player.slot = idx;
            
            document.querySelectorAll('.inventory-slot').forEach((el, i) => {
                el.classList.toggle('active', i === idx);
            });
            
            if(viewModel) weaponScene.remove(viewModel);
            const item = player.inventory[idx];
            
            if(item && item.category === 'weapon') {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
                const color = item.rarity && item.rarity.color ? item.rarity.color : '#FFFFFF'; 
                const mat = new THREE.MeshStandardMaterial({ color: color });
                viewModel = new THREE.Mesh(geo, mat);
                viewModel.position.set(0.2, -0.2, -0.5);
                weaponScene.add(viewModel);
                
                toggleADS(player.ads); 
            } else {
                document.getElementById('crosshair').style.display = 'block';
                toggleADS(false);
            }
            
            updateUI(); 
        }
        
        function selectSlotMobile(idx) {
            if (gameMode === 'mobile') {
                switchSlot(idx);
            }
        }

        // ===============================================================
        // === INPUT & CONTROL MANAGEMENT (UPDATED) ======================
        // ===============================================================
        
        function setGameMode(mode) {
            gameMode = mode;
            const mobileControls = document.getElementById('mobile-controls');
            const gameContainer = document.getElementById('game-container');

            if (mode === 'mobile') {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'block';
                gameContainer.removeEventListener('mousedown', lockPointer);
                
                initMobileControls();
            } else if (mode === 'controller') {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'none';
                gameContainer.removeEventListener('mousedown', lockPointer);
            } else {
                if (controls) controls.enabled = true;
                mobileControls.style.display = 'none';
                gameContainer.addEventListener('mousedown', lockPointer);
            }
        }
        
        function lockPointer() {
            if (controls && gameMode === 'desktop') {
                controls.lock();
                inputs.fire = false; 
            }
        }

        function setupPCLock() {
            if (controls) controls.enabled = true;
            document.getElementById('game-container').addEventListener('mousedown', lockPointer);
        }

        // === UPDATED: Mobile controls with improved sensitivity ===
        function initMobileControls() {
            const touchLeft = document.getElementById('touch-left');
            const touchRight = document.getElementById('touch-right');
            const joystickThumb = document.getElementById('joystick-thumb');
            const movementZone = document.getElementById('movement-zone');
            
            let touchStartX = 0;
            let touchStartY = 0;
            let isTouchingLeft = false;
            let joystickActive = false;
            
            touchLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isTouchingLeft = true;
                joystickActive = true;
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                
                const rect = touchLeft.getBoundingClientRect();
                movementZone.style.left = `${touch.clientX - rect.left - 90}px`;
                movementZone.style.bottom = '180px';
                movementZone.style.display = 'block';
            });
            
            touchLeft.addEventListener('touchmove', (e) => {
                if (!isTouchingLeft) return;
                e.preventDefault();
                const touch = e.touches[0];
                const rect = movementZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const maxDist = rect.width / 2;
                
                if(dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio;
                    dy *= ratio;
                }
                
                joystickThumb.style.transform = `translate(${dx}px, ${dy}px)`;
                
                inputs.w = dy < -20;
                inputs.s = dy > 20;
                inputs.a = dx < -20;
                inputs.d = dx > 20;
                inputs.sprint = dist > 50;
            });
            
            touchLeft.addEventListener('touchend', (e) => {
                isTouchingLeft = false;
                joystickActive = false;
                joystickThumb.style.transform = `translate(-50%, -50%)`;
                inputs.w = inputs.s = inputs.a = inputs.d = inputs.sprint = false;
                movementZone.style.display = 'none';
            });
            
            let lastCameraTouchX = 0;
            let lastCameraTouchY = 0;
            let isTouchingCamera = false;
            
            touchRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isTouchingCamera = true;
                const touch = e.touches[0];
                lastCameraTouchX = touch.clientX;
                lastCameraTouchY = touch.clientY;
                touchDeltaX = 0;
                touchDeltaY = 0;
            });
            
            touchRight.addEventListener('touchmove', (e) => {
                if (!isTouchingCamera) return;
                e.preventDefault();
                const touch = e.touches[0];
                
                const deltaX = touch.clientX - lastCameraTouchX;
                const deltaY = touch.clientY - lastCameraTouchY;
                
                // UPDATED: Increased sensitivity
                touchDeltaX = touchDeltaX * (1 - MOBILE_SMOOTHING) + deltaX * MOBILE_SMOOTHING;
                touchDeltaY = touchDeltaY * (1 - MOBILE_SMOOTHING) + deltaY * MOBILE_SMOOTHING;
                
                camera.rotation.y -= touchDeltaX * settings.mobileSensitivity;
                camera.rotation.x -= touchDeltaY * settings.mobileSensitivity;
                
                camera.rotation.x = Math.max(-MAX_CAMERA_ANGLE, Math.min(MAX_CAMERA_ANGLE, camera.rotation.x));
                
                lastCameraTouchX = touch.clientX;
                lastCameraTouchY = touch.clientY;
            });
            
            touchRight.addEventListener('touchend', (e) => {
                isTouchingCamera = false;
                touchDeltaX = 0;
                touchDeltaY = 0;
            });
            
            document.getElementById('btn-fire').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                inputs.fire = true; 
            });
            document.getElementById('btn-fire').addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                inputs.fire = false; 
            });
            
            document.getElementById('btn-jump').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                inputs.jump = true; 
            });
            document.getElementById('btn-jump').addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                inputs.jump = false; 
            });
            
            document.getElementById('btn-interact').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                tryInteract(); 
            });
            
            document.getElementById('btn-build').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                buildWall(); 
            });
            
            document.getElementById('btn-ads').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                toggleADS(true); 
                // UPDATED: Stop movement when aiming
                inputs.w = inputs.a = inputs.s = inputs.d = false;
            });
            document.getElementById('btn-ads').addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                toggleADS(false); 
            });
            
            document.getElementById('btn-reload').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                reload(); 
            });
        }

        function setupControllerInputs() {
            window.addEventListener("gamepadconnected", (e) => {
                console.log("Gamepad connected:", e.gamepad);
                gamepad = e.gamepad;
                controllerConnected = true;
                showControllerNotification();
                vibrateController('medium');
            });

            window.addEventListener("gamepaddisconnected", (e) => {
                console.log("Gamepad disconnected:", e.gamepad);
                gamepad = null;
                controllerConnected = false;
            });

            function updateControllerState() {
                if (!controllerConnected || !gamepad) return;
                
                const gp = navigator.getGamepads()[gamepad.index];
                if (!gp) return;
                
                controllerMapping.leftStick.x = gp.axes[0];
                controllerMapping.leftStick.y = gp.axes[1];
                controllerMapping.rightStick.x = gp.axes[2];
                controllerMapping.rightStick.y = gp.axes[3];
                controllerMapping.buttons.l1 = gp.buttons[4].pressed;
                controllerMapping.buttons.r1 = gp.buttons[5].pressed;
                controllerMapping.buttons.l2 = gp.buttons[6].value;
                controllerMapping.buttons.r2 = gp.buttons[7].value;
                controllerMapping.buttons.y = gp.buttons[3].pressed;
                controllerMapping.buttons.b = gp.buttons[1].pressed;
                controllerMapping.buttons.a = gp.buttons[0].pressed;
                controllerMapping.buttons.x = gp.buttons[2].pressed;
                controllerMapping.buttons.dpadUp = gp.buttons[12].pressed;
                controllerMapping.buttons.dpadDown = gp.buttons[13].pressed;
                controllerMapping.buttons.dpadLeft = gp.buttons[14].pressed;
                controllerMapping.buttons.dpadRight = gp.buttons[15].pressed;
                
                if (gameMode === 'controller') {
                    inputs.w = controllerMapping.leftStick.y < -0.3;
                    inputs.s = controllerMapping.leftStick.y > 0.3;
                    inputs.a = controllerMapping.leftStick.x < -0.3;
                    inputs.d = controllerMapping.leftStick.x > 0.3;
                    inputs.sprint = controllerMapping.buttons.a;
                    
                    if (Math.abs(controllerMapping.rightStick.x) > 0.1 || Math.abs(controllerMapping.rightStick.y) > 0.1) {
                        camera.rotation.y -= controllerMapping.rightStick.x * CONTROLLER_SENSITIVITY;
                        camera.rotation.x -= controllerMapping.rightStick.y * CONTROLLER_SENSITIVITY;
                        camera.rotation.x = Math.max(-MAX_CAMERA_ANGLE, Math.min(MAX_CAMERA_ANGLE, camera.rotation.x));
                    }
                    
                    if (controllerMapping.buttons.b && !inputs.jump) {
                        inputs.jump = true;
                        setTimeout(() => inputs.jump = false, 100);
                        vibrateController('jump');
                    }
                    
                    if (controllerMapping.buttons.y && !inputs.reload) {
                        inputs.reload = true;
                        setTimeout(() => inputs.reload = false, 100);
                    }
                    
                    if (controllerMapping.buttons.x && !inputs.use) {
                        inputs.use = true;
                        setTimeout(() => inputs.use = false, 100);
                        tryInteract();
                    }
                    
                    if (controllerMapping.buttons.l2 > 0.5) {
                        toggleADS(true);
                    } else if (player.ads) {
                        toggleADS(false);
                    }
                    
                    if (controllerMapping.buttons.r2 > 0.5) {
                        inputs.fire = true;
                    } else {
                        inputs.fire = false;
                    }
                    
                    if (controllerMapping.buttons.dpadLeft || controllerMapping.buttons.l1) {
                        const newSlot = (player.slot - 1 + 5) % 5;
                        switchSlot(newSlot);
                        vibrateController('light');
                    }
                    if (controllerMapping.buttons.dpadRight || controllerMapping.buttons.r1) {
                        const newSlot = (player.slot + 1) % 5;
                        switchSlot(newSlot);
                        vibrateController('light');
                    }
                }
            }
            
            setInterval(updateControllerState, 16);
        }

        function setupInputs() {
            const gameContainer = document.getElementById('game-container');
            
            const onKey = (e, v) => {
                if (gameMode === 'desktop' && controls && controls.isLocked) {
                    if(e.code === 'KeyW') inputs.w = v;
                    if(e.code === 'KeyS') inputs.s = v;
                    if(e.code === 'KeyA') inputs.a = v;
                    if(e.code === 'KeyD') inputs.d = v;
                    if(e.code === 'ShiftLeft') inputs.sprint = v;
                    
                    if(e.code === 'Space' && v) inputs.jump = true; 
                    if(e.code === 'KeyR' && v) inputs.reload = true; 
                    if(e.code === 'KeyX' && v) useHealingItem();
                }
            };
            
            document.addEventListener('keydown', e => {
                onKey(e, true);
                if(gameMode === 'desktop' && controls && controls.isLocked) {
                    if(e.code === 'Digit1') switchSlot(0);
                    if(e.code === 'Digit2') switchSlot(1);
                    if(e.code === 'Digit3') switchSlot(2);
                    if(e.code === 'Digit4') switchSlot(3);
                    if(e.code === 'Digit5') switchSlot(4);
                    if(e.code === 'KeyE') tryInteract();
                    if(e.code === 'KeyB') buildWall(); 
                    // Pause menu
                    if(e.code === 'Escape') togglePause();
                }
                
                // Global pause key
                if(e.code === 'Escape' && gameStarted) {
                    togglePause();
                }
            });
            
            document.addEventListener('keyup', e => onKey(e, false));
            
            document.addEventListener('mousedown', e => {
                if(player.dead || gameMode !== 'desktop' || !controls || !controls.isLocked) return;
                if(e.button === 0) inputs.fire = true;
                if(e.button === 2) toggleADS(true);
            });
            
            document.addEventListener('mouseup', e => {
                if(player.dead || gameMode !== 'desktop') return;
                if(e.button === 0) inputs.fire = false;
                if(e.button === 2) toggleADS(false);
            });
            
            document.addEventListener('contextmenu', e => e.preventDefault());
        }

        // ===============================================================
        // === INITIALIZATION & START GAME ===============================
        // ===============================================================

        function init() {
            loadLevelData();
            updateLevelDisplay();
            
            createParticles();
            initAudio();
            setupControllerInputs();
            initMiniMap();
            
            objects = [];
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            camera = new THREE.PerspectiveCamera(settings.fov, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(settings.fov, window.innerWidth/window.innerHeight, 0.01, 100);

            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            renderer = new THREE.WebGLRenderer({ 
                antialias: !isMobile,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = settings.shadows;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false; 
            
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1 : 2));
            
            const gameContainer = document.getElementById('game-container');
            gameContainer.appendChild(renderer.domElement);
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(100, 200, 100);
            sun.castShadow = settings.shadows;
            
            sun.shadow.camera.right = 150; sun.shadow.camera.left = -150;
            sun.shadow.camera.top = 150; sun.shadow.camera.bottom = -150;
            sun.shadow.mapSize.width = isMobile ? 1024 : 2048;
            sun.shadow.mapSize.height = isMobile ? 1024 : 2048;
            scene.add(sun);
            
            weaponScene.add(ambient.clone());
            weaponScene.add(sun.clone());
            
            controls = new PointerLockControls(camera, document.body);
            setupInputs(); 

            raycaster = new THREE.Raycaster();
            downRay = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, PLAYER_HEIGHT + 0.1);
            
            animate();
        }
        
        function createParticles() {
            const container = document.getElementById('particles-container');
            for(let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = `${Math.random() * 20 + 5}px`;
                particle.style.height = particle.style.width;
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 20}s`;
                particle.style.animationDuration = `${Math.random() * 10 + 15}s`;
                container.appendChild(particle);
            }
        }

        window.startGame = (mode) => {
            document.getElementById('start-screen').style.display = 'none';
            gameStarted = true;
            
            setGameMode(mode);
            
            if (mode === 'desktop') {
                setupPCLock(); 
            }
            
            player.health = 100;
            player.shield = 100;
            player.overshield = 50;
            player.wood = 0;
            player.inventory = [null, null, null, null, null];
            player.slot = 0;
            player.eliminations = 0;
            player.chestsOpened = 0;
            player.legendaryItemsHeld = 0;
            player.matchPoints = 0;
            player.dead = false;
            player.shotsFired = 0;
            player.shotsHit = 0;
            player.headshots = 0;
            player.totalDamage = 0;
            
            generateTerrain(); 
            generatePOIs(); 
            spawnBots();
            spawnCars();
            initDayNightCycle();
            initWeather();

            camera.position.set(0, getTerrainHeight(0, 0) + PLAYER_HEIGHT + 2, 0);
            
            startStormTimer(); 
            switchSlot(0);
            updateCrosshairStyle();
            
            updateUI();
        };

        // ===============================================================
        // === OPTIMIZED CORE GAME LOOP =================================
        // ===============================================================

        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            frameCount++;
            if (now - lastFpsUpdate > 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                document.getElementById('fps-counter').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = now;
            }

            if(!gameStarted || player.dead || gamePaused) {
                renderer.clear();
                renderer.render(scene, camera);
                return;
            }

            if (dt < 0.1) {
                if (player.isHealing && player.healingItem) {
                    if (player.healingItem.continuous) {
                        applyContinuousHealing(player.healingItem, dt);
                    } else if (!player.healingItem.instant) {
                        inputs.fire = false;
                        inputs.w = inputs.a = inputs.s = inputs.d = false;
                    }
                }
                overshieldRegen(dt);

                // UPDATED: Stop movement when aiming on mobile
                const canMove = (gameMode === 'mobile' && !player.ads) || gameMode === 'controller' || (controls && controls.isLocked); 
                
                if(player.vehicle) {
                    updateCars(dt);
                } else if (canMove) {
                    const speedMultiplier = player.ads ? 0.5 : 1.0; 
                    const currentSpeed = (inputs.sprint ? SPRINT_SPEED : WALK_SPEED) * speedMultiplier;
                    
                    const direction = new THREE.Vector3();
                    direction.setFromMatrixColumn(camera.matrix, 0); 
                    direction.crossVectors(camera.up, direction);
                    direction.y = 0;
                    direction.normalize();
                    
                    const right = new THREE.Vector3(-direction.z, 0, direction.x);

                    const yVelocity = velocity.y; 
                    velocity.set(0, yVelocity, 0); 

                    if(inputs.w) velocity.add(direction.clone().multiplyScalar(currentSpeed));
                    if(inputs.s) velocity.add(direction.clone().multiplyScalar(-currentSpeed));
                    if(inputs.a) velocity.add(right.clone().multiplyScalar(-currentSpeed));
                    if(inputs.d) velocity.add(right.clone().multiplyScalar(currentSpeed));
                    
                    camera.position.x += velocity.x * dt;
                    camera.position.z += velocity.z * dt;
                    velocity.y -= GRAVITY * dt; 
                    
                    const groundY = getTerrainHeight(camera.position.x, camera.position.z);
                    let floorY = groundY;
                    
                    downRay.ray.origin.copy(camera.position);
                    const hits = downRay.intersectObjects(objects, false); 
                    
                    if(hits.length > 0) {
                        const closestHit = hits[0];
                        if (closestHit.point.y > groundY + 0.1) { 
                            floorY = closestHit.point.y;
                        }
                    }
                    
                    if (camera.position.y <= floorY + PLAYER_HEIGHT && velocity.y <= 0) {
                        camera.position.y = floorY + PLAYER_HEIGHT;
                        velocity.y = 0;
                        isGrounded = true;
                    } else {
                        isGrounded = false;
                    }
                    
                    if(inputs.jump && isGrounded) {
                        velocity.y = JUMP_FORCE;
                        isGrounded = false;
                        inputs.jump = false; 
                        playSound('jump');
                    }
                    
                    camera.position.y += velocity.y * dt;
                } else {
                    velocity.x = 0; 
                    velocity.z = 0;
                }

                const canFire = gameMode === 'mobile' || gameMode === 'controller' || (controls && controls.isLocked); 
                if(inputs.fire && !player.vehicle && !player.isHealing && canFire) {
                    const item = player.inventory[player.slot];
                    if(item && item.category === 'weapon') {
                        if (item.stats.burst) {
                            if (now - lastShot > item.stats.burstDelay) {
                                shoot(item);
                            }
                        } else if(now - lastShot > item.stats.rate * 1000) {
                            shoot(item);
                        }
                    }
                } else if (inputs.reload) {
                    reload();
                    inputs.reload = false;
                }
                
                updateProjectiles(dt);
                updateBots(dt, now);
                updateStorm(now);
                updateMiniMap();
                updateDayNightCycle();
            }

            renderer.clear();
            renderer.render(scene, camera);
            renderer.clearDepth();
            renderer.render(weaponScene, weaponCamera);
            
            updateUI();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            weaponCamera.aspect = window.innerWidth / window.innerHeight;
            weaponCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1 : 2));
        });

        window.selectSlot = switchSlot;
        window.selectSlotMobile = selectSlotMobile;
        window.openSettings = openSettings;
        window.openCharacterCustomization = openCharacterCustomization;
        
        init();
    </script>
</body>
</html>
