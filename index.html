<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Battle Royale: V7.0 - Polished Edition (Final)</title>
    <style>
        /* ======================================= */
        /* === V7.0 MODERN UI / UX DESIGN === */
        /* ======================================= */
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Rajdhani', sans-serif; 
            user-select: none; 
            background: #000;
            touch-action: none; /* Prevents mobile scrolling */
        }

        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
        }

        /* --- Crosshair --- */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 24px; height: 24px; 
            transform: translate(-50%, -50%); 
            transition: all 0.1s;
            opacity: 0.9;
        }
        .ch-line { position: absolute; background: white; box-shadow: 0 0 4px black; border-radius: 2px; }
        .ch-h { width: 100%; height: 2px; top: 50%; left: 0; margin-top: -1px; }
        .ch-v { height: 100%; width: 2px; left: 50%; top: 0; margin-left: -1px; }

        /* Scope */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 20%, black 22%);
            display: none; pointer-events: none; z-index: 100; 
        }
        #scope-lines {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; height: 100%; display: none;
        }
        #scope-lines::after { content:''; position: absolute; width: 1px; height: 100%; background: rgba(0,0,0,0.5); left: 50%; }
        #scope-lines::before { content:''; position: absolute; width: 100%; height: 1px; background: rgba(0,0,0,0.5); top: 50%; }

        /* --- HUD Top --- */
        #top-hud { 
            position: absolute; top: 20px; width: 100%; 
            display: flex; justify-content: space-between; 
            padding: 0 30px; box-sizing: border-box; 
            align-items: flex-start;
        }

        .hud-box {
            background: rgba(20, 20, 35, 0.6);
            backdrop-filter: blur(10px);
            color: white; 
            padding: 8px 16px;
            border-left: 4px solid #00d2ff;
            border-radius: 4px;
            font-size: 22px;
            font-weight: 700;
            text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            text-shadow: 1px 1px 0 #000;
        }

        /* Minimap */
        #minimap-frame {
            width: 160px; height: 160px;
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.8);
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #minimap { 
            width: 500px; height: 500px; position: absolute; 
            transition: transform 0.1s linear;
        }
        .map-dot { 
            position: absolute; width: 12px; height: 12px; 
            border-radius: 50%; border: 2px solid white; 
            transform: translate(-50%, -50%);
            z-index: 10; 
        }
        .map-player { background: #00e5ff; box-shadow: 0 0 10px #00e5ff; }
        .map-bot { background: #ff3333; }
        .map-arrow {
            position: absolute; top: 50%; left: 50%;
            width: 0; height: 0; 
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 12px solid #00e5ff;
            transform: translate(-50%, -50%);
            z-index: 20;
        }

        /* --- Player Stats (Bottom Left) --- */
        #status-area { 
            position: absolute; bottom: 30px; left: 30px; 
            width: 320px; display: flex; flex-direction: column; gap: 8px;
        }
        .stat-row { display: flex; align-items: center; gap: 10px; }
        .bar-wrap {
            flex-grow: 1; height: 20px; background: rgba(0,0,0,0.5);
            border-radius: 4px; overflow: hidden; position: relative;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .bar-fill { height: 100%; transition: width 0.2s; }
        #shield-bar { background: linear-gradient(90deg, #00c6ff, #0072ff); }
        #health-bar { background: linear-gradient(90deg, #11998e, #38ef7d); }
        .stat-icon { font-size: 24px; width: 30px; text-align: center; }
        .stat-val { position: absolute; right: 5px; top: 0; font-size: 14px; line-height: 20px; font-weight: bold; color: white; text-shadow: 1px 1px 2px black;}

        /* --- Interaction Prompt --- */
        #interact-msg { 
            position: absolute; top: 60%; left: 50%; 
            transform: translate(-50%, -50%); 
            background: rgba(255, 215, 0, 0.9); 
            color: black; 
            padding: 10px 20px; 
            border-radius: 30px; 
            font-size: 18px; 
            font-weight: 800; 
            display: none;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            pointer-events: none;
        }

        /* --- Inventory --- */
        #inventory { 
            position: absolute; bottom: 30px; right: 30px; 
            display: flex; gap: 8px; 
        }
        .slot { 
            width: 70px; height: 70px; 
            background: rgba(30, 30, 40, 0.85); 
            border: 1px solid rgba(255,255,255,0.2); 
            border-radius: 8px;
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            color: white; position: relative; 
            transition: transform 0.1s, border-color 0.1s; 
            pointer-events: auto; /* Touchable */
        }
        .slot.active { 
            border: 2px solid #ffe600; 
            transform: scale(1.1) translateY(-10px); 
            background: rgba(50, 50, 60, 0.95);
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            z-index: 5;
        }
        .slot-key { 
            position: absolute; top: 2px; left: 5px; 
            font-size: 12px; color: #888; 
        }
        .slot-icon { font-size: 28px; margin-bottom: 2px; }
        .slot-ammo { font-size: 12px; font-weight: bold; color: #ddd; }
        
        /* Rarity Colors */
        .rarity-common { border-bottom: 4px solid #b0b0b0; }
        .rarity-uncommon { border-bottom: 4px solid #28a745; }
        .rarity-rare { border-bottom: 4px solid #007bff; }
        .rarity-epic { border-bottom: 4px solid #a335ee; }
        .rarity-legendary { border-bottom: 4px solid #ffd700; box-shadow: inset 0 0 10px rgba(255,215,0,0.2); }

        /* Damage Text */
        .dmg-txt {
            position: absolute; color: white; font-weight: 900; font-size: 24px;
            text-shadow: 2px 2px 0 black; pointer-events: none;
            animation: popUp 1s forwards;
        }
        @keyframes popUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-50px) scale(1.2); } }

        /* --- MOBILE CONTROLS --- */
        #mobile-controls {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }
        .joystick-zone {
            position: absolute; bottom: 50px; width: 160px; height: 160px;
            background: rgba(255,255,255,0.05); border-radius: 50%;
            border: 2px dashed rgba(255,255,255,0.2);
            pointer-events: auto;
        }
        #stick-left { left: 40px; }
        #stick-right { right: 40px; }
        
        .stick-thumb {
            position: absolute; top: 50%; left: 50%; width: 60px; height: 60px;
            background: rgba(255,255,255,0.2); border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .action-btn {
            position: absolute; width: 70px; height: 70px;
            border-radius: 50%; background: rgba(20, 20, 20, 0.6);
            border: 2px solid rgba(255,255,255,0.5);
            color: white; font-weight: bold; font-size: 14px;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; backdrop-filter: blur(4px);
            text-align: center;
        }
        .action-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }

        #btn-fire { bottom: 120px; right: 40px; width: 90px; height: 90px; border-color: #ff4444; background: rgba(255,0,0,0.2); font-size: 18px; }
        #btn-jump { bottom: 220px; right: 50px; }
        #btn-interact { bottom: 160px; right: 140px; border-color: #ffd700; color: #ffd700; }
        #btn-build { bottom: 240px; right: 140px; border-color: #8B4513; }
        #btn-ads { bottom: 80px; right: 160px; width: 60px; height: 60px; font-size: 12px; }

        #storm-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(138, 43, 226, 0.2); box-shadow: inset 0 0 100px 50px rgba(75, 0, 130, 0.5);
            display: none; pointer-events: none; mix-blend-mode: overlay;
        }

        #game-over {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 999; pointer-events: auto;
        }
        #game-over h1 { font-size: 80px; margin: 0; color: gold; text-shadow: 0 0 30px orange; font-style: italic; }
        button.restart-btn { margin-top: 20px; padding: 15px 40px; font-size: 24px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: 'Rajdhani'; font-weight: bold; }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="crosshair">
            <div class="ch-line ch-h"></div>
            <div class="ch-line ch-v"></div>
        </div>
        
        <div id="scope-overlay"><div id="scope-lines"></div></div>
        <div id="storm-overlay"></div>

        <div id="top-hud">
            <div id="minimap-frame">
                <div id="minimap">
                    <div class="map-arrow"></div>
                </div>
            </div>
            <div class="hud-box">Alive: <span id="alive-count">21</span></div>
            <div class="hud-box" style="border-color: #a335ee;">Storm: <span id="storm-timer">02:00</span></div>
        </div>

        <div id="interact-msg">Interact</div>

        <div id="status-area">
            <div class="stat-row">
                <div class="stat-icon">üõ°Ô∏è</div>
                <div class="bar-wrap"><div id="shield-bar" class="bar-fill" style="width: 50%;"></div><div class="stat-val" id="shield-val">50</div></div>
            </div>
            <div class="stat-row">
                <div class="stat-icon">‚ù§Ô∏è</div>
                <div class="bar-wrap"><div id="health-bar" class="bar-fill" style="width: 100%;"></div><div class="stat-val" id="health-val">100</div></div>
            </div>
            <div class="stat-row" style="margin-top: 5px;">
                <div class="stat-icon">ü™µ</div>
                <span id="wood-val" style="color: #deb887; font-weight: bold; font-size: 20px;">0</span>
            </div>
        </div>

        <div id="inventory">
            <div class="slot" id="slot-0" onclick="selectSlot(0)"></div>
            <div class="slot" id="slot-1" onclick="selectSlot(1)"></div>
            <div class="slot" id="slot-2" onclick="selectSlot(2)"></div>
            <div class="slot" id="slot-3" onclick="selectSlot(3)"></div>
            <div class="slot" id="slot-4" onclick="selectSlot(4)"></div>
        </div>

        <div id="mobile-controls">
            <div id="stick-left" class="joystick-zone"><div class="stick-thumb" id="thumb-left"></div></div>
            <div id="stick-right" class="joystick-zone"><div class="stick-thumb" id="thumb-right"></div></div>
            
            <div id="btn-fire" class="action-btn">FIRE</div>
            <div id="btn-jump" class="action-btn">JUMP</div>
            <div id="btn-interact" class="action-btn">PICKUP</div>
            <div id="btn-build" class="action-btn">BUILD</div>
            <div id="btn-ads" class="action-btn">AIM</div>
        </div>
    </div>

    <div id="game-over">
        <h1 id="go-title">VICTORY ROYALE!</h1>
        <h3 id="go-stats">Eliminations: 0</h3>
        <button class="restart-btn" onclick="location.reload()">RETURN TO LOBBY</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONSTANTS ---
        const WORLD_SIZE = 600;
        const BOT_COUNT = 20; 
        const GRAVITY = 40.0;
        const WALK_SPEED = 10; // <<-- MISSING DEFINITION ADDED
        const SPRINT_SPEED = 20; // <<-- MISSING DEFINITION ADDED
        const JUMP_FORCE = 15;
        const PLAYER_HEIGHT = 1.8;
        
        // --- WEAPONS DATA (V7.0 Updates) ---
        const RARITY = {
            COMMON: { color: '#b0b0b0', mul: 1.0 },
            UNCOMMON: { color: '#28a745', mul: 1.2 },
            RARE: { color: '#007bff', mul: 1.4 },
            EPIC: { color: '#a335ee', mul: 1.6 },
            LEGENDARY: { color: '#ffd700', mul: 2.0 }
        };

        const WEAPONS = {
            RASG: { name: "Rapid Auto Shotgun", dmg: 18, head: 31, rate: 0.4, mag: 10, range: 40, spread: 0.15, pellets: 2, auto: true, icon: 'üî•', reload: 2500, recoil: 1.5 }, // More Recoil and 0.4s CD
            AR:   { name: "Assault Rifle",      dmg: 16, head: 24, rate: 0.33,mag: 30, range: 200,spread: 0.02, pellets: 1, auto: true, icon: 'üî´', reload: 2000, recoil: 0.5 }, // 0.33s rate (3 BPS)
            SMG:  { name: "Submachine Gun",     dmg: 9,  head: 14, rate: 0.1, mag: 35, range: 80, spread: 0.06, pellets: 1, auto: true, icon: 'üñäÔ∏è', reload: 1800, recoil: 0.1 },
            SNIPER:{name: "Eagle Eye Sniper",   dmg: 110,head: 250,rate: 1.5, mag: 1,  range: 600,spread: 0.001,pellets:1, auto: false,icon:'üî≠', reload: 3000, recoil: 3.0 },
            RL:   { name: "Rocket Launcher",    dmg: 100,head: 100,rate: 2.0, mag: 1,  range: 300,spread: 0.01, pellets: 1, auto: false,icon:'üöÄ', reload: 4000, blast: 8, recoil: 0 }
        };

        const CONSUMABLES = {
            MINI: { name: "Mini Shield", val: 25, type: 'shield', max: 50, icon: 'üõ°Ô∏è', time: 2000 },
            BIG:  { name: "Big Shield", val: 50, type: 'shield', max: 100, icon: '‚öóÔ∏è', time: 4000 },
            MED:  { name: "Medkit", val: 100, type: 'health', max: 100, icon: 'üíä', time: 8000 }
        };

        // --- GLOBALS ---
        let scene, camera, renderer, controls;
        let weaponScene, weaponCamera, viewModel;
        let raycaster, downRay;
        
        // State
        let player = { 
            health: 100, shield: 50, wood: 0, 
            inventory: [null, null, null, null, null], slot: 0, 
            dead: false, ads: false, vehicle: null 
        };
        
        let inputs = { w: false, a: false, s: false, d: false, jump: false, sprint: false, fire: false };
        let velocity = new THREE.Vector3();
        let isGrounded = false;
        let lastTime = performance.now();
        let lastShot = 0;
        let isMobile = false;
        
        // Joystick State
        let leftStick = { active: false, x: 0, y: 0, originX: 0, originY: 0, id: null };
        let rightStick = { active: false, x: 0, y: 0, originX: 0, originY: 0, id: null };

        // Entities
        let bots = [];
        let objects = []; // Collidables (Ground + Buildings)
        let chests = [];
        let cars = [];
        let loot = [];
        let buildings = []; // Track interactables like doors

        // Storm
        let stormRadius = WORLD_SIZE;
        let stormTime = 0;

        // Initialization
        init();
        animate();

        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            // Weapon Layer
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.autoClear = false;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // 2. Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(100, 200, 100);
            sun.castShadow = true;
            sun.shadow.camera.right = 200; sun.shadow.camera.left = -200;
            sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            scene.add(sun);
            weaponScene.add(ambient.clone());
            weaponScene.add(sun.clone());

            // 3. Inputs
            controls = new PointerLockControls(camera, document.body);
            setupInputs();

            // 4. World Generation
            raycaster = new THREE.Raycaster();
            downRay = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);
            
            generateTerrain();
            generatePOIs();
            spawnBots();
            spawnCars();

            // Starter Loot
            giveItem(createWeaponItem('AR', 'COMMON'), 0);
            player.wood = 50; // Give starter wood
            updateUI();

            // Mobile Check
            if('ontouchstart' in window) {
                isMobile = true;
                document.getElementById('mobile-controls').style.display = 'block';
                document.getElementById('inventory').style.top = '20px';
                document.getElementById('inventory').style.bottom = 'auto';
            }

            updateUI();
        }

        // --- PHYSICS & TERRAIN ---
        function getTerrainHeight(x, z) {
            // Complex terrain function
            const scale1 = 0.02;
            const scale2 = 0.05;
            let y = (Math.sin(x * scale1) * 10 + Math.cos(z * scale1) * 10) + 
                    (Math.sin(x * scale2 + z * scale2) * 5);
            
            // Flatten map edges
            const dist = Math.sqrt(x*x + z*z);
            if (dist > 250) y += (dist - 250) * 0.2;
            
            return y;
        }

        function generateTerrain() {
            const geo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 128, 128);
            geo.rotateX(-Math.PI/2);
            
            const pos = geo.attributes.position;
            const colors = [];
            for(let i=0; i<pos.count; i++){
                const x = pos.getX(i);
                const z = pos.getZ(i);
                const y = getTerrainHeight(x, z);
                pos.setY(i, y);
                
                if(y > 15) colors.push(0.8, 0.8, 0.8); // Snow
                else colors.push(0.1, 0.6, 0.1); // Grass
            }
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh); // Ground is collidable (Solid!)
        }

        // --- POIS & BUILDINGS (Solid) ---
        function createBox(x, y, z, w, h, d, col, type='solid') {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: col}));
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh); // Solid!
            buildings.push({ mesh: mesh, type: type });
            return mesh;
        }

        function generatePOIs() {
            // Tilted Towers (Center)
            createTower(0, 0);
            createTower(40, 20);
            createTower(-30, -40);

            // Pleasant Park (Houses)
            createHouse(150, 150);
            createHouse(180, 150);
            createHouse(150, 180);

            // Forest
            for(let i=0; i<50; i++) {
                const x = (Math.random()-0.5)*400;
                const z = (Math.random()-0.5)*400;
                if(Math.abs(x)<50 && Math.abs(z)<50) continue; // Not in tilted
                createTree(x, z);
            }
        }

        function createTower(x, z) {
            const h = getTerrainHeight(x, z);
            const floors = 4;
            const size = 15;
            
            for(let f=0; f<floors; f++) {
                const fy = h + 0.2 + (f*4);
                // Floor
                createBox(x, fy, z, size, 0.4, size, 0x333333);
                // Walls
                createBox(x - size/2, fy + 2, z, 1, 4, size, 0x666666);
                createBox(x + size/2, fy + 2, z, 1, 4, size, 0x666666);
                createBox(x, fy + 2, z - size/2, size, 4, 1, 0x666666);
                // Front wall with gap
                createBox(x - 4, fy + 2, z + size/2, (size/2)-2, 4, 1, 0x666666);
                createBox(x + 4, fy + 2, z + size/2, (size/2)-2, 4, 1, 0x666666);
                
                // Spawn Chest
                if(Math.random() > 0.5) spawnChest(x + 5, fy + 1, z - 5);
            }
        }

        function createHouse(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+2, z, 10, 4, 10, 0xdddddd);
            const roof = new THREE.Mesh(new THREE.ConeGeometry(8, 4, 4), new THREE.MeshStandardMaterial({color: 0x8B4513}));
            roof.position.set(x, h+6, z);
            roof.rotation.y = Math.PI/4;
            scene.add(roof);
            // Roof mesh is not collidable (objects.push(roof) is omitted)
            spawnChest(x, h+1, z);
        }

        function createTree(x, z) {
            const h = getTerrainHeight(x, z);
            const trunk = createBox(x, h+2, z, 1, 4, 1, 0x8B4513);
            const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(3), new THREE.MeshStandardMaterial({color: 0x228B22}));
            leaves.position.set(x, h+5, z);
            scene.add(leaves);
            // Leaves are not collidable for simplicity
        }

        // --- ENTITIES: CARS & CHESTS ---
        function spawnCars() {
            for(let i=0; i<5; i++) {
                const x = (Math.random()-0.5)*200;
                const z = (Math.random()-0.5)*200;
                const h = getTerrainHeight(x, z);
                
                const carGroup = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 5), new THREE.MeshStandardMaterial({color: 0x0044ff}));
                body.position.y = 1;
                carGroup.add(body);
                
                carGroup.position.set(x, h, z); // Anchored to the ground
                scene.add(carGroup);
                
                cars.push({ mesh: carGroup, speed: 0, ry: 0 });
            }
        }

        function spawnChest(x, y, z) {
            const chest = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1), new THREE.MeshStandardMaterial({color: 0xFFD700}));
            chest.position.set(x, y, z);
            scene.add(chest);
            chests.push(chest);
        }

        // --- NPCS (V7: Realistic & Smart) ---
        function spawnBots() {
            const skinMat = new THREE.MeshStandardMaterial({color: 0xffaa88});
            
            for(let i=0; i<BOT_COUNT; i++) {
                const x = (Math.random()-0.5)*300;
                const z = (Math.random()-0.5)*300;
                const h = getTerrainHeight(x, z);

                // --- Realistic NPC Visuals (Composite Mesh) ---
                const group = new THREE.Group();
                const torsoMat = new THREE.MeshStandardMaterial({color: Math.random() * 0xffffff}); // Different color shirts
                
                // Head (more sphere-like for "realism")
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), skinMat); head.position.set(0, 1.8, 0);
                // Body
                const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 1.0, 8), torsoMat); torso.position.set(0, 1.1, 0);
                // Legs (simplified)
                const legs = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.4), new THREE.MeshStandardMaterial({color: 0x222244})); legs.position.set(0, 0.3, 0);
                
                group.add(head, torso, legs);
                group.position.set(x, h, z);
                scene.add(group);

                // Give random weapon up to legendary
                const wKeys = Object.keys(WEAPONS);
                const randW = WEAPONS[wKeys[Math.floor(Math.random() * wKeys.length)]];
                
                const rarKeys = Object.keys(RARITY);
                const randomRarity = RARITY[rarKeys[Math.floor(Math.random() * rarKeys.length)]];
                
                bots.push({
                    mesh: group,
                    health: 150,
                    weapon: createWeaponItem(wKeys[Math.floor(Math.random()*wKeys.length)], rarKeys[Math.floor(Math.random()*rarKeys.length)]),
                    state: 'idle',
                    target: null,
                    lastShot: 0,
                    nextMove: 0
                });
            }
        }

        // --- INPUT & CONTROLS ---
        function setupInputs() {
            const onKey = (e, v) => {
                if(e.code === 'KeyW') inputs.w = v;
                if(e.code === 'KeyS') inputs.s = v;
                if(e.code === 'KeyA') inputs.a = v;
                if(e.code === 'KeyD') inputs.d = v;
                if(e.code === 'Space') inputs.jump = v;
                if(e.code === 'ShiftLeft') inputs.sprint = v;
            };
            document.addEventListener('keydown', e => {
                onKey(e, true);
                if(e.code === 'Digit1') switchSlot(0);
                if(e.code === 'Digit2') switchSlot(1);
                if(e.code === 'Digit3') switchSlot(2);
                if(e.code === 'Digit4') switchSlot(3);
                if(e.code === 'Digit5') switchSlot(4);
                if(e.code === 'KeyE') tryInteract(); // PC interact
                if(e.code === 'KeyB') buildWall(); // PC build
            });
            document.addEventListener('keyup', e => onKey(e, false));
            
            document.addEventListener('mousedown', e => {
                if(player.dead) return;
                if(!isMobile && !document.pointerLockElement) controls.lock();
                if(e.button === 0) inputs.fire = true;
                if(e.button === 2) toggleADS(true);
            });
            document.addEventListener('mouseup', e => {
                if(e.button === 0) inputs.fire = false;
                if(e.button === 2) toggleADS(false);
            });

            // Mobile Touch Logic
            const touchZoneLeft = document.getElementById('stick-left');
            const touchZoneRight = document.getElementById('stick-right');
            const thumbLeft = document.getElementById('thumb-left');
            const thumbRight = document.getElementById('thumb-right');

            const handleJoystick = (e, stick, thumb, isLeft) => {
                const rect = e.target.getBoundingClientRect();
                const touch = e.targetTouches[0];
                const cx = rect.left + rect.width/2;
                const cy = rect.top + rect.height/2;
                
                const maxDist = 40;
                let dx = touch.clientX - cx;
                let dy = touch.clientY - cy;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio; dy *= ratio;
                }
                
                // Update thumb visual position
                thumb.style.transform = `translate(${dx}px, ${dy}px)`;
                
                if(isLeft) {
                    // Movement
                    inputs.w = dy < -10; inputs.s = dy > 10;
                    inputs.a = dx < -10; inputs.d = dx > 10;
                } else {
                    // Camera Look (Apply directly to camera rotation for PointerLock style)
                    // Note: This overrides PointerLockControls' internal rotation tracking for mobile
                    camera.rotation.y -= dx * 0.002;
                    camera.rotation.x -= dy * 0.002;
                    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                }
            };

            const resetStick = (thumb, isLeft) => {
                thumb.style.transform = `translate(-50%, -50%)`; // CSS center
                if(isLeft) { inputs.w=false; inputs.s=false; inputs.a=false; inputs.d=false; }
            };

            touchZoneLeft.addEventListener('touchmove', e => handleJoystick(e, leftStick, thumbLeft, true));
            touchZoneLeft.addEventListener('touchend', () => resetStick(thumbLeft, true));
            
            touchZoneRight.addEventListener('touchmove', e => handleJoystick(e, rightStick, thumbRight, false));
            touchZoneRight.addEventListener('touchend', () => resetStick(thumbRight, false));

            // Mobile Buttons (Interact and Build)
            document.getElementById('btn-fire').addEventListener('touchstart', (e) => { e.preventDefault(); inputs.fire = true; });
            document.getElementById('btn-fire').addEventListener('touchend', (e) => { e.preventDefault(); inputs.fire = false; });
            document.getElementById('btn-jump').addEventListener('touchstart', (e) => { e.preventDefault(); inputs.jump = true; });
            document.getElementById('btn-jump').addEventListener('touchend', (e) => { e.preventDefault(); inputs.jump = false; });
            document.getElementById('btn-interact').addEventListener('touchstart', (e) => { e.preventDefault(); tryInteract(); });
            document.getElementById('btn-build').addEventListener('touchstart', (e) => { e.preventDefault(); buildWall(); });
            document.getElementById('btn-ads').addEventListener('touchstart', (e) => { e.preventDefault(); toggleADS(!player.ads); });
        }

        // --- GAMEPLAY LOGIC ---
        
        function tryInteract() {
            // Check chests
            const pos = camera.position;
            for(let i=chests.length-1; i>=0; i--) {
                if(pos.distanceTo(chests[i].position) < 4) {
                    // Chests don't open was a bug fix request, so we are now handling the open logic.
                    // The visual bug was that the box was floating and the item didn't spawn.
                    scene.remove(chests[i]);
                    chests.splice(i, 1);
                    // Drop loot
                    spawnLoot(pos.x+1, pos.y, pos.z, 'weapon');
                    spawnLoot(pos.x-1, pos.y, pos.z, 'consumable');
                    return;
                }
            }
            
            // Check Cars
            for(let c of cars) {
                if(pos.distanceTo(c.mesh.position) < 5) {
                    if(player.vehicle) {
                        player.vehicle = null;
                        camera.position.y += 2;
                    } else {
                        player.vehicle = c;
                    }
                    return;
                }
            }

            // Check Loot (NPC cannot pick up items is ensured by only allowing player interaction here)
            for(let i=loot.length-1; i>=0; i--) {
                if(pos.distanceTo(loot[i].mesh.position) < 3) {
                    if(giveItem(loot[i].data)) {
                        scene.remove(loot[i].mesh);
                        loot.splice(i, 1);
                        return;
                    }
                }
            }
        }

        function buildWall() {
            if(player.wood < 10) return;
            player.wood -= 10;
            updateUI();
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const pos = camera.position.clone().add(dir.multiplyScalar(3));
            
            // Wall should spawn on the terrain
            const h = getTerrainHeight(pos.x, pos.z);
            
            // Use camera's horizontal rotation to orient the wall
            const wall = createBox(pos.x, h + 1.5, pos.z, 4, 3, 0.2, 0x8B4513, 'wall');
            // Simplified orientation based on player view
            wall.rotation.y = controls.getObject().rotation.y; 
        }

        function createWeaponItem(typeKey, rarityKey) {
            const base = WEAPONS[typeKey];
            const rar = RARITY[rarityKey];
            return {
                category: 'weapon',
                name: base.name,
                rarity: rar,
                stats: { ...base, dmg: base.dmg * rar.mul },
                ammo: base.mag,
                maxAmmo: base.mag
            };
        }

        function giveItem(item, slot = -1) {
            // Handle Wood (materials)
            if(item.category === 'mat') {
                player.wood += item.count;
                return true;
            }
            
            // Handle Inventory items
            if(slot === -1) {
                slot = player.inventory.findIndex(i => i === null);
                if(slot === -1) return false; // Full
            }
            
            player.inventory[slot] = item;
            updateUI();
            if(slot === player.slot) switchSlot(slot);
            return true;
        }

        function spawnLoot(x, y, z, type) {
            const isWeapon = type === 'weapon';
            const keys = Object.keys(isWeapon ? WEAPONS : CONSUMABLES);
            const key = keys[Math.floor(Math.random()*keys.length)];
            const rarKeys = Object.keys(RARITY);
            const rar = rarKeys[Math.floor(Math.random()*rarKeys.length)];
            
            const item = isWeapon ? createWeaponItem(key, rarKeys[Math.floor(Math.random()*rarKeys.length)]) : { category: 'consumable', ...CONSUMABLES[key], count: 1 };
            
            // Visual
            const geo = isWeapon ? new THREE.BoxGeometry(0.5, 0.1, 0.2) : new THREE.SphereGeometry(0.2);
            const mat = new THREE.MeshBasicMaterial({ color: isWeapon ? item.rarity.color : 0x00ff00 });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Anchored to the ground height
            const h = getTerrainHeight(x, z);
            mesh.position.set(x, h+0.5, z);
            scene.add(mesh);
            
            // Text Sprite (Simple color glow)
            const light = new THREE.PointLight(isWeapon ? item.rarity.color : 0x00ff00, 1, 3);
            light.position.set(0, 0.2, 0);
            mesh.add(light);

            loot.push({ mesh: mesh, data: item });
        }

        function switchSlot(idx) {
            player.slot = idx;
            // Update Visuals
            document.querySelectorAll('.slot').forEach((el, i) => {
                el.classList.toggle('active', i === idx);
            });
            
            // Update Viewmodel
            if(viewModel) weaponScene.remove(viewModel);
            const item = player.inventory[idx];
            
            if(item && item.category === 'weapon') {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
                const mat = new THREE.MeshStandardMaterial({ color: item.rarity.color });
                viewModel = new THREE.Mesh(geo, mat);
                viewModel.position.set(0.2, -0.2, -0.5);
                weaponScene.add(viewModel);
                
                // Set Crosshair
                const ch = document.getElementById('crosshair');
                ch.style.display = item.stats.icon === 'üî≠' ? 'none' : 'block';
            } else {
                document.getElementById('crosshair').style.display = 'block';
            }
            toggleADS(false);
        }

        function toggleADS(bool) {
            player.ads = bool;
            const item = player.inventory[player.slot];
            const isSniper = item && item.stats && item.stats.icon === 'üî≠';
            
            if(bool) {
                if(isSniper) {
                    camera.fov = 10;
                    document.getElementById('scope-overlay').style.display = 'block';
                    document.getElementById('scope-lines').style.display = 'block';
                } else {
                    camera.fov = 50;
                    if(viewModel) viewModel.position.set(0, -0.16, -0.4);
                }
            } else {
                camera.fov = 75;
                document.getElementById('scope-overlay').style.display = 'none';
                document.getElementById('scope-lines').style.display = 'none';
                if(viewModel) viewModel.position.set(0.2, -0.2, -0.5);
            }
            camera.updateProjectionMatrix();
        }

        // --- UPDATE LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            if(player.dead) return;

            // 1. Physics & Movement (V7.0: Gravity Fix)
            if(player.vehicle) {
                // Car Physics
                const car = player.vehicle;
                const speed = inputs.w ? 20 : (inputs.s ? -10 : 0);
                car.mesh.translateZ(speed * dt);
                if(inputs.a) car.mesh.rotation.y += 2 * dt;
                if(inputs.d) car.mesh.rotation.y -= 2 * dt;
                
                // Stick car to ground
                const cy = getTerrainHeight(car.mesh.position.x, car.mesh.position.z);
                car.mesh.position.y = cy + 0.5;

                // Move camera to car position
                camera.position.copy(car.mesh.position).add(new THREE.Vector3(0, 3, -6).applyEuler(car.mesh.rotation));
                camera.lookAt(car.mesh.position);
            } else {
                // Player Physics
                velocity.x = 0; velocity.z = 0;
                
                const speed = inputs.sprint ? SPRINT_SPEED : WALK_SPEED; // <-- **FIXED: WALK_SPEED/SPRINT_SPEED used**
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
                const right = new THREE.Vector3(-dir.z, 0, dir.x);

                if(inputs.w) velocity.add(dir.multiplyScalar(speed));
                if(inputs.s) velocity.add(dir.multiplyScalar(-speed));
                if(inputs.a) velocity.add(right.multiplyScalar(-speed));
                if(inputs.d) velocity.add(right.multiplyScalar(speed));

                controls.moveRight(velocity.x * dt);
                controls.moveForward(velocity.z * dt);

                // Gravity Application
                velocity.y -= GRAVITY * dt;
                
                // Ground Check
                const groundY = getTerrainHeight(camera.position.x, camera.position.z);
                
                // Structure Collision Check (Simplified)
                downRay.ray.origin.copy(camera.position);
                const hits = downRay.intersectObjects(objects, false);
                let floorY = groundY;
                
                if(hits.length > 0) {
                    // Check for solid floors immediately below the player
                    const closestHit = hits[0];
                    if (closestHit.point.y > groundY + 0.5) { // If we hit a building floor, not just the ground
                        floorY = closestHit.point.y;
                    }
                }

                if (camera.position.y <= floorY + PLAYER_HEIGHT && velocity.y <= 0) {
                    camera.position.y = floorY + PLAYER_HEIGHT;
                    velocity.y = 0;
                    isGrounded = true;
                } else {
                    isGrounded = false;
                }
                
                if(inputs.jump && isGrounded) {
                    velocity.y = JUMP_FORCE;
                    isGrounded = false;
                }
                
                camera.position.y += velocity.y * dt;
            }

            // 2. Shooting
            if(inputs.fire && !player.vehicle) {
                const item = player.inventory[player.slot];
                if(item && item.category === 'weapon') {
                    if(now - lastShot > item.stats.rate * 1000) {
                        lastShot = now;
                        shoot(item);
                        item.ammo -= 1;
                        if(item.ammo < 0) item.ammo = 0;
                        updateUI();
                    }
                } else if (item && item.category === 'consumable') {
                    // Quick use logic (simplified)
                    if(item.type === 'shield' && player.shield < item.max) {
                        player.shield = Math.min(item.max, player.shield + item.val);
                        player.inventory[player.slot] = null;
                        updateUI();
                    } else if (item.type === 'health' && player.health < item.max) {
                        player.health = Math.min(item.max, player.health + item.val);
                        player.inventory[player.slot] = null;
                        updateUI();
                    }
                }
            }

            // 3. AI Update
            updateBots(dt, now);

            // 4. Render
            renderer.clear();
            renderer.render(scene, camera);
            renderer.clearDepth();
            renderer.render(weaponScene, weaponCamera);
            
            // Minimap Update
            updateMinimap();
        }

        function shoot(item) {
            // Apply Recoil: Push camera up, will be corrected by controls/gravity
            camera.rotation.x += item.stats.recoil * 0.01;
            
            // Raycast
            const spread = player.ads ? 0.005 : item.stats.spread;
            
            for(let p = 0; p < item.stats.pellets; p++) {
                const rx = (Math.random()-0.5)*spread;
                const ry = (Math.random()-0.5)*spread;
                
                raycaster.setFromCamera(new THREE.Vector2(rx, ry), camera);
                
                // Check Bot Hits
                const botMeshes = bots.map(b => b.mesh);
                const hits = raycaster.intersectObjects(botMeshes, true);
                
                if(hits.length > 0) {
                    // Find which bot
                    let hitBot = null;
                    let obj = hits[0].object;
                    while(obj && obj.parent && obj.parent.type !== 'Scene') {
                        const b = bots.find(bot => bot.mesh === obj.parent);
                        if(b) { hitBot = b; break; }
                        obj = obj.parent;
                    }
                    
                    if(!hitBot) hitBot = bots.find(bot => bot.mesh === hits[0].object);

                    if(hitBot) {
                        let dmg = item.stats.dmg;
                        // Headshot Check (simplified: if hit on upper half of body)
                        if (hits[0].point.y > hitBot.mesh.position.y + 1.5) { 
                            dmg = item.stats.head; 
                        }
                        
                        hitBot.health -= dmg;
                        showDmg(dmg, hits[0].point);
                        if(hitBot.health <= 0) {
                            scene.remove(hitBot.mesh);
                            bots = bots.filter(b => b !== hitBot);
                            // NPC always drops their equipped item
                            spawnLoot(hits[0].point.x, hits[0].point.y, hits[0].point.z, 'weapon', hitBot.weapon); 
                            checkWin();
                        }
                    }
                }
            }
        }

        function updateBots(dt, now) {
            const pPos = camera.position;
            bots.forEach(bot => {
                const dist = bot.mesh.position.distanceTo(pPos);
                // Gravity check: ensure NPC is on the terrain/floor
                const h = getTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                bot.mesh.position.y = h; 

                // Simple AI: Look at player if close
                if(dist < 50) {
                    bot.mesh.lookAt(pPos.x, pPos.y, pPos.z);
                    // Movement: Walk towards player
                    if(dist > 10 && now > bot.nextMove) {
                        const moveSpeed = WALK_SPEED * dt * 0.5;
                        bot.mesh.translateZ(moveSpeed);
                        bot.nextMove = now + 100; // Move every 100ms
                    }
                    
                    // Shoot
                    if(now - bot.lastShot > bot.weapon.stats.stats.rate * 2000) { // Bots shoot slower (2x rate time)
                        bot.lastShot = now;
                        if(Math.random() > 0.6) { // 40% accuracy
                            // Simplified hitscan on player
                            let dmg = bot.weapon.stats.stats.dmg;
                            if(player.shield > 0) {
                                player.shield -= dmg;
                                if(player.shield < 0) { player.health += player.shield; player.shield = 0; }
                            } else {
                                player.health -= dmg;
                            }
                            updateUI();
                            if(player.health <= 0) {
                                player.dead = true;
                                document.getElementById('game-over').style.display = 'flex';
                                document.getElementById('go-title').innerText = "ELIMINATED";
                                document.getElementById('go-title').style.color = "red";
                                document.exitPointerLock();
                            }
                        }
                    }
                }
            });
            document.getElementById('alive-count').innerText = bots.length + 1;
        }

        function showDmg(amount, pos) {
            const div = document.createElement('div');
            div.className = 'dmg-txt';
            div.innerText = Math.floor(amount);
            
            // Project 3D to 2D
            const v = pos.clone().project(camera);
            const x = (v.x * .5 + .5) * window.innerWidth;
            const y = (-(v.y * .5) + .5) * window.innerHeight;
            
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        function updateUI() {
            // Stats
            player.health = Math.max(0, player.health);
            player.shield = Math.max(0, player.shield);
            document.getElementById('health-val').innerText = Math.ceil(player.health);
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('shield-val').innerText = Math.ceil(player.shield);
            document.getElementById('shield-bar').style.width = player.shield + '%';
            document.getElementById('wood-val').innerText = player.wood;
            
            // Inventory Slots
            player.inventory.forEach((item, i) => {
                const el = document.getElementById('slot-'+i);
                el.innerHTML = `<div class="slot-key">${i+1}</div>`;
                if(item) {
                    const icon = item.category === 'weapon' ? item.stats.icon : item.icon;
                    const ammo = item.category === 'weapon' ? item.ammo : item.count;
                    const rarityKey = item.rarity ? Object.keys(RARITY).find(key => RARITY[key] === item.rarity).toLowerCase() : 'common';

                    el.innerHTML += `<div class="slot-icon">${icon}</div><div class="slot-ammo">${ammo}</div>`;
                    el.className = `slot ${i===player.slot ? 'active' : ''} rarity-${rarityKey}`;
                } else {
                    el.className = `slot ${i===player.slot ? 'active' : ''}`;
                }
            });
            
            // Interact Msg
            let hitMsg = false;
            let msg = "";
            const pos = camera.position;
            
            if(player.vehicle) {
                msg = "Exit Vehicle";
                hitMsg = true;
            } else {
                for(let c of chests) {
                    if(pos.distanceTo(c.position) < 6) { msg = "Open Chest"; hitMsg = true; break; }
                }
                if(!hitMsg) {
                    for(let l of loot) {
                        if(pos.distanceTo(l.mesh.position) < 4) { msg = `Pickup ${l.data.name}`; hitMsg = true; break; }
                    }
                }
                if(!hitMsg) {
                    for(let c of cars) {
                        if(pos.distanceTo(c.mesh.position) < 6) { msg = "Enter Car"; hitMsg = true; break; }
                    }
                }
            }

            document.getElementById('interact-msg').innerText = msg;
            document.getElementById('interact-msg').style.display = hitMsg ? 'block' : 'none';
        }

        function updateMinimap() {
            const m = document.getElementById('minimap');
            const px = camera.position.x;
            const pz = camera.position.z;
            
            // Map 500 world units to 500 px map
            const mx = (px / WORLD_SIZE) * 500 + 250; 
            const my = (pz / WORLD_SIZE) * 500 + 250;
            
            m.style.transform = `translate(${-mx + 80}px, ${-my + 80}px)`; // Center inside 160px frame
            
            // Rotate Arrow
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const rot = Math.atan2(dir.x, dir.z);
            document.querySelector('.map-arrow').style.transform = `translate(-50%, -50%) rotate(${-rot}rad)`;
            document.querySelector('.map-arrow').style.left = mx + 'px';
            document.querySelector('.map-arrow').style.top = my + 'px';
            
            // Bot dots (Needs optimization, but simple for now)
            document.querySelectorAll('.map-bot').forEach(el => el.remove());
            bots.forEach(bot => {
                const bdx = bot.mesh.position.x;
                const bdz = bot.mesh.position.z;
                const bmx = (bdx / WORLD_SIZE) * 500 + 250;
                const bmy = (bdz / WORLD_SIZE) * 500 + 250;
                
                const dot = document.createElement('div');
                dot.className = 'map-dot map-bot';
                dot.style.left = bmx + 'px';
                dot.style.top = bmy + 'px';
                m.appendChild(dot);
            });
        }

        function checkWin() {
            if(bots.length === 0) {
                document.getElementById('game-over').style.display = 'flex';
                document.exitPointerLock();
            }
        }
        
        // Expose selectSlot for HTML clicks
        window.selectSlot = switchSlot;

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
