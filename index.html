<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Battle Royale: Ultimate Fix</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; background: #111; }
        
        /* --- UI LAYER --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Crosshair */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px; 
            transform: translate(-50%, -50%); transition: transform 0.1s;
        }
        .crosshair-line { position: absolute; background: rgba(255,255,255,0.9); box-shadow: 0 0 2px black; }
        .ch-h { width: 100%; height: 2px; top: 50%; left: 0; margin-top: -1px; }
        .ch-v { height: 100%; width: 2px; left: 50%; top: 0; margin-left: -1px; }
        .ch-dot { width: 4px; height: 4px; background: red; top: 50%; left: 50%; position: absolute; transform: translate(-50%, -50%); border-radius: 50%; display: none;}

        /* HUD Stats */
        #status-area { position: absolute; bottom: 30px; left: 30px; display: flex; flex-direction: column; gap: 8px; width: 320px; }
        .bar-container { width: 100%; height: 28px; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.2); transform: skewX(-15deg); position: relative; }
        .bar-fill { height: 100%; transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1); }
        #shield-bar { background: linear-gradient(90deg, #0066ff, #00ccff); width: 0%; box-shadow: 0 0 10px #00ccff; }
        #health-bar { background: linear-gradient(90deg, #00aa00, #55ff55); width: 100%; box-shadow: 0 0 10px #55ff55; }
        .bar-text { position: absolute; top: 0; left: 15px; color: white; font-weight: 900; font-size: 16px; line-height: 28px; text-shadow: 2px 2px 0 #000; transform: skewX(15deg); font-style: italic; }

        /* Inventory */
        #inventory { 
            position: absolute; bottom: 30px; right: 30px; 
            display: flex; gap: 10px; 
        }
        .slot { 
            width: 75px; height: 75px; 
            background: rgba(10, 10, 10, 0.85); 
            border: 2px solid #444; 
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            color: white; position: relative;
            transition: transform 0.1s, border-color 0.2s;
        }
        .slot.active { border-color: #ffd700; transform: scale(1.1) translateY(-10px); z-index: 2; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .slot-key { position: absolute; top: 2px; left: 5px; font-weight: bold; color: #aaa; font-size: 12px; }
        .slot-icon { font-size: 28px; margin-bottom: 5px; filter: drop-shadow(0 0 5px rgba(255,255,255,0.3)); }
        .slot-name { font-size: 10px; text-transform: uppercase; font-weight: bold; width: 90%; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        
        /* Rarity Borders */
        .rarity-common { border-bottom: 4px solid #b0b0b0; }
        .rarity-uncommon { border-bottom: 4px solid #28a745; }
        .rarity-rare { border-bottom: 4px solid #007bff; }
        .rarity-epic { border-bottom: 4px solid #a335ee; }
        .rarity-legendary { border-bottom: 4px solid #ffd700; box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.2); }

        /* Interaction */
        #interact-msg {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: #ffcc00; padding: 10px 30px;
            font-size: 20px; border-radius: 5px; display: none;
            border: 2px solid #ffcc00; font-weight: bold; text-transform: uppercase;
        }
        
        /* Top HUD */
        #top-hud { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 30px; box-sizing: border-box; }
        #storm-timer { background: #220033; color: #ff99ff; padding: 8px 20px; border-radius: 4px; font-weight: bold; border: 2px solid #a335ee; font-family: monospace; font-size: 20px; }
        #alive-counter { background: #333; color: white; padding: 8px 20px; border-radius: 4px; font-weight: bold; border: 2px solid white; font-size: 20px; }
        
        #kill-feed { position: absolute; top: 80px; left: 30px; display: flex; flex-direction: column; gap: 5px; }
        .feed-item { background: rgba(0,0,0,0.5); padding: 5px 10px; color: white; border-radius: 3px; font-size: 14px; animation: fadeout 5s forwards; }
        @keyframes fadeout { 0% {opacity:1;} 80% {opacity:1;} 100% {opacity:0;} }

        #mats-display { position: absolute; right: 30px; top: 80px; color: #deb887; font-size: 24px; font-weight: 900; background: rgba(0,0,0,0.6); padding: 5px 15px; border-radius: 5px; border: 1px solid #deb887; }

        /* Game Over */
        #game-over-screen {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 999; pointer-events: auto;
        }
        #go-title { font-size: 100px; font-weight: 900; margin: 0; text-transform: uppercase; letter-spacing: 5px; font-style: italic; }
        .btn { margin-top: 40px; padding: 20px 50px; font-size: 24px; cursor: pointer; background: #ffe600; color: black; border: none; font-weight: 900; text-transform: uppercase; transform: skewX(-10deg); transition: 0.2s;}
        .btn:hover { background: #fff; transform: skewX(-10deg) scale(1.05); }

        #storm-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(100, 0, 200, 0.3);
            box-shadow: inset 0 0 200px rgba(100, 0, 200, 0.8);
            display: none; pointer-events: none; z-index: 1; mix-blend-mode: hard-light;
        }

        #hit-marker {
            position: absolute; top: 50%; left: 50%; width: 16px; height: 16px;
            transform: translate(-50%, -50%) rotate(45deg);
            border: 2px solid transparent;
            border-top-color: #ff3333; border-right-color: #ff3333;
            opacity: 0; transition: opacity 0.05s;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="crosshair">
            <div class="crosshair-line ch-h"></div>
            <div class="crosshair-line ch-v"></div>
            <div class="ch-dot"></div>
        </div>
        <div id="hit-marker"></div>

        <div id="top-hud">
            <div id="alive-counter">Alive: 30</div>
            <div id="storm-timer">STORM: 02:00</div>
        </div>

        <div id="mats-display">ðŸªµ <span id="wood-val">0</span></div>
        <div id="kill-feed"></div>
        <div id="interact-msg">Press E</div>

        <div id="status-area">
            <div class="bar-container">
                <div id="shield-bar" class="bar-fill"></div>
                <div class="bar-text">SHIELD <span id="shield-val">0</span></div>
            </div>
            <div class="bar-container">
                <div id="health-bar" class="bar-fill"></div>
                <div class="bar-text">HEALTH <span id="health-val">100</span></div>
            </div>
        </div>

        <div id="inventory">
            <div class="slot" id="slot-0"><span class="slot-key">1</span></div>
            <div class="slot" id="slot-1"><span class="slot-key">2</span></div>
            <div class="slot" id="slot-2"><span class="slot-key">3</span></div>
            <div class="slot" id="slot-3"><span class="slot-key">4</span></div>
            <div class="slot" id="slot-4"><span class="slot-key">5</span></div>
        </div>
        
        <div id="storm-overlay"></div>
    </div>

    <div id="game-over-screen">
        <div id="go-title">VICTORY ROYALE!</div>
        <div id="go-stats" style="font-size: 24px; margin-top: 10px; color: #aaa;"></div>
        <button class="btn" onclick="location.reload()">RETURN TO LOBBY</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. CONSTANTS & DATA ---
        const WORLD_SIZE = 500;
        const PLAYER_HEIGHT = 1.7;
        const GRAVITY = 30.0;
        const JUMP_FORCE = 12.0;
        const WALK_SPEED = 8.0;
        const SPRINT_SPEED = 15.0;
        const BOT_COUNT = 30;

        const RARITY = {
            COMMON:     { id: 0, name: 'Common',    color: '#b0b0b0', hex: 0xb0b0b0, mul: 1.0 },
            UNCOMMON:   { id: 1, name: 'Uncommon',  color: '#28a745', hex: 0x28a745, mul: 1.2 },
            RARE:       { id: 2, name: 'Rare',      color: '#007bff', hex: 0x007bff, mul: 1.4 },
            EPIC:       { id: 3, name: 'Epic',      color: '#a335ee', hex: 0xa335ee, mul: 1.6 },
            LEGENDARY:  { id: 4, name: 'Legendary', color: '#ffd700', hex: 0xffd700, mul: 2.0 }
        };

        const WEAPON_TYPES = {
            AR:     { name: "Assault Rifle",    dmg: 30, range: 250, fireRate: 0.15, spread: 0.02, auto: true, icon: 'ðŸ”«' },
            PUMP:   { name: "Pump Shotgun",     dmg: 90, range: 40,  fireRate: 0.9,  spread: 0.08, auto: false, pellets: 8, icon: 'ðŸ§¨' },
            SMG:    { name: "Paced SMG",        dmg: 18, range: 80,  fireRate: 0.08, spread: 0.05, auto: true, icon: 'ðŸ–Šï¸' },
            SNIPER: { name: "Eagle Eye",        dmg: 110,range: 500, fireRate: 1.5,  spread: 0.001,auto: false, icon: 'ðŸ”­' },
            RIFLE:  { name: "Heavy Rifle",      dmg: 45, range: 150, fireRate: 0.35, spread: 0.01, auto: false, icon: 'ðŸ' }
        };

        const CONSUMABLES = {
            MINI: { name: "Small Shield", val: 25, type: 'shield', max: 50, icon: 'ðŸ›¡ï¸', time: 2000, color: 0x55aaff },
            BIG:  { name: "Shield Potion", val: 50, type: 'shield', max: 100,icon: 'âš—ï¸', time: 4000, color: 0x0000ff },
            MED:  { name: "Med Kit",       val: 100,type: 'health', max: 100,icon: 'ðŸ’Š', time: 8000, color: 0xff0000 }
        };

        // --- 2. GLOBAL STATE VARIABLES (Defined BEFORE usage to fix ReferenceError) ---
        
        // ThreeJS Globals
        let camera, scene, renderer, controls;
        let weaponCamera, weaponScene;
        let raycaster;
        
        // Movement State
        let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, isSprinting=false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();

        // Player State
        let player = {
            health: 100,
            shield: 0,
            wood: 0,
            inventory: [null, null, null, null, null],
            selectedSlot: 0,
            isDead: false,
            isConsuming: false,
            inVehicle: false
        };

        // Combat State (The culprits of the previous error)
        let isFiring = false; 
        let lastFireTime = 0;
        let isAds = false;
        let currentViewModel = null;

        // World Objects
        let objects = []; 
        let bots = [];
        let chests = [];
        let lootItems = [];
        let buildings = [];
        let cars = [];
        let currentCar = null; // The car object the player is driving

        // Storm
        let stormStartTime = Date.now();
        let stormRadius = WORLD_SIZE;
        let stormCenter = new THREE.Vector2(0,0);

        // --- 3. INITIALIZATION ---

        init();
        animate();

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 400);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = PLAYER_HEIGHT;

            // Weapon Layer
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.autoClear = false;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemi);
            weaponScene.add(hemi.clone());

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            scene.add(dirLight);

            const weaponLight = new THREE.DirectionalLight(0xffffff, 1.5);
            weaponLight.position.set(0, 5, 2);
            weaponScene.add(weaponLight);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            document.addEventListener('click', () => {
                if(!player.isDead) controls.lock();
            });

            // Inputs
            setupInputs();

            // Generation
            raycaster = new THREE.Raycaster();
            generateTerrain();
            generatePOIs();
            spawnBots();
            spawnCars(); // Added cars back

            // Give initial loot
            addToInventory({
                category: 'weapon',
                ...WEAPON_TYPES.AR,
                rarity: RARITY.COMMON,
                currentAmmo: 30,
                damage: 30,
                id: Math.random()
            });

            updateUI();
            updateInventoryUI();
        }

        // --- 4. INPUT HANDLING ---
        function setupInputs() {
            const onKeyDown = (e) => {
                if(player.isDead) return;
                switch(e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': 
                        if(player.inVehicle) break;
                        if(canJump) { velocity.y += JUMP_FORCE; canJump=false; } 
                        break;
                    case 'ShiftLeft': isSprinting = true; break;
                    case 'Digit1': switchSlot(0); break;
                    case 'Digit2': switchSlot(1); break;
                    case 'Digit3': switchSlot(2); break;
                    case 'Digit4': switchSlot(3); break;
                    case 'Digit5': switchSlot(4); break;
                    case 'KeyR': /* reload logic placeholder */ break;
                    case 'KeyE': interact(); break;
                    case 'KeyQ': buildWall(); break;
                }
            };
            const onKeyUp = (e) => {
                switch(e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': isSprinting = false; break;
                }
            };
            const onMouseDown = (e) => {
                if(!controls.isLocked) return;
                if(e.button === 0) fireWeapon();
                if(e.button === 2) toggleAds(true);
            };
            const onMouseUp = (e) => {
                if(e.button === 0) stopFiring();
                if(e.button === 2) toggleAds(false);
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
        }

        // --- 5. WORLD GENERATION ---
        function generateTerrain() {
            const geometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 128, 128);
            geometry.rotateX(-Math.PI / 2);
            
            const pos = geometry.attributes.position;
            const colors = [];
            const colorAttr = new THREE.BufferAttribute(new Float32Array(pos.count * 3), 3);

            for(let i=0; i<pos.count; i++) {
                const x = pos.getX(i);
                const z = pos.getZ(i);
                let y = (Math.sin(x/40)*6 + Math.cos(z/40)*6) + (Math.sin(x/15 + z/15)*2);
                if(Math.abs(x) > 180 || Math.abs(z) > 180) y += 15 + Math.random()*5; 
                
                pos.setY(i, y);

                if(y > 14) colors.push(1,1,1); // Snow
                else if(y > 8) colors.push(0.5, 0.4, 0.3); // Rock
                else colors.push(0.1, 0.5 + Math.random()*0.1, 0.1); // Grass
            }
            
            geometry.setAttribute('color', colorAttr.copyArray(colors));
            geometry.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9 });
            const mesh = new THREE.Mesh(geometry, mat);
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh);
        }

        function getTerrainHeight(x, z) {
            let y = (Math.sin(x/40)*6 + Math.cos(z/40)*6) + (Math.sin(x/15 + z/15)*2);
            if(Math.abs(x) > 180 || Math.abs(z) > 180) y += 15;
            return y;
        }

        function generatePOIs() {
            // Tilted Towers
            createCity(-60, -60);
            // Forest
            createForest(60, 60);
            // Outpost
            createOutpost(0, 80);
        }

        function createCity(ox, oz) {
            for(let i=0; i<5; i++) {
                for(let j=0; j<5; j++) {
                    if(Math.random() > 0.3) {
                        const h = 15 + Math.random()*25;
                        const w = 10;
                        const mat = new THREE.MeshStandardMaterial({color: 0x555555});
                        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), mat);
                        mesh.position.set(ox + i*18, h/2 + getTerrainHeight(ox+i*18, oz+j*18), oz + j*18);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        scene.add(mesh);
                        objects.push(mesh);
                    }
                }
            }
            spawnChest(ox, getTerrainHeight(ox,oz)+1, oz);
            spawnChest(ox+20, getTerrainHeight(ox+20,oz+20)+1, oz+20);
        }

        function createForest(ox, oz) {
            for(let i=0; i<30; i++) {
                const x = ox + (Math.random()-0.5)*80;
                const z = oz + (Math.random()-0.5)*80;
                const y = getTerrainHeight(x,z);
                
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.8,5), new THREE.MeshStandardMaterial({color:0x8B4513}));
                trunk.position.set(x, y+2.5, z);
                scene.add(trunk);
                objects.push(trunk);
                
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(4,8,8), new THREE.MeshStandardMaterial({color:0x228B22}));
                leaves.position.set(x, y+7, z);
                scene.add(leaves);
            }
            spawnChest(ox, getTerrainHeight(ox,oz)+1, oz);
        }

        function createOutpost(x, z) {
            const h = getTerrainHeight(x,z);
            const base = new THREE.Mesh(new THREE.BoxGeometry(20, 2, 20), new THREE.MeshStandardMaterial({color: 0x333333}));
            base.position.set(x, h+1, z);
            scene.add(base);
            objects.push(base);
            spawnChest(x, h+2.5, z);
        }

        // --- 6. CARS ---
        function spawnCars() {
            const carGeo = new THREE.BoxGeometry(4, 1.5, 6);
            const carMat = new THREE.MeshStandardMaterial({ color: 0xff3300 });
            
            for(let i=0; i<3; i++) { // 3 Cars
                const carMesh = new THREE.Mesh(carGeo, carMat);
                // Random loc
                const cx = (Math.random()-0.5)*100;
                const cz = (Math.random()-0.5)*100;
                carMesh.position.set(cx, getTerrainHeight(cx,cz)+1, cz);
                carMesh.castShadow = true;
                
                // Add Wheels (visual)
                const wGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5);
                const wMat = new THREE.MeshBasicMaterial({color:0x000000});
                const positions = [[-2.1, -0.5, -2], [2.1, -0.5, -2], [-2.1, -0.5, 2], [2.1, -0.5, 2]];
                positions.forEach(p => {
                    const w = new THREE.Mesh(wGeo, wMat);
                    w.rotation.z = Math.PI/2;
                    w.position.set(...p);
                    carMesh.add(w);
                });

                scene.add(carMesh);
                cars.push({ mesh: carMesh, speed: 0, ry: 0 });
            }
        }

        // --- 7. INTERACTION ---
        function spawnChest(x, y, z) {
            const geo = new THREE.BoxGeometry(1.5, 1, 1);
            const mat = new THREE.MeshStandardMaterial({color: 0xFFD700, roughness: 0.3});
            const chest = new THREE.Mesh(geo, mat);
            chest.position.set(x, y, z);
            chest.userData = { type: 'chest' };
            scene.add(chest);
            chests.push(chest);
        }

        function spawnLoot(x, y, z, fixedItem = null) {
            const item = fixedItem || generateRandomItem();
            const group = new THREE.Group();
            
            // Glow
            const glow = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.1, 10, 8), 
                new THREE.MeshBasicMaterial({ color: item.rarity?.hex || item.color, transparent: true, opacity: 0.4 })
            );
            glow.position.y = 5;
            group.add(glow);

            // Box
            const box = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshBasicMaterial({color: item.rarity?.hex || item.color}));
            box.position.y = 0.5;
            
            // Animate spin
            box.userData = { spin: true };
            group.add(box);

            group.position.set(x, y, z);
            group.userData = { type: 'loot', data: item };
            scene.add(group);
            lootItems.push(group);
        }

        function generateRandomItem() {
            if(Math.random() < 0.35) {
                // Consumable
                const types = Object.values(CONSUMABLES);
                const type = types[Math.floor(Math.random() * types.length)];
                return { category: 'consumable', ...type, count: 1, id: Math.random() };
            } else {
                // Weapon
                const types = Object.values(WEAPON_TYPES);
                const base = types[Math.floor(Math.random() * types.length)];
                
                let rarity = RARITY.COMMON;
                const r = Math.random();
                if(r>0.95) rarity=RARITY.LEGENDARY;
                else if(r>0.85) rarity=RARITY.EPIC;
                else if(r>0.65) rarity=RARITY.RARE;
                else if(r>0.40) rarity=RARITY.UNCOMMON;

                return {
                    category: 'weapon',
                    ...base,
                    rarity: rarity,
                    currentAmmo: 30,
                    damage: Math.floor(base.dmg * rarity.mul),
                    id: Math.random()
                };
            }
        }

        function interact() {
            // 1. Exit Car
            if(player.inVehicle) {
                player.inVehicle = false;
                currentCar = null;
                camera.position.y = PLAYER_HEIGHT; // Reset height
                controls.getObject().rotation.z = 0; // Reset tilt
                return;
            }

            const pos = camera.position;
            
            // 2. Enter Car
            for(let c of cars) {
                if(c.mesh.position.distanceTo(pos) < 5) {
                    player.inVehicle = true;
                    currentCar = c;
                    return;
                }
            }

            // 3. Open Chests
            for(let i=chests.length-1; i>=0; i--) {
                const c = chests[i];
                if(c.position.distanceTo(pos) < 3) {
                    scene.remove(c);
                    chests.splice(i, 1);
                    // Spawn Items
                    spawnLoot(c.position.x-1, c.position.y, c.position.z);
                    spawnLoot(c.position.x+1, c.position.y, c.position.z);
                    spawnLoot(c.position.x, c.position.y, c.position.z+1);
                    return;
                }
            }

            // 4. Pick up Loot
            for(let i=lootItems.length-1; i>=0; i--) {
                const l = lootItems[i];
                if(l.position.distanceTo(pos) < 2.5) {
                    if(addToInventory(l.userData.data)) {
                        scene.remove(l);
                        lootItems.splice(i, 1);
                        return;
                    }
                }
            }
        }

        function addToInventory(item) {
            // Find empty
            for(let i=0; i<5; i++) {
                if(player.inventory[i] == null) {
                    player.inventory[i] = item;
                    updateInventoryUI();
                    if(i === player.selectedSlot) switchSlot(i);
                    return true;
                }
            }
            return false;
        }

        function switchSlot(index) {
            player.selectedSlot = index;
            document.querySelectorAll('.slot').forEach((el, i) => {
                el.classList.toggle('active', i === index);
            });
            
            const item = player.inventory[index];
            if(item && item.category === 'weapon') {
                buildWeaponModel(item);
            } else {
                if(currentViewModel) {
                    weaponScene.remove(currentViewModel);
                    currentViewModel = null;
                }
            }
        }

        // --- 8. WEAPON MODELS ---
        function buildWeaponModel(item) {
            if(currentViewModel) weaponScene.remove(currentViewModel);
            
            const group = new THREE.Group();
            const col = item.rarity.hex;
            const mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.3, metalness: 0.5 });
            const black = new THREE.MeshStandardMaterial({ color: 0x111111 });

            // Proceedural Parts
            const type = item.name;
            if(type.includes("Rifle") || type.includes("AR")) {
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.6), mat)); // Body
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.2, 0.1), black)); // Mag
                const b = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.6), black); // Barrel
                b.rotation.x = -Math.PI/2; b.position.z = -0.5;
                group.add(b);
            } else if (type.includes("Shotgun")) {
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.7), mat));
                const b = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,0.5), black);
                b.rotation.x = -Math.PI/2; b.position.z = -0.6;
                group.add(b);
            } else if (type.includes("Sniper")) {
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.12, 0.8), mat));
                const b = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,1.0), black);
                b.rotation.x = -Math.PI/2; b.position.z = -0.8;
                group.add(b);
                const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,0.3), black);
                scope.rotation.x = -Math.PI/2; scope.position.y = 0.12;
                group.add(scope);
            } else {
                // SMG
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.4), mat));
                const b = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.3), black);
                b.rotation.x = -Math.PI/2; b.position.z = -0.3;
                group.add(b);
            }

            // Default Pos
            group.position.set(0.3, -0.3, -0.5);
            weaponScene.add(group);
            currentViewModel = group;
        }

        // --- 9. COMBAT & LOGIC ---
        function toggleAds(state) {
            isAds = state;
            const crosshair = document.getElementById('crosshair');
            if(isAds) {
                crosshair.style.transform = "translate(-50%, -50%) scale(0.5)";
            } else {
                crosshair.style.transform = "translate(-50%, -50%) scale(1)";
            }
        }

        function fireWeapon() {
            const item = player.inventory[player.selectedSlot];
            if(!item) return;

            if(item.category === 'consumable') {
                useConsumable(item);
                return;
            }
            if(!player.inVehicle) isFiring = true;
        }

        function stopFiring() { isFiring = false; }

        function useConsumable(item) {
            if(player.isConsuming) return;
            player.isConsuming = true;
            
            const msg = document.getElementById('interact-msg');
            msg.style.display = 'block';
            msg.innerText = `Using ${item.name}...`;

            setTimeout(() => {
                if(player.isDead) return;
                
                if(item.type === 'shield') player.shield = Math.min(player.shield + item.val, item.max);
                else player.health = Math.min(player.health + item.val, 100);
                
                player.inventory[player.selectedSlot] = null;
                updateInventoryUI();
                updateUI();
                player.isConsuming = false;
                msg.style.display = 'none';
            }, item.time);
        }

        function processShooting(time) {
            const item = player.inventory[player.selectedSlot];
            if(!item || item.category !== 'weapon' || !isFiring) return;
            if(player.isConsuming || player.inVehicle) return;

            if(time - lastFireTime < item.fireRate * 1000) return;
            if(!item.auto) isFiring = false; // Semi auto check

            lastFireTime = time;

            // Recoil Visual
            if(currentViewModel) {
                currentViewModel.position.z += 0.15;
                currentViewModel.rotation.x += 0.1;
            }

            // Raycast
            const spread = isAds ? item.spread * 0.3 : item.spread;
            const rx = (Math.random()-0.5) * spread;
            const ry = (Math.random()-0.5) * spread;
            raycaster.setFromCamera(new THREE.Vector2(rx, ry), camera);

            // Collidables
            const botMeshes = bots.map(b => b.mesh);
            const hits = raycaster.intersectObjects([...botMeshes, ...buildings]);

            if(hits.length > 0) {
                const hit = hits[0];
                if(hit.distance > item.range) return;

                // Find Bot
                const bot = bots.find(b => b.mesh === hit.object);
                if(bot) {
                    // DMG
                    const isHead = hit.point.y > bot.mesh.position.y + 0.5;
                    const dmg = Math.floor(isHead ? item.damage * 2.0 : item.damage);
                    bot.health -= dmg;

                    // UI
                    showHitMarker();
                    createHitEffect(hit.point, 0xff0000);

                    if(bot.health <= 0) killBot(bot);
                } else {
                    // Wall
                    createHitEffect(hit.point, 0xcccccc);
                    // Building destroy logic simplified
                    if(buildings.includes(hit.object)) {
                         // could remove wall here
                    }
                }
            }
        }

        function createHitEffect(pos, color) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.1), new THREE.MeshBasicMaterial({color:color}));
            p.position.copy(pos);
            scene.add(p);
            setTimeout(()=>scene.remove(p), 300);
        }

        function showHitMarker() {
            const h = document.getElementById('hit-marker');
            h.style.opacity = 1;
            setTimeout(() => h.style.opacity = 0, 100);
        }

        // --- 10. AI & UPDATE LOOP ---
        function updateBots(delta, now) {
            const pPos = camera.position;
            bots.forEach(bot => {
                if(bot.health <= 0) return;
                
                const dist = bot.mesh.position.distanceTo(pPos);
                
                // Gravity
                const ground = getTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                if(bot.mesh.position.y > ground + 0.9) {
                    bot.mesh.position.y -= GRAVITY * delta * 0.5;
                } else {
                    bot.mesh.position.y = ground + 0.9;
                }

                if(dist < 50) {
                    // Attack
                    bot.mesh.lookAt(pPos.x, bot.mesh.position.y, pPos.z);
                    if(dist > 10) bot.mesh.translateZ(3 * delta);

                    // Shoot
                    if(now - bot.lastShot > 1500) {
                        bot.lastShot = now;
                        // 30% hit chance
                        if(Math.random() < 0.3 && !player.isDead) {
                            const isHead = Math.random() < 0.1;
                            damagePlayer(isHead ? 16 : 7);
                            // Visual Tracer
                            const t = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1, dist), new THREE.MeshBasicMaterial({color:0xffff00}));
                            t.position.copy(bot.mesh.position).lerp(pPos, 0.5);
                            t.lookAt(pPos);
                            scene.add(t);
                            setTimeout(()=>scene.remove(t), 100);
                        }
                    }
                } else {
                    // Wander
                    if(now > bot.nextMove) {
                        bot.mesh.rotation.y = Math.random() * 6.28;
                        bot.nextMove = now + 2000 + Math.random()*3000;
                    }
                    bot.mesh.translateZ(2 * delta);
                }
            });
        }

        function killBot(bot) {
            scene.remove(bot.mesh);
            const idx = bots.indexOf(bot);
            if(idx > -1) bots.splice(idx, 1);

            // Log
            const feed = document.getElementById('kill-feed');
            const el = document.createElement('div');
            el.className = 'feed-item';
            el.innerHTML = `You eliminated <span style="color:red">Bot#${Math.floor(Math.random()*99)}</span>`;
            feed.prepend(el);

            player.wood += 50;
            spawnLoot(bot.mesh.position.x, bot.mesh.position.y, bot.mesh.position.z);
            
            updateUI();
            
            if(bots.length === 0) {
                document.getElementById('game-over-screen').style.display = 'flex';
                controls.unlock();
            }
        }

        function damagePlayer(amt) {
            if(player.isDead) return;
            
            if(player.shield > 0) {
                if(player.shield >= amt) {
                    player.shield -= amt;
                } else {
                    const rem = amt - player.shield;
                    player.shield = 0;
                    player.health -= rem;
                }
            } else {
                player.health -= amt;
            }

            document.body.style.boxShadow = "inset 0 0 50px red";
            setTimeout(()=>document.body.style.boxShadow="none", 100);
            updateUI();

            if(player.health <= 0) {
                player.isDead = true;
                controls.unlock();
                document.getElementById('game-over-screen').style.display = 'flex';
                document.getElementById('go-title').innerText = "ELIMINATED";
                document.getElementById('go-title').style.color = "red";
            }
        }

        // --- 11. BUILD ---
        function buildWall() {
            if(player.wood < 10 || player.inVehicle) return;
            player.wood -= 10;
            updateUI();

            const geo = new THREE.BoxGeometry(4, 3, 0.2);
            const mat = new THREE.MeshStandardMaterial({map: null, color: 0x8B4513});
            const wall = new THREE.Mesh(geo, mat);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const pos = camera.position.clone().add(dir.multiplyScalar(3));
            
            wall.position.set(pos.x, pos.y, pos.z);
            wall.lookAt(camera.position.x, wall.position.y, camera.position.z);
            
            scene.add(wall);
            buildings.push(wall);
        }

        // --- 12. UI HELPERS ---
        function updateUI() {
            document.getElementById('health-val').innerText = Math.ceil(player.health);
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('shield-val').innerText = Math.ceil(player.shield);
            document.getElementById('shield-bar').style.width = player.shield + '%';
            document.getElementById('wood-val').innerText = player.wood;
            document.getElementById('alive-counter').innerText = `Alive: ${bots.length + 1}`;
        }

        function updateInventoryUI() {
            player.inventory.forEach((item, i) => {
                const el = document.getElementById(`slot-${i}`);
                if(item) {
                    const rClass = item.rarity ? `rarity-${item.rarity.name.toLowerCase()}` : '';
                    el.className = `slot ${rClass} ${i===player.selectedSlot ? 'active' : ''}`;
                    el.innerHTML = `<span class="slot-key">${i+1}</span>
                                    <div class="slot-icon">${item.icon}</div>
                                    <div class="slot-name">${item.name}</div>`;
                } else {
                    el.className = `slot ${i===player.selectedSlot ? 'active' : ''}`;
                    el.innerHTML = `<span class="slot-key">${i+1}</span>`;
                }
            });
        }

        function spawnBot() {
             const geo = new THREE.CapsuleGeometry(0.6, 1.8, 4, 8);
             const mat = new THREE.MeshStandardMaterial({color: 0xff0000});
             const m = new THREE.Mesh(geo, mat);
             const x = (Math.random()-0.5)*WORLD_SIZE*0.7;
             const z = (Math.random()-0.5)*WORLD_SIZE*0.7;
             m.position.set(x, 10, z);
             scene.add(m);
             bots.push({ mesh: m, health: 100, lastShot: 0, nextMove: 0 });
        }

        function spawnBots() {
            for(let i=0; i<BOT_COUNT; i++) spawnBot();
        }

        // --- 13. MAIN ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            if(player.isDead) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            // Storm
            const elapsed = (Date.now() - stormStartTime) / 1000;
            const stormTotal = 180; 
            stormRadius = THREE.MathUtils.lerp(WORLD_SIZE, 0, Math.min(elapsed/stormTotal, 1));
            
            const mins = Math.floor(Math.max(0, stormTotal - elapsed) / 60);
            const secs = Math.floor(Math.max(0, stormTotal - elapsed) % 60);
            document.getElementById('storm-timer').innerText = `STORM: ${mins}:${secs<10?'0':''}${secs}`;
            
            const pDist = new THREE.Vector2(camera.position.x, camera.position.z).distanceTo(stormCenter);
            const overlay = document.getElementById('storm-overlay');
            if(pDist > stormRadius) {
                overlay.style.display = 'block';
                if(Math.random()<0.05) damagePlayer(1);
            } else {
                overlay.style.display = 'none';
            }

            // Controls
            if(controls.isLocked) {
                if(player.inVehicle && currentCar) {
                    // Car Physics
                    const speed = 25.0;
                    if(moveForward) currentCar.mesh.translateZ(speed * delta);
                    if(moveBackward) currentCar.mesh.translateZ(-speed * delta);
                    if(moveLeft) currentCar.mesh.rotateY(2.0 * delta);
                    if(moveRight) currentCar.mesh.rotateY(-2.0 * delta);

                    // Camera Follow
                    const offset = new THREE.Vector3(0, 5, -10);
                    offset.applyQuaternion(currentCar.mesh.quaternion);
                    camera.position.copy(currentCar.mesh.position).add(offset);
                    camera.lookAt(currentCar.mesh.position);
                    
                    // Stick to ground
                    const h = getTerrainHeight(currentCar.mesh.position.x, currentCar.mesh.position.z);
                    currentCar.mesh.position.y = h + 1;

                } else {
                    // Foot Physics
                    velocity.x -= velocity.x * 10.0 * delta;
                    velocity.z -= velocity.z * 10.0 * delta;
                    velocity.y -= GRAVITY * delta;
                    
                    direction.z = Number(moveForward) - Number(moveBackward);
                    direction.x = Number(moveRight) - Number(moveLeft);
                    direction.normalize();

                    const s = isSprinting ? SPRINT_SPEED : WALK_SPEED;
                    if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta * (s/10);
                    if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta * (s/10);

                    controls.moveRight(-velocity.x * delta);
                    controls.moveForward(-velocity.z * delta);

                    const h = getTerrainHeight(camera.position.x, camera.position.z);
                    if(camera.position.y < h + PLAYER_HEIGHT) {
                        velocity.y = 0;
                        camera.position.y = h + PLAYER_HEIGHT;
                        canJump = true;
                    }

                    // Weapon Sway
                    if(currentViewModel) {
                        const tx = isAds ? 0 : 0.3;
                        const ty = isAds ? -0.20 : -0.3;
                        const tz = isAds ? -0.4 : -0.5;
                        
                        // Sway
                        const mx = Math.sin(time*0.01) * (velocity.length()>1 ? 0.02 : 0.002);
                        const my = Math.cos(time*0.01) * (velocity.length()>1 ? 0.02 : 0.002);

                        currentViewModel.position.x += (tx + mx - currentViewModel.position.x) * 10 * delta;
                        currentViewModel.position.y += (ty + my - currentViewModel.position.y) * 10 * delta;
                        currentViewModel.position.z += (tz - currentViewModel.position.z) * 10 * delta;
                        
                        // Recoil Recovery
                        currentViewModel.rotation.x *= 0.9; 
                    }
                }
            }
            
            // Interaction UI Check
            const pos = camera.position;
            let showE = false;
            // Cars
            cars.forEach(c => { if(c.mesh.position.distanceTo(pos)<5 && !player.inVehicle) showE=true; });
            // Chests
            chests.forEach(c => { if(c.position.distanceTo(pos)<3) showE=true; });
            // Loot
            lootItems.forEach(l => { if(l.position.distanceTo(pos)<2.5) showE=true; });
            // Exit Car
            if(player.inVehicle) showE = true;

            const msg = document.getElementById('interact-msg');
            if(showE && !player.isConsuming) {
                msg.style.display = 'block';
                msg.innerText = player.inVehicle ? "Press E to Exit" : "Press E";
            } else if (!player.isConsuming) {
                msg.style.display = 'none';
            }

            processShooting(time);
            updateBots(delta, time);
            
            renderer.clear();
            renderer.render(scene, camera);
            if(!player.inVehicle) {
                renderer.clearDepth();
                renderer.render(weaponScene, weaponCamera);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            weaponCamera.aspect = window.innerWidth / window.innerHeight;
            weaponCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
