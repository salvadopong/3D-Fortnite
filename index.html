<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Battle Royale</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 20px; height: 20px; 
            background: transparent; 
            border: 2px solid white; border-radius: 50%; 
            transform: translate(-50%, -50%);
        }
        #crosshair-dot {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: red;
            transform: translate(-50%, -50%); border-radius: 50%;
        }
        .hud-panel { position: absolute; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; color: white; font-weight: bold; }
        #health-bar-container { bottom: 20px; left: 20px; width: 200px; height: 20px; background: #333; border: 2px solid white; }
        #health-bar { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s; }
        #ammo-box { bottom: 20px; right: 20px; font-size: 24px; }
        #mats-box { bottom: 60px; right: 20px; font-size: 20px; color: #deb887; }
        #weapon-bar { bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        .weapon-slot { width: 50px; height: 50px; background: rgba(0,0,0,0.6); border: 1px solid #555; display: flex; justify-content: center; align-items: center; font-size: 12px; color: #aaa; }
        .weapon-selected { border: 2px solid yellow; background: rgba(255, 255, 0, 0.2); color: white; }
        #storm-timer { top: 20px; left: 50%; transform: translateX(-50%); font-size: 20px; color: #aaddff; }
        #kill-feed { top: 20px; left: 20px; font-size: 14px; text-align: left; }
        #player-count { top: 20px; right: 20px; font-size: 18px; }
        #game-over { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); pointer-events: auto; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 10; }
        #game-over h1 { font-size: 72px; text-transform: uppercase; margin-bottom: 20px; }
        #victory-royale { color: #ffd700; text-shadow: 0 0 20px #ffd700; display: none; }
        #you-died { color: #ff3333; display: none; }
        button { padding: 15px 30px; font-size: 24px; cursor: pointer; border: none; background: #007bff; color: white; border-radius: 5px; }
        button:hover { background: #0056b3; }
        #storm-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(100, 0, 255, 0.3);
            display: none; pointer-events: none;
            box-shadow: inset 0 0 100px 50px rgba(100, 0, 255, 0.8);
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="crosshair"><div id="crosshair-dot"></div></div>
        
        <div id="health-bar-container" class="hud-panel">
            <div id="health-bar"></div>
        </div>

        <div id="ammo-box" class="hud-panel">
            <span id="ammo-count">30</span> / <span id="ammo-reserve">âˆž</span>
        </div>

        <div id="mats-box" class="hud-panel">
            ðŸªµ <span id="wood-count">0</span> (Q to Build)
        </div>

        <div id="storm-timer" class="hud-panel">
            STORM: <span id="time-display">02:00</span>
        </div>

        <div id="player-count" class="hud-panel">
            Alive: <span id="alive-count">30</span>
        </div>

        <div id="kill-feed" class="hud-panel" style="background:transparent;"></div>

        <div id="weapon-bar">
            <div class="weapon-slot" id="slot-0">AR</div>
            <div class="weapon-slot" id="slot-1">Pump</div>
            <div class="weapon-slot" id="slot-2">SMG</div>
            <div class="weapon-slot" id="slot-3">Sniper</div>
            <div class="weapon-slot" id="slot-4">Heavy</div>
        </div>
        
        <div id="storm-overlay"></div>
    </div>

    <div id="game-over">
        <h1 id="victory-royale">VICTORY ROYALE!</h1>
        <h1 id="you-died">ELIMINATED</h1>
        <p id="final-stats"></p>
        <button onclick="location.reload()">Return to Lobby</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GAME CONSTANTS ---
        const PLAYER_HEIGHT = 1.8;
        const PLAYER_SPEED = 10.0;
        const PLAYER_RUN_SPEED = 18.0;
        const WORLD_SIZE = 400; // Map size
        const GRAVITY = 30.0;
        const JUMP_FORCE = 15.0;
        const BOT_COUNT = 29;
        
        // --- WEAPONS DATA ---
        const WEAPONS = [
            { name: "Assault Rifle", range: 200, damage: 30, fireRate: 150, spread: 0.02, auto: true, color: 'blue' },
            { name: "Pump Shotgun", range: 40, damage: 95, fireRate: 800, spread: 0.1, auto: false, pellets: 5, color: 'green' },
            { name: "Paced SMG", range: 80, damage: 18, fireRate: 80, spread: 0.06, auto: true, color: 'gray' },
            { name: "Eagle Eye Sniper", range: 500, damage: 150, fireRate: 1500, spread: 0.001, auto: false, color: 'purple' },
            { name: "Blown Out Rifle", range: 150, damage: 45, fireRate: 400, spread: 0.01, auto: false, color: 'orange' }
        ];

        // --- GLOBALS ---
        let camera, scene, renderer, controls;
        let raycaster;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, sprint = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        
        // Game State
        let playerHealth = 100;
        let playerWood = 0;
        let currentWeaponIdx = 0;
        let lastShotTime = 0;
        let isDead = false;
        let isVictory = false;
        let bots = [];
        let buildings = [];
        let cars = [];
        let isDriving = false;
        let currentCar = null;
        let stormRadius = WORLD_SIZE;
        let stormPhase = 0; // 0: Wait, 1: Shrink
        let stormCenter = new THREE.Vector3(0,0,0);

        // Map Objects
        const objects = []; // Collidables
        const bullets = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky Blue
            scene.fog = new THREE.Fog(0x87CEEB, 0, 300);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = PLAYER_HEIGHT;

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
            hemiLight.position.set(0, 200, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            document.addEventListener('click', () => {
                if(!isDead && !isVictory) controls.lock();
            });

            // Input Listeners
            const onKeyDown = (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'Space': if (canJump === true) velocity.y += JUMP_FORCE; canJump = false; break;
                    case 'ShiftLeft': sprint = true; break;
                    case 'KeyQ': buildWall(); break;
                    case 'KeyE': interact(); break;
                    case 'Digit1': switchWeapon(0); break;
                    case 'Digit2': switchWeapon(1); break;
                    case 'Digit3': switchWeapon(2); break;
                    case 'Digit4': switchWeapon(3); break;
                    case 'Digit5': switchWeapon(4); break;
                }
            };
            const onKeyUp = (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': sprint = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', (e) => {
                if(e.button === 0 && controls.isLocked) shoot(); // Left click
                if(e.button === 2) camera.zoom = 2; // Right click zoom
                camera.updateProjectionMatrix();
            });
            document.addEventListener('mouseup', (e) => {
                if(e.button === 2) camera.zoom = 1;
                camera.updateProjectionMatrix();
            });

            // Raycaster for shooting
            raycaster = new THREE.Raycaster();

            // --- WORLD GENERATION ---
            generateTerrain();
            generatePOIs();
            spawnBots();
            spawnCars();

            // Initial UI Update
            updateUI();
        }

        // --- TERRAIN ---
        function generateTerrain() {
            // Simple wavy terrain using sin/cos
            const geometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 64, 64);
            geometry.rotateX(-Math.PI / 2);

            const vertices = geometry.attributes.position.array;
            const colors = [];
            const colorAttribute = new THREE.BufferAttribute(new Float32Array(vertices.length), 3);

            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                // Height formula
                const y = (Math.sin(x / 20) * 5) + (Math.cos(z / 20) * 5) + (Math.sin(x/50 + z/50) * 10);
                vertices[i + 1] = y;

                // Color based on height (White for snowy peaks, Green for grass)
                if (y > 8) {
                    colors.push(1, 1, 1); // Snow
                } else {
                    colors.push(0.2, 0.8, 0.2); // Grass
                }
            }
            
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8 });
            const terrain = new THREE.Mesh(geometry, material);
            terrain.receiveShadow = true;
            scene.add(terrain);
            objects.push(terrain); // Collision floor
        }

        // --- POIS & STRUCTURES ---
        function generatePOIs() {
            // 1. Tilted Towers (City Cluster)
            createCity(-50, -50);
            
            // 2. Nitro Dome (Big Arena-like structure)
            createArena(60, 60);

            // 3. Flower Meadows (Random flowers/trees)
            for(let i=0; i<50; i++) {
                let x = (Math.random() - 0.5) * WORLD_SIZE * 0.8;
                let z = (Math.random() - 0.5) * WORLD_SIZE * 0.8;
                if(Math.abs(x) < 20 && Math.abs(z) < 20) continue; // Don't spawn on spawn point
                createTree(x, z);
            }
        }

        function createCity(cx, cz) {
            for(let i=0; i<5; i++) {
                for(let j=0; j<5; j++) {
                    if(Math.random() > 0.3) {
                        createBuilding(cx + i*15, cz + j*15, 3 + Math.floor(Math.random()*4));
                    }
                }
            }
        }

        function createBuilding(x, z, floors) {
            const h = floors * 5;
            const mat = new THREE.MeshStandardMaterial({color: 0x555555});
            // Main block
            const geo = new THREE.BoxGeometry(10, h, 10);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, h/2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh); // Add to collision

            // "Door" (Visual only, black rectangle)
            const doorGeo = new THREE.BoxGeometry(2, 4, 0.1);
            const doorMat = new THREE.MeshBasicMaterial({color: 0x000000});
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(x, 2, z + 5.05);
            scene.add(door);
            
            // Allow entering? We simulate entering by having gap walls. 
            // Simplified: Just solid blocks for POI look in this version due to complexity.
        }

        function createArena(x, z) {
            const geo = new THREE.CylinderGeometry(20, 20, 10, 16, 1, true);
            const mat = new THREE.MeshStandardMaterial({color: 0xff4500, side: THREE.DoubleSide});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 5, z);
            scene.add(mesh);
            objects.push(mesh);
            
            // Dome roof
            const domeGeo = new THREE.SphereGeometry(20, 16, 16, 0, Math.PI * 2, 0, Math.PI/2);
            const dome = new THREE.Mesh(domeGeo, new THREE.MeshStandardMaterial({color: 0xffaa00, wireframe:true}));
            dome.position.set(x, 5, z);
            scene.add(dome);
        }

        function createTree(x, z) {
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.5, 4);
            const trunkMat = new THREE.MeshStandardMaterial({color: 0x8B4513});
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.set(x, 2, z);
            scene.add(trunk);
            objects.push(trunk);

            const leavesGeo = new THREE.ConeGeometry(3, 6, 8);
            const leavesMat = new THREE.MeshStandardMaterial({color: 0x228B22});
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.set(x, 6, z);
            scene.add(leaves);
        }

        // --- CARS ---
        function spawnCars() {
            // Create 5 cars
            for(let i=0; i<5; i++) {
                const carGroup = new THREE.Group();
                const bodyGeo = new THREE.BoxGeometry(4, 2, 6);
                const bodyMat = new THREE.MeshStandardMaterial({color: 0xff0000});
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 1.5;
                carGroup.add(body);

                // Wheels
                const wGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5);
                const wMat = new THREE.MeshStandardMaterial({color: 0x000000});
                const pos = [[-2, 0.8, -2], [2, 0.8, -2], [-2, 0.8, 2], [2, 0.8, 2]];
                pos.forEach(p => {
                    const w = new THREE.Mesh(wGeo, wMat);
                    w.rotation.z = Math.PI/2;
                    w.position.set(...p);
                    carGroup.add(w);
                });

                carGroup.position.set((Math.random()-0.5)*100, 1, (Math.random()-0.5)*100);
                scene.add(carGroup);
                
                cars.push({
                    mesh: carGroup,
                    speed: 0,
                    velocity: new THREE.Vector3()
                });
            }
        }

        // --- BOTS (AI) ---
        function spawnBots() {
            const geometry = new THREE.CapsuleGeometry(0.8, 1.8, 4, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });

            for (let i = 0; i < BOT_COUNT; i++) {
                const botMesh = new THREE.Mesh(geometry, material);
                // Random position away from center
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                botMesh.position.set(x, 5, z);
                botMesh.castShadow = true;
                
                scene.add(botMesh);
                
                bots.push({
                    mesh: botMesh,
                    health: 100,
                    lastFire: 0,
                    state: 'wander', // wander, chase
                    target: new THREE.Vector3(x, 5, z)
                });
            }
        }

        function updateBots(delta) {
            const playerPos = camera.position;

            bots.forEach((bot, index) => {
                if (bot.health <= 0) return;

                const distToPlayer = bot.mesh.position.distanceTo(playerPos);
                
                // AI Logic
                if (distToPlayer < 50 && !currentCar) {
                    bot.state = 'chase';
                } else if (distToPlayer > 80) {
                    bot.state = 'wander';
                }

                // Movement
                let moveDir = new THREE.Vector3();
                if (bot.state === 'chase') {
                    moveDir.subVectors(playerPos, bot.mesh.position).normalize();
                    // Shoot at player
                    if (Date.now() - bot.lastFire > 1000) { // Shoot every second
                        bot.lastFire = Date.now();
                        // 30% chance to hit
                        if (Math.random() < 0.3) {
                            takeDamage(10);
                        } else {
                            // Miss effects (whizz sound logic here)
                            // console.log("Bot missed");
                        }
                    }
                } else {
                    // Wander logic
                    if (bot.mesh.position.distanceTo(bot.target) < 2) {
                        bot.target.set(
                            bot.mesh.position.x + (Math.random()-0.5)*40,
                            bot.mesh.position.y,
                            bot.mesh.position.z + (Math.random()-0.5)*40
                        );
                    }
                    moveDir.subVectors(bot.target, bot.mesh.position).normalize();
                }

                // Gravity
                bot.mesh.position.y = Math.max(bot.mesh.position.y, getTerrainHeight(bot.mesh.position.x, bot.mesh.position.z) + 1.8);
                
                bot.mesh.position.add(moveDir.multiplyScalar(5 * delta));
                bot.mesh.lookAt(playerPos.x, bot.mesh.position.y, playerPos.z);
            });
        }

        // --- GAME MECHANICS ---
        function switchWeapon(index) {
            currentWeaponIdx = index;
            const weapons = document.querySelectorAll('.weapon-slot');
            weapons.forEach(w => w.classList.remove('weapon-selected'));
            document.getElementById('slot-' + index).classList.add('weapon-selected');
        }

        function shoot() {
            const now = Date.now();
            const weapon = WEAPONS[currentWeaponIdx];
            
            if (now - lastShotTime < weapon.fireRate) return;
            lastShotTime = now;

            // Recoil / Spread
            const spreadX = (Math.random() - 0.5) * weapon.spread;
            const spreadY = (Math.random() - 0.5) * weapon.spread;

            // Raycast
            raycaster.setFromCamera(new THREE.Vector2(spreadX, spreadY), camera);
            
            // Check hits on bots
            const botMeshes = bots.filter(b => b.health > 0).map(b => b.mesh);
            const intersects = raycaster.intersectObjects(botMeshes);

            if (intersects.length > 0 && intersects[0].distance < weapon.range) {
                const hitObj = intersects[0].object;
                const bot = bots.find(b => b.mesh === hitObj);
                if (bot) {
                    // Headshot logic (simple height check relative to bot center)
                    const isHeadshot = intersects[0].point.y > bot.mesh.position.y + 0.5;
                    const dmg = isHeadshot ? weapon.damage * 2 : weapon.damage;
                    
                    bot.health -= dmg;
                    
                    // Visual hit marker
                    createHitParticle(intersects[0].point, isHeadshot ? 0xff0000 : 0xffffff);

                    if (bot.health <= 0) {
                        killBot(bot);
                    }
                }
            } else {
                // Check building hits
                const buildIntersects = raycaster.intersectObjects(buildings);
                if(buildIntersects.length > 0 && buildIntersects[0].distance < weapon.range) {
                    createHitParticle(buildIntersects[0].point, 0xaaaaaa);
                }
            }
        }

        function createHitParticle(pos, color) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({color: color});
            const p = new THREE.Mesh(geo, mat);
            p.position.copy(pos);
            scene.add(p);
            setTimeout(() => scene.remove(p), 500);
        }

        function killBot(bot) {
            scene.remove(bot.mesh);
            bot.health = 0; // Ensure dead
            playerWood += 50;
            updateUI();
            checkVictory();
            
            // Kill Feed
            const feed = document.getElementById('kill-feed');
            const msg = document.createElement('div');
            msg.innerText = "You eliminated a bot";
            msg.style.color = "yellow";
            feed.appendChild(msg);
            setTimeout(() => msg.remove(), 3000);
        }

        function buildWall() {
            if(isDriving) return;
            if (playerWood < 10) return;
            playerWood -= 10;
            updateUI();

            const wallGeo = new THREE.BoxGeometry(4, 3, 0.5);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, map: null }); // Wood color
            const wall = new THREE.Mesh(wallGeo, wallMat);

            // Place in front of player
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const pos = camera.position.clone().add(dir.multiplyScalar(4));
            
            wall.position.set(pos.x, pos.y, pos.z);
            wall.lookAt(camera.position.x, wall.position.y, camera.position.z);
            
            scene.add(wall);
            buildings.push(wall);
            objects.push(wall);
        }

        function interact() {
            // Check for cars
            if(isDriving) {
                // Exit car
                isDriving = false;
                camera.position.y = PLAYER_HEIGHT;
                currentCar = null;
                return;
            }

            const playerPos = camera.position;
            for(let c of cars) {
                if(c.mesh.position.distanceTo(playerPos) < 5) {
                    isDriving = true;
                    currentCar = c;
                    break;
                }
            }
        }

        function takeDamage(amount) {
            playerHealth -= amount;
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.width = '100%'; flash.style.height = '100%';
            flash.style.background = 'red'; flash.style.opacity = '0.3';
            flash.style.pointerEvents = 'none';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 100);

            if (playerHealth <= 0) {
                playerHealth = 0;
                isDead = true;
                controls.unlock();
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('you-died').style.display = 'block';
                document.getElementById('final-stats').innerText = "Placed #" + (getAliveCount() + 1);
            }
            updateUI();
        }

        function checkVictory() {
            if (getAliveCount() === 0) {
                isVictory = true;
                controls.unlock();
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('victory-royale').style.display = 'block';
            }
        }

        function getAliveCount() {
            return bots.filter(b => b.health > 0).length;
        }

        function getTerrainHeight(x, z) {
            // Simplified approximation matching generateTerrain
            // For collisions, better to use Raycaster down, but math is faster for this demo
            return (Math.sin(x / 20) * 5) + (Math.cos(z / 20) * 5) + (Math.sin(x/50 + z/50) * 10);
        }

        function updateUI() {
            document.getElementById('health-bar').style.width = playerHealth + '%';
            document.getElementById('wood-count').innerText = playerWood;
            document.getElementById('alive-count').innerText = getAliveCount() + 1; // +1 for player
        }

        // --- STORM LOGIC ---
        let stormStartTime = Date.now();
        function updateStorm() {
            const timeElapsed = (Date.now() - stormStartTime) / 1000;
            const phases = [120, 180, 240]; // Seconds for phases
            
            let timeLeft = 0;
            if (timeElapsed < 60) {
                timeLeft = 60 - timeElapsed;
                stormPhase = 0;
            } else if (timeElapsed < 120) {
                // Shrinking
                timeLeft = 120 - timeElapsed;
                stormRadius = THREE.MathUtils.lerp(WORLD_SIZE, 50, (timeElapsed - 60) / 60);
                stormPhase = 1;
            } else {
                stormRadius = 0;
                timeLeft = 0;
            }

            // UI
            const mins = Math.floor(timeLeft / 60);
            const secs = Math.floor(timeLeft % 60);
            document.getElementById('time-display').innerText = `${mins}:${secs < 10 ? '0' : ''}${secs}`;

            // Damage
            const dist = new THREE.Vector2(camera.position.x, camera.position.z).distanceTo(new THREE.Vector2(0,0));
            const overlay = document.getElementById('storm-overlay');
            if(dist > stormRadius) {
                overlay.style.display = 'block';
                if(Math.random() < 0.05) takeDamage(1);
            } else {
                overlay.style.display = 'none';
            }
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            if (isDead || isVictory) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // Storm
            updateStorm();

            // Movement
            if (controls.isLocked) {
                if (isDriving && currentCar) {
                    // Car Physics (Simplified)
                    const speed = 30;
                    const turnSpeed = 2.0;
                    
                    if(moveForward) currentCar.mesh.translateZ(speed * delta);
                    if(moveBackward) currentCar.mesh.translateZ(-speed * delta);
                    if(moveLeft) currentCar.mesh.rotateY(turnSpeed * delta);
                    if(moveRight) currentCar.mesh.rotateY(-turnSpeed * delta);

                    // Camera follows car
                    const offset = new THREE.Vector3(0, 5, -10);
                    offset.applyQuaternion(currentCar.mesh.quaternion);
                    camera.position.copy(currentCar.mesh.position).add(offset);
                    camera.lookAt(currentCar.mesh.position);
                    
                    // Stick car to ground
                    currentCar.mesh.position.y = getTerrainHeight(currentCar.mesh.position.x, currentCar.mesh.position.z) + 1;

                } else {
                    // On Foot Physics
                    velocity.x -= velocity.x * 10.0 * delta;
                    velocity.z -= velocity.z * 10.0 * delta;
                    velocity.y -= GRAVITY * delta; 

                    direction.z = Number(moveForward) - Number(moveBackward);
                    direction.x = Number(moveRight) - Number(moveLeft);
                    direction.normalize();

                    const currentSpeed = sprint ? PLAYER_RUN_SPEED : PLAYER_SPEED;

                    if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                    if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                    controls.moveRight(-velocity.x * delta);
                    controls.moveForward(-velocity.z * delta);

                    // Floor Collision
                    const terrainHeight = getTerrainHeight(camera.position.x, camera.position.z);
                    if (camera.position.y < terrainHeight + PLAYER_HEIGHT) {
                        velocity.y = 0;
                        camera.position.y = terrainHeight + PLAYER_HEIGHT;
                        canJump = true;
                    }
                    
                    // Building Collision (Simple dist check to keep it fast)
                    for(let b of buildings) {
                        if(camera.position.distanceTo(b.position) < 3) {
                             controls.moveForward(10 * delta); // Push back
                        }
                    }
                }
            }

            updateBots(delta);
            renderer.render(scene, camera);
            prevTime = time;
        }

    </script>
</body>
</html>
