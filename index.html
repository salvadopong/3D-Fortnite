<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Battle Royale: V3 - Advanced Combat (Final Complete)</title>
    <style>
        /* Base Styles and UI Overlays (Unchanged from previous V3) */
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; background: #111; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Crosshair & Scope */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 24px; height: 24px; transform: translate(-50%, -50%); transition: transform 0.1s; pointer-events: none; }
        .ch-line { position: absolute; background: rgba(255,255,255,0.9); box-shadow: 0 0 2px black; }
        .ch-h { width: 100%; height: 2px; top: 50%; left: 0; margin-top: -1px; }
        .ch-v { height: 100%; width: 2px; left: 50%; top: 0; margin-left: -1px; }
        .ch-dot { width: 4px; height: 4px; background: red; top: 50%; left: 50%; position: absolute; transform: translate(-50%, -50%); border-radius: 50%; display: none;}
        
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black;
            display: none; pointer-events: none; z-index: 100; opacity: 0; transition: opacity 0.1s; border: 5px solid black;
        }
        #scope-overlay.sniper::after { content: ''; position: absolute; top: 50%; left: 50%; width: 2px; height: 100%; background: green; transform: translate(-50%, -50%); }
        #scope-overlay.sniper::before { content: ''; position: absolute; top: 50%; left: 50%; width: 100%; height: 2px; background: green; transform: translate(-50%, -50%); }

        /* Damage Numbers */
        .damage-number {
            position: absolute; color: white; font-size: 24px; font-weight: 900;
            text-shadow: 2px 2px 0 #000; animation: floatup 1.5s ease-out forwards;
            pointer-events: none; z-index: 50;
        }
        .damage-number.headshot { color: yellow; font-size: 30px; text-shadow: 2px 2px 5px red; }
        @keyframes floatup { 0% { transform: translate(-50%, 0); opacity: 1; } 100% { transform: translate(-50%, -100px); opacity: 0; } }

        /* HUD Stats */
        #status-area { position: absolute; bottom: 30px; left: 30px; display: flex; flex-direction: column; gap: 8px; width: 320px; }
        .bar-container { width: 100%; height: 28px; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.2); transform: skewX(-15deg); position: relative; }
        .bar-fill { height: 100%; transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1); }
        #shield-bar { background: linear-gradient(90deg, #0066ff, #00ccff); width: 0%; box-shadow: 0 0 10px #00ccff; }
        #health-bar { background: linear-gradient(90deg, #00aa00, #55ff55); width: 100%; box-shadow: 0 0 10px #55ff55; }
        #jug-indicator { position: absolute; top: -30px; left: 0; color: #00ccff; font-weight: bold; font-size: 14px; text-shadow: 1px 1px 0 #000; display: none;}
        .bar-text { position: absolute; top: 0; left: 15px; color: white; font-weight: 900; font-size: 16px; line-height: 28px; text-shadow: 2px 2px 0 #000; transform: skewX(15deg); font-style: italic; }

        /* Inventory */
        #inventory { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 10px; }
        .slot { width: 75px; height: 75px; background: rgba(10, 10, 10, 0.85); border: 2px solid #444; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; position: relative; transition: transform 0.1s, border-color 0.2s; }
        .slot.active { border-color: #ffd700; transform: scale(1.1) translateY(-10px); z-index: 2; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .slot-key { position: absolute; top: 2px; left: 5px; font-weight: bold; color: #aaa; font-size: 12px; }
        .slot-icon { font-size: 28px; margin-bottom: 5px; filter: drop-shadow(0 0 5px rgba(255,255,255,0.3)); }
        .slot-name { font-size: 10px; text-transform: uppercase; font-weight: bold; width: 90%; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        
        /* Rarity Borders */
        .rarity-common { border-bottom: 4px solid #b0b0b0; }
        .rarity-uncommon { border-bottom: 4px solid #28a745; }
        .rarity-rare { border-bottom: 4px solid #007bff; }
        .rarity-epic { border-bottom: 4px solid #a335ee; }
        .rarity-legendary { border-bottom: 4px solid #ffd700; box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.2); }

        /* Top HUD / Minimap */
        #top-hud { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 30px; box-sizing: border-box; }
        #alive-counter { background: #333; color: white; padding: 8px 20px; border-radius: 4px; font-weight: bold; border: 2px solid white; font-size: 20px; }
        #minimap-container { 
            width: 150px; height: 150px; background: rgba(0,0,0,0.7); 
            border: 2px solid #fff; border-radius: 5px; overflow: hidden; 
            position: relative; transform: skewX(-10deg);
        }
        #minimap { width: 500px; height: 500px; position: absolute; transition: transform 0.1s; }
        .map-dot { position: absolute; width: 8px; height: 8px; border-radius: 50%; }
        .map-player { background: yellow; border: 1px solid black; z-index: 10; }
        .map-bot { background: red; border: 1px solid white; z-index: 9; }

        /* Game Over */
        #game-over-screen {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 9999; pointer-events: auto; text-align: center;
        }
        #go-title { font-size: 120px; font-weight: 900; margin: 0; text-transform: uppercase; letter-spacing: 5px; font-style: italic; color: gold; text-shadow: 0 0 20px orange; }
        .btn { margin-top: 40px; padding: 20px 50px; font-size: 24px; cursor: pointer; background: #ffe600; color: black; border: none; font-weight: 900; text-transform: uppercase; transform: skewX(-10deg); transition: 0.2s;}
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        
        <div id="scope-overlay"></div>

        <div id="crosshair">
            <div class="ch-line ch-h"></div>
            <div class="ch-line ch-v"></div>
            <div class="ch-dot"></div>
        </div>

        <div id="top-hud">
            <div id="minimap-container">
                <div id="minimap"></div>
            </div>
            <div id="alive-counter">Alive: 30 | Elims: 0</div>
            <div id="storm-timer">STORM: 03:00</div>
        </div>

        <div id="mats-display">ðŸªµ <span id="wood-val">0</span></div>
        <div id="kill-feed"></div>
        <div id="interact-msg">Press E</div>

        <div id="status-area">
            <div id="jug-indicator">Shielding +3/s</div>
            <div class="bar-container">
                <div id="shield-bar" class="bar-fill"></div>
                <div class="bar-text">SHIELD <span id="shield-val">0</span></div>
            </div>
            <div class="bar-container">
                <div id="health-bar" class="bar-fill"></div>
                <div class="bar-text">HEALTH <span id="health-val">100</span></div>
            </div>
        </div>
        <div id="inventory">
            <div class="slot" id="slot-0"><span class="slot-key">1</span></div>
            <div class="slot" id="slot-1"><span class="slot-key">2</span></div>
            <div class="slot" id="slot-2"><span class="slot-key">3</span></div>
            <div class="slot" id="slot-3"><span class="slot-key">4</span></div>
        </div>
        
        <div id="storm-overlay"></div>
    </div>

    <div id="game-over-screen">
        <div id="go-title">ELIMINATED!</div>
        <div id="go-stats" style="font-size: 24px; margin-top: 10px; color: #aaa;"></div>
        <button class="btn" onclick="restartGame()">RETURN TO LOBBY</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // =========================================================================
        // === 1. CONSTANTS & DATA =================================================
        // =========================================================================
        
        const WORLD_SIZE = 500;
        const PLAYER_HEIGHT = 1.7;
        const GRAVITY = 30.0;
        const JUMP_FORCE = 12.0;
        const WALK_SPEED = 8.0;
        const SPRINT_SPEED = 15.0;
        const BOT_COUNT = 30;
        const MINIMAP_SCALE = WORLD_SIZE / 150; 
        const DAMAGE_PER_RARITY_STEP = 3;

        const RARITY = {
            COMMON:     { id: 0, name: 'Common',    color: '#b0b0b0', hex: 0xb0b0b0, scale: 0 },
            UNCOMMON:   { id: 1, name: 'Uncommon',  color: '#28a745', hex: 0x28a745, scale: 1 },
            RARE:       { id: 2, name: 'Rare',      color: '#007bff', hex: 0x007bff, scale: 2 },
            EPIC:       { id: 3, name: 'Epic',      color: '#a335ee', hex: 0xa335ee, scale: 3 },
            LEGENDARY:  { id: 4, name: 'Legendary', color: '#ffd700', hex: 0xffd700, scale: 4 }
        };

        const WEAPON_TYPES = {
            SMG:    { name: "Paced SMG",        dmg: 8,  headMul: 19/8,  range: 80,  rate: 0.333, mag: 80, auto: true,  icon: 'ðŸ–Šï¸', recoil: 0.05, scope: null },
            AR:     { name: "Assault Rifle",    dmg: 16, headMul: 22/16, range: 250, rate: 0.5,   mag: 65, auto: true,  icon: 'ðŸ”«', recoil: 0.02, scope: 'red_dot' },
            PUMP:   { name: "Pump Shotgun",     dmg: 13, headMul: 22/13, range: 40,  rate: 0.9,   mag: 10, auto: false, icon: 'ðŸ§¨', recoil: 0.2,  scope: null, pellets: 4 },
            SNIPER: { name: "Sniper Rifle",     dmg: 103,headMul: 200/103,range: 500, rate: 1.0,   mag: 3,  auto: false, icon: 'ðŸ”­', recoil: 0.5,  scope: 'sniper' },
            HR:     { name: "Heavy Rifle",      dmg: 22, headMul: 33/22, range: 150, rate: 0.666, mag: 40, auto: false, icon: 'ðŸ', recoil: 0.08, scope: 'heavy_zoom' }
        };

        const CONSUMABLES = {
            MINI: { name: "Small Shield", val: 25, type: 'shield', max: 50, icon: 'ðŸ›¡ï¸', time: 2000, color: 0x55aaff },
            BIG:  { name: "Shield Potion", val: 50, type: 'shield', max: 100,icon: 'âš—ï¸', time: 4000, color: 0x0000ff },
            MED:  { name: "Med Kit",       val: 100,type: 'health', max: 100,icon: 'ðŸ’Š', time: 8000, color: 0xff0000 },
            JUG:  { name: "Shield Jug",    val: 60, type: 'jug',    max: 100,icon: 'ðŸ¥›', time: 6000, color: 0x00ffee }
        };


        // =========================================================================
        // === 2. GLOBAL STATE VARIABLES (MUST BE AT THE TOP TO AVOID REFERENCE ERRORS)
        // =========================================================================
        
        let camera, scene, renderer, controls;
        let weaponCamera, weaponScene;
        let raycaster;
        const v3 = new THREE.Vector3(); // Reusable vector for calculations
        
        // Movement State
        let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, isSprinting=false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();

        // Player State
        let player = {
            health: 100,
            shield: 50, 
            wood: 0,
            inventory: [null, null, null, null], 
            selectedSlot: 0,
            isDead: false,
            isConsuming: false,
            inVehicle: false,
            eliminations: 0,
            jugTimeLeft: 0, 
        };

        // Combat State
        let isFiring = false; 
        let lastFireTime = 0;
        let isAds = false;
        let currentViewModel = null;
        let verticalRecoil = 0; 

        // World Objects
        let objects = []; 
        let bots = [];
        let chests = [];
        let lootItems = [];
        let buildings = [];
        let cars = [];
        let currentCar = null;

        // Storm
        let stormStartTime = Date.now();
        let stormRadius = WORLD_SIZE;
        let stormCenter = new THREE.Vector2(0,0);
        let stormRingMesh = null; 


        // =========================================================================
        // === 3. INITIALIZATION & SETUP ===========================================
        // =========================================================================

        init();
        animate(); // Start the loop immediately after setup

        function init() {
            // Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 400);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = PLAYER_HEIGHT;

            // Weapon Layer
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.autoClear = false;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 200; dirLight.shadow.camera.bottom = -200;
            dirLight.shadow.camera.left = -200; dirLight.shadow.camera.right = 200;
            scene.add(dirLight);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            document.addEventListener('click', () => {
                if(!player.isDead) controls.lock();
            });

            // Inputs
            setupInputs();

            // Generation
            raycaster = new THREE.Raycaster();
            generateTerrain();
            generatePOIs();
            spawnBots();
            spawnCars(); 
            createStormVisual();

            // Give initial loot (Common AR in Slot 0)
            addToInventory(generateWeapon('AR', RARITY.COMMON), 0);

            updateUI();
            updateInventoryUI();
        }

        function restartGame() {
            location.reload();
        }


        // =========================================================================
        // === 4. INPUTS & INTERACTION =============================================
        // =========================================================================
        function setupInputs() {
            const onKeyDown = (e) => {
                if(player.isDead) return;
                switch(e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': 
                        if(player.inVehicle) break;
                        if(canJump) { velocity.y += JUMP_FORCE; canJump=false; } 
                        break;
                    case 'ShiftLeft': isSprinting = true; break;
                    case 'Digit1': switchSlot(0); break;
                    case 'Digit2': switchSlot(1); break;
                    case 'Digit3': switchSlot(2); break;
                    case 'Digit4': switchSlot(3); break;
                    case 'KeyE': interact(); break;
                    case 'KeyQ': buildWall(); break;
                }
            };
            const onKeyUp = (e) => {
                switch(e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': isSprinting = false; break;
                }
            };
            const onMouseDown = (e) => {
                if(!controls.isLocked || player.isConsuming) return;
                if(e.button === 0) fireWeapon();
                if(e.button === 2) toggleAds(true);
            };
            const onMouseUp = (e) => {
                if(e.button === 0) stopFiring();
                if(e.button === 2) toggleAds(false);
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
        }

        function interact() {
            const pos = camera.position;
            
            // 1. Exit Car
            if(player.inVehicle) {
                player.inVehicle = false;
                currentCar = null;
                camera.position.y = getTerrainHeight(pos.x, pos.z) + PLAYER_HEIGHT; 
                controls.getObject().rotation.z = 0; 
                return;
            }

            // 2. Enter Car
            for(let c of cars) {
                if(c.mesh.position.distanceTo(pos) < 5) {
                    player.inVehicle = true;
                    currentCar = c;
                    return;
                }
            }

            // 3. Open Chests
            for(let i=chests.length-1; i>=0; i--) {
                const c = chests[i];
                if(c.position.distanceTo(pos) < 3) {
                    scene.remove(c);
                    chests.splice(i, 1);
                    spawnLoot(c.position.x-1, c.position.y, c.position.z);
                    spawnLoot(c.position.x+1, c.position.y, c.position.z);
                    spawnLoot(c.position.x, c.position.y, c.position.z+1);
                    return;
                }
            }

            // 4. Pick up Loot
            for(let i=lootItems.length-1; i>=0; i--) {
                const l = lootItems[i];
                if(l.position.distanceTo(pos) < 2.5) {
                    if(addToInventory(l.userData.data)) {
                        scene.remove(l);
                        lootItems.splice(i, 1);
                        return;
                    }
                }
            }
        }


        // =========================================================================
        // === 5. WORLD GENERATION & PHYSICS HELPERS ===============================
        // =========================================================================
        
        function getTerrainHeight(x, z) {
            let y = (Math.sin(x/40)*6 + Math.cos(z/40)*6) + (Math.sin(x/15 + z/15)*2);
            if(Math.abs(x) > 180 || Math.abs(z) > 180) y += 15;
            return y;
        }

        function generateTerrain() {
            const geometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 128, 128);
            geometry.rotateX(-Math.PI / 2);
            const pos = geometry.attributes.position;
            const colors = [];

            for(let i=0; i<pos.count; i++) {
                const x = pos.getX(i);
                const z = pos.getZ(i);
                let y = getTerrainHeight(x, z) + (Math.abs(x) > 180 || Math.abs(z) > 180 ? Math.random()*5 : 0);
                pos.setY(i, y);
                if(y > 14) colors.push(1,1,1);
                else if(y > 8) colors.push(0.5, 0.4, 0.3);
                else colors.push(0.1, 0.5 + Math.random()*0.1, 0.1);
            }
            
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
            geometry.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9 });
            const mesh = new THREE.Mesh(geometry, mat);
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh);
        }

        function generatePOIs() {
            // Simplified POI generation for conciseness
            createCity(-60, -60);
            createForest(60, 60);
            createOutpost(0, 80);
        }

        function createCity(ox, oz) {
            for(let i=0; i<5; i++) {
                for(let j=0; j<5; j++) {
                    if(Math.random() > 0.3) {
                        const h = 15 + Math.random()*25;
                        const w = 10;
                        const mat = new THREE.MeshStandardMaterial({color: 0x555555});
                        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), mat);
                        mesh.position.set(ox + i*18, h/2 + getTerrainHeight(ox+i*18, oz+j*18), oz + j*18);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        scene.add(mesh);
                        objects.push(mesh);
                    }
                }
            }
            spawnChest(ox, getTerrainHeight(ox,oz)+1, oz);
            spawnChest(ox+20, getTerrainHeight(ox+20,oz+20)+1, oz+20);
        }

        function createForest(ox, oz) {
            for(let i=0; i<30; i++) {
                const x = ox + (Math.random()-0.5)*80;
                const z = oz + (Math.random()-0.5)*80;
                const y = getTerrainHeight(x,z);
                
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.8,5), new THREE.MeshStandardMaterial({color:0x8B4513}));
                trunk.position.set(x, y+2.5, z);
                scene.add(trunk);
                objects.push(trunk);
                
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(4,8,8), new THREE.MeshStandardMaterial({color:0x228B22}));
                leaves.position.set(x, y+7, z);
                scene.add(leaves);
            }
            spawnChest(ox, getTerrainHeight(ox,oz)+1, oz);
        }

        function createOutpost(x, z) {
            const h = getTerrainHeight(x,z);
            const base = new THREE.Mesh(new THREE.BoxGeometry(20, 2, 20), new THREE.MeshStandardMaterial({color: 0x333333}));
            base.position.set(x, h+1, z);
            scene.add(base);
            objects.push(base);
            spawnChest(x, h+2.5, z);
        }


        // =========================================================================
        // === 6. CARS, LOOT, & INVENTORY ==========================================
        // =========================================================================
        
        function spawnCars() {
            const carGeo = new THREE.BoxGeometry(4, 1.5, 6);
            const carMat = new THREE.MeshStandardMaterial({ color: 0xff3300 });
            
            for(let i=0; i<3; i++) { 
                const carMesh = new THREE.Mesh(carGeo, carMat);
                const cx = (Math.random()-0.5)*100;
                const cz = (Math.random()-0.5)*100;
                carMesh.position.set(cx, getTerrainHeight(cx,cz)+1, cz);
                carMesh.castShadow = true;
                
                const wGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5);
                const wMat = new THREE.MeshBasicMaterial({color:0x000000});
                const positions = [[-2.1, -0.5, -2], [2.1, -0.5, -2], [-2.1, -0.5, 2], [2.1, -0.5, 2]];
                positions.forEach(p => {
                    const w = new THREE.Mesh(wGeo, wMat);
                    w.rotation.z = Math.PI/2;
                    w.position.set(...p);
                    carMesh.add(w);
                });

                scene.add(carMesh);
                cars.push({ mesh: carMesh, speed: 0, ry: 0 });
            }
        }

        function spawnChest(x, y, z) {
            const geo = new THREE.BoxGeometry(1.5, 1, 1);
            const mat = new THREE.MeshStandardMaterial({color: 0xFFD700, roughness: 0.3});
            const chest = new THREE.Mesh(geo, mat);
            chest.position.set(x, y, z);
            chest.userData = { type: 'chest' };
            scene.add(chest);
            chests.push(chest);
        }

        function generateRandomItem() {
            const r = Math.random();
            let rarity = RARITY.COMMON;
            if(r>0.95) rarity=RARITY.LEGENDARY;
            else if(r>0.85) rarity=RARITY.EPIC;
            else if(r>0.65) rarity=RARITY.RARE;
            else if(r>0.40) rarity=RARITY.UNCOMMON;

            if(Math.random() < 0.35) {
                const types = Object.values(CONSUMABLES);
                const type = types[Math.floor(Math.random() * types.length)];
                return { category: 'consumable', ...type, count: 1, id: Math.random(), rarity: rarity };
            } else {
                const types = Object.keys(WEAPON_TYPES);
                const baseKey = types[Math.floor(Math.random() * types.length)];
                return generateWeapon(baseKey, rarity);
            }
        }
        
        function spawnLoot(x, y, z, fixedItem = null) {
            const item = fixedItem || generateRandomItem();
            const group = new THREE.Group();
            
            const glow = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.1, 10, 8), 
                new THREE.MeshBasicMaterial({ color: item.rarity?.hex || item.color, transparent: true, opacity: 0.4 })
            );
            glow.position.y = 5;
            group.add(glow);

            const box = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshBasicMaterial({color: item.rarity?.hex || item.color}));
            box.position.y = 0.5;
            box.userData = { spin: true };
            group.add(box);

            group.position.set(x, y, z);
            group.userData = { type: 'loot', data: item };
            scene.add(group);
            lootItems.push(group);
        }

        function addToInventory(item, slot = -1) {
            if (slot > -1 && player.inventory[slot] === null) {
                player.inventory[slot] = item;
                updateInventoryUI();
                if(slot === player.selectedSlot) switchSlot(slot);
                return true;
            }
            
            for(let i=0; i<player.inventory.length; i++) {
                if(player.inventory[i] == null) {
                    player.inventory[i] = item;
                    updateInventoryUI();
                    if(i === player.selectedSlot) switchSlot(i);
                    return true;
                }
            }
            return false;
        }

        function switchSlot(index) {
            player.selectedSlot = index;
            document.querySelectorAll('.slot').forEach((el, i) => {
                el.classList.toggle('active', i === index);
            });
            
            const item = player.inventory[index];
            if(item && item.category === 'weapon') {
                buildWeaponModel(item);
                toggleAds(isAds); // Re-apply ADS if active
            } else {
                if(currentViewModel) {
                    weaponScene.remove(currentViewModel);
                    currentViewModel = null;
                }
                toggleAds(false); // Force off ADS if switching away from weapon
            }
        }


        // =========================================================================
        // === 7. WEAPON & COMBAT LOGIC ============================================
        // =========================================================================

        function generateWeapon(baseKey, rarity) {
            const base = WEAPON_TYPES[baseKey];
            const bonusDamage = rarity.scale * DAMAGE_PER_RARITY_STEP;
            const bodyDamage = base.dmg + bonusDamage;
            const headshotDamage = Math.round(bodyDamage * base.headMul);

            return {
                category: 'weapon',
                ...base,
                rarity: rarity,
                baseDamage: bodyDamage,
                headDamage: headshotDamage,
                currentAmmo: base.mag,
                id: Math.random()
            };
        }

        function buildWeaponModel(item) {
            if(currentViewModel) weaponScene.remove(currentViewModel);
            
            const group = new THREE.Group();
            const col = item.rarity.hex;
            const mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.3, metalness: 0.5 });
            const black = new THREE.MeshStandardMaterial({ color: 0x111111 });

            // Proceedural Parts
            const type = item.name;
            const length = type.includes("Sniper") ? 0.8 : type.includes("Rifle") ? 0.6 : 0.4;
            
            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, length), mat); 
            group.add(body);
            
            // Mag
            if (!type.includes("Shotgun") && !type.includes("Sniper")) {
                const mag = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.2, 0.1), black); 
                mag.position.x = 0.05; mag.position.y = -0.15;
                group.add(mag);
            }
            
            // Barrel
            const bLength = length + 0.3;
            const b = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03, bLength), black);
            b.rotation.x = -Math.PI/2; b.position.z = -bLength/2;
            group.add(b);

            // Scope (Visual only)
            if (item.scope) {
                const scopeGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.3);
                const scope = new THREE.Mesh(scopeGeo, black);
                scope.rotation.x = -Math.PI/2; scope.position.y = 0.12; scope.position.z = -0.1;
                group.add(scope);
            }

            // Default Pos (Held)
            group.position.set(0.3, -0.3, -0.5);
            weaponScene.add(group);
            currentViewModel = group;
        }

        function processShooting(time) {
            const item = player.inventory[player.selectedSlot];
            if(!item || item.category !== 'weapon' || !isFiring) return;
            if(player.isConsuming || player.inVehicle) return;

            if(time - lastFireTime < item.rate * 1000) return;
            
            if(!item.auto) isFiring = false; 

            lastFireTime = time;

            // Recoil
            const recoilAmount = item.recoil * (isAds ? 0.2 : 1.0) * 0.01; 
            verticalRecoil += recoilAmount;

            // Visual Kickback
            if(currentViewModel) {
                currentViewModel.position.z += 0.15 * (item.recoil);
                currentViewModel.rotation.x += 0.05 * (item.recoil);
            }

            const spread = isAds ? item.recoil * 0.005 : item.recoil * 0.01;
            const numShots = item.pellets || 1;
            
            for(let i=0; i<numShots; i++) {
                const x = (Math.random()-0.5) * spread;
                const y = (Math.random()-0.5) * spread;

                // Adjust raycaster direction by current recoil (verticalRecoil is inverted for screen space to world space)
                raycaster.setFromCamera(new THREE.Vector2(x, y - verticalRecoil), camera);
                
                const botMeshes = bots.map(b => b.mesh);
                const wallMeshes = buildings.map(b => b.mesh);
                const hits = raycaster.intersectObjects([...botMeshes, ...wallMeshes]);
                
                if(hits.length > 0) {
                    const hit = hits[0];
                    if(hit.distance > item.range) continue;
                    
                    const bot = bots.find(b => b.mesh === hit.object);
                    const wall = buildings.find(b => b.mesh === hit.object);

                    if(bot) {
                        const isHead = hit.point.y > bot.mesh.position.y + 0.6;
                        const dmg = isHead ? item.headDamage : item.baseDamage;
                        
                        bot.health -= dmg;
                        displayDamageNumber(dmg, hit.point, isHead);
                        
                        if(bot.health <= 0) killBot(bot);
                    } else if (wall) {
                        wall.hits = (wall.hits || 0) + 1;
                        if (wall.hits >= 5) destroyWall(wall);
                    }
                }
            }
        }

        function displayDamageNumber(damage, worldPosition, isHeadshot) {
            v3.copy(worldPosition);
            v3.project(camera);

            const x = (v3.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-v3.y * 0.5 + 0.5) * window.innerHeight;

            const el = document.createElement('div');
            el.className = 'damage-number' + (isHeadshot ? ' headshot' : '');
            el.innerText = Math.round(damage);
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;

            document.getElementById('ui-layer').appendChild(el);
            setTimeout(() => el.remove(), 1500);
        }

        // =========================================================================
        // === 8. HEALING, AI & BUILD LOGIC ========================================
        // =========================================================================

        function useConsumable(item) {
            if(player.isConsuming) return;
            
            if (item.type === 'jug' && player.shield >= 100) return;
            if (item.type === 'shield' && player.shield >= item.max) return;
            if (item.type === 'health' && player.health >= 100) return;

            player.isConsuming = true;
            
            const msg = document.getElementById('interact-msg');
            msg.style.display = 'block';
            msg.innerText = `Using ${item.name}...`;

            setTimeout(() => {
                if(player.isDead) return;
                
                if(item.type === 'shield') player.shield = Math.min(player.shield + item.val, item.max);
                else if (item.type === 'health') player.health = Math.min(player.health + item.val, 100);
                else if (item.type === 'jug') player.jugTimeLeft = 20; 

                if (item.type !== 'jug') player.inventory[player.selectedSlot] = null;
                
                updateInventoryUI();
                updateUI();
                
                player.isConsuming = false;
                msg.style.display = 'none';
            }, item.time);
        }

        function buildWall() {
            if(player.wood < 10 || player.inVehicle) return;
            player.wood -= 10;
            updateUI();

            const geo = new THREE.BoxGeometry(4, 3, 0.2);
            const mat = new THREE.MeshStandardMaterial({color: 0x8B4513});
            const wallMesh = new THREE.Mesh(geo, mat);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const pos = camera.position.clone().add(dir.multiplyScalar(3));
            
            wallMesh.position.set(pos.x, getTerrainHeight(pos.x, pos.z) + 1.5, pos.z);
            wallMesh.lookAt(camera.position.x, wallMesh.position.y, camera.position.z);
            
            scene.add(wallMesh);
            buildings.push({ mesh: wallMesh, hits: 0 });
            objects.push(wallMesh);
        }
        
        function destroyWall(wall) {
            scene.remove(wall.mesh);
            objects = objects.filter(o => o !== wall.mesh);
            buildings = buildings.filter(b => b !== wall);
        }

        function damagePlayer(amt, isBotDamage, source) {
            if(player.isDead) return;

            if (isBotDamage && player.inVehicle && currentCar) {
                // Car collision damage (not implemented for simplicity, but here if needed)
                return;
            }

            if(player.shield > 0) {
                const damageToHealth = Math.max(0, amt - player.shield);
                player.shield = Math.max(0, player.shield - amt);
                player.health -= damageToHealth;
            } else {
                player.health -= amt;
            }

            if(isBotDamage) {
                document.body.style.boxShadow = "inset 0 0 50px red";
                setTimeout(() => document.body.style.boxShadow = "none", 100);
            }

            updateUI();

            if(player.health <= 0) {
                player.health = 0;
                player.isDead = true;
                controls.unlock();
                gameOver(false); 
            }
        }


        // =========================================================================
        // === 9. MAIN ANIMATION LOOP (animate) ====================================
        // =========================================================================

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if(player.isDead) {
                renderer.render(scene, camera);
                return;
            }

            updateStorm(delta);
            updateShieldJug(delta);

            if(controls.isLocked) {
                if (player.inVehicle && currentCar) {
                    // Car Physics (Movement + Running over NPCs)
                    const speed = 25.0;
                    if(moveForward) currentCar.mesh.translateZ(speed * delta);
                    if(moveBackward) currentCar.mesh.translateZ(-speed * delta);
                    if(moveLeft) currentCar.mesh.rotateY(2.0 * delta);
                    if(moveRight) currentCar.mesh.rotateY(-2.0 * delta);

                    // Car-Bot Collision Check (100 Damage requested)
                    bots.forEach(bot => {
                        if (bot.mesh.position.distanceTo(currentCar.mesh.position) < 4 && currentCar.mesh.speed > 5) {
                            bot.health -= 100;
                            if (bot.health <= 0) killBot(bot);
                        }
                    });

                    // Camera Follow
                    const offset = new THREE.Vector3(0, 5, -10);
                    offset.applyQuaternion(currentCar.mesh.quaternion);
                    camera.position.copy(currentCar.mesh.position).add(offset);
                    camera.lookAt(currentCar.mesh.position);
                    
                    const h = getTerrainHeight(currentCar.mesh.position.x, currentCar.mesh.position.z);
                    currentCar.mesh.position.y = h + 1;

                } else {
                    // Player Movement & Gravity
                    velocity.x -= velocity.x * 10.0 * delta;
                    velocity.z -= velocity.z * 10.0 * delta;
                    velocity.y -= GRAVITY * delta;
                    
                    direction.z = Number(moveForward) - Number(moveBackward);
                    direction.x = Number(moveRight) - Number(moveLeft);
                    direction.normalize();

                    const s = isSprinting ? SPRINT_SPEED : WALK_SPEED;
                    if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta * (s/10);
                    if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta * (s/10);

                    controls.moveRight(-velocity.x * delta);
                    controls.moveForward(-velocity.z * delta);

                    // Recoil Recovery
                    if(!isFiring) verticalRecoil *= 0.99; 
                    if(verticalRecoil < 0.001) verticalRecoil = 0; 

                    // Weapon Sway/Recoil Reset
                    if(currentViewModel) {
                        const tx = isAds ? 0 : 0.3;
                        const ty = isAds ? -0.20 : -0.3;
                        const tz = isAds ? -0.4 : -0.5;
                        
                        const mx = Math.sin(time*0.01) * (velocity.length()>1 ? 0.02 : 0.002);
                        const my = Math.cos(time*0.01) * (velocity.length()>1 ? 0.02 : 0.002);

                        currentViewModel.position.x += (tx + mx - currentViewModel.position.x) * 10 * delta;
                        currentViewModel.position.y += (ty + my - currentViewModel.position.y) * 10 * delta;
                        currentViewModel.position.z += (tz - currentViewModel.position.z) * 10 * delta;
                        
                        currentViewModel.rotation.x *= 0.8; 
                    }

                    // Ground Collision & Map Boundary Check
                    const h = getTerrainHeight(camera.position.x, camera.position.z);
                    if(camera.position.y < h + PLAYER_HEIGHT) {
                        velocity.y = 0;
                        camera.position.y = h + PLAYER_HEIGHT;
                        canJump = true;
                    }
                    
                    const boundary = WORLD_SIZE / 2;
                    camera.position.x = Math.max(-boundary, Math.min(boundary, camera.position.x));
                    camera.position.z = Math.max(-boundary, Math.min(boundary, camera.position.z));
                }
            }
            
            processShooting(time);
            updateBots(delta, time);
            updateMinimap();

            // Rendering
            renderer.clear();
            renderer.render(scene, camera);
            if(!player.inVehicle) {
                renderer.clearDepth();
                renderer.render(weaponScene, weaponCamera);
            }
        }

        // --- Other Update Functions ---

        function updateStorm(delta) {
            // (Same storm update logic from V2/V3)
            const elapsed = (Date.now() - stormStartTime) / 1000;
            const stormTotal = 180; 
            const newRadius = THREE.MathUtils.lerp(WORLD_SIZE, 50, Math.min(elapsed/stormTotal, 1));
            stormRadius = newRadius;
            
            if (stormRingMesh) {
                stormRingMesh.scale.x = stormRadius / (WORLD_SIZE / 2);
                stormRingMesh.scale.z = stormRadius / (WORLD_SIZE / 2);
            }
            
            const mins = Math.floor(Math.max(0, stormTotal - elapsed) / 60);
            const secs = Math.floor(Math.max(0, stormTotal - elapsed) % 60);
            document.getElementById('storm-timer').innerText = `STORM: ${mins}:${secs<10?'0':''}${secs}`;
            
            const pDist = new THREE.Vector2(camera.position.x, camera.position.z).distanceTo(stormCenter);
            const overlay = document.getElementById('storm-overlay');
            
            if(pDist > stormRadius) {
                overlay.style.display = 'block';
                if(Math.floor(elapsed*10) % 10 === 0 && Math.random() < 0.1) {
                   damagePlayer(1, false, "Storm"); 
                }
            } else {
                overlay.style.display = 'none';
            }
        }

        function updateShieldJug(delta) {
            const jugEl = document.getElementById('jug-indicator');
            if (player.jugTimeLeft > 0) {
                player.jugTimeLeft -= delta;
                player.shield = Math.min(player.shield + (3 * delta), 100);
                jugEl.style.display = 'block';
                if (player.jugTimeLeft <= 0) {
                    player.jugTimeLeft = 0;
                    jugEl.style.display = 'none';
                }
                updateUI();
            }
        }

        function updateBots(delta, now) {
            // (Same bot logic from V3 with wall breaking and damage values)
            const pPos = camera.position;
            const pDir = new THREE.Vector3(pPos.x, pPos.y - PLAYER_HEIGHT/2, pPos.z);
            
            bots.forEach(bot => {
                if(bot.health <= 0) return;
                
                const dist = bot.mesh.position.distanceTo(pPos);
                
                // Gravity
                const floorY = getTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                if(bot.mesh.position.y > floorY + 0.9) {
                    bot.mesh.position.y -= GRAVITY * delta * 0.5;
                } else {
                    bot.mesh.position.y = floorY + 0.9;
                }

                if(dist < 50) {
                    bot.mesh.lookAt(pPos.x, bot.mesh.position.y, pPos.z);
                    if(dist > 10) bot.mesh.translateZ(3 * delta);

                    if(now - bot.lastShot > 1500) { 
                        bot.lastShot = now;
                        
                        raycaster.set(bot.mesh.position, pDir.clone().sub(bot.mesh.position).normalize());
                        const wallCheck = raycaster.intersectObjects(buildings.map(b=>b.mesh));

                        if (wallCheck.length > 0 && wallCheck[0].distance < dist) {
                            bot.wallTarget = buildings.find(b => b.mesh === wallCheck[0].object);
                            if (bot.wallTarget) {
                                bot.wallTarget.hits = (bot.wallTarget.hits || 0) + 1;
                                if (bot.wallTarget.hits >= 5) destroyWall(bot.wallTarget);
                            }
                        } else {
                            if(Math.random() < 0.4) {
                                const isHead = Math.random() < 0.1;
                                damagePlayer(isHead ? 9 : 4, true, "Bot"); 
                            }
                        }
                    }
                } else {
                    if(now > bot.nextMove) {
                        bot.mesh.rotation.y = Math.random() * Math.PI * 2;
                        bot.nextMove = now + 2000 + Math.random()*3000;
                    }
                    bot.mesh.translateZ(2 * delta);
                }
            });
        }
        
        // --- UI & Game State Helpers ---

        function updateUI() {
            document.getElementById('health-val').innerText = Math.ceil(player.health);
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('shield-val').innerText = Math.ceil(player.shield);
            document.getElementById('shield-bar').style.width = player.shield + '%';
            document.getElementById('wood-val').innerText = player.wood;
            document.getElementById('alive-counter').innerText = `Alive: ${bots.length + 1} | Elims: ${player.eliminations}`;
        }

        function updateInventoryUI() {
            player.inventory.forEach((item, i) => {
                const el = document.getElementById(`slot-${i}`);
                if(item) {
                    const rClass = item.rarity ? `rarity-${item.rarity.name.toLowerCase()}` : '';
                    el.className = `slot ${rClass} ${i===player.selectedSlot ? 'active' : ''}`;
                    el.innerHTML = `<span class="slot-key">${i+1}</span>
                                    <div class="slot-icon">${item.icon}</div>
                                    <div class="slot-name">${item.name}</div>`;
                } else {
                    el.className = `slot ${i===player.selectedSlot ? 'active' : ''}`;
                    el.innerHTML = `<span class="slot-key">${i+1}</span>`;
                }
            });
        }
        
        function updateMinimap() {
            // (Same minimap logic from V3)
            const mapContainer = document.getElementById('minimap');
            const p = camera.position;
            const mapX = (p.x / MINIMAP_SCALE) + 150/2;
            const mapY = (p.z / MINIMAP_SCALE) + 150/2;
            mapContainer.style.transform = `translate(${-mapX + 150/2}px, ${-mapY + 150/2}px) skewX(10deg)`;
            mapContainer.innerHTML = ''; 

            const pDot = document.createElement('div');
            pDot.className = 'map-dot map-player';
            pDot.style.left = `${p.x / MINIMAP_SCALE + WORLD_SIZE / MINIMAP_SCALE / 2}px`;
            pDot.style.top = `${p.z / MINIMAP_SCALE + WORLD_SIZE / MINIMAP_SCALE / 2}px`;
            pDot.style.backgroundColor = player.shield > 0 ? '#007bff' : 'yellow';
            mapContainer.appendChild(pDot);

            bots.forEach(bot => {
                const bDot = document.createElement('div');
                bDot.className = 'map-dot map-bot';
                bDot.style.left = `${bot.mesh.position.x / MINIMAP_SCALE + WORLD_SIZE / MINIMAP_SCALE / 2}px`;
                bDot.style.top = `${bot.mesh.position.z / MINIMAP_SCALE + WORLD_SIZE / MINIMAP_SCALE / 2}px`;
                mapContainer.appendChild(bDot);
            });
            document.getElementById('alive-counter').innerText = `Alive: ${bots.length + 1} | Elims: ${player.eliminations}`;
        }

        function spawnBots() {
            const geo = new THREE.CapsuleGeometry(0.6, 1.8, 4, 8);
            const mat = new THREE.MeshStandardMaterial({color: 0xaa3333});
            
            for(let i=0; i<BOT_COUNT; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                const x = (Math.random()-0.5)*WORLD_SIZE*0.7;
                const z = (Math.random()-0.5)*WORLD_SIZE*0.7;
                mesh.position.set(x, 10, z);
                scene.add(mesh);
                
                bots.push({
                    mesh: mesh,
                    health: 100,
                    state: 'idle',
                    nextMove: 0,
                    lastShot: 0,
                    wallTarget: null
                });
            }
        }
        
        function killBot(bot) {
            scene.remove(bot.mesh);
            const index = bots.indexOf(bot);
            if(index > -1) bots.splice(index, 1);
            
            player.eliminations++;
            player.wood += 50;
            spawnLoot(bot.mesh.position.x, bot.mesh.position.y, bot.mesh.position.z);

            updateUI();
            checkWin();
        }

        function checkWin() {
            if(bots.length === 0) {
                gameOver(true); 
            }
        }

        function gameOver(victory) {
            player.isDead = true;
            controls.unlock();
            const screen = document.getElementById('game-over-screen');
            const title = document.getElementById('go-title');

            if (victory) {
                title.innerText = "VICTORY ROYALE!";
                title.style.color = "gold";
                document.getElementById('go-stats').innerText = `Eliminations: ${player.eliminations}`;
            } else {
                title.innerText = "ELIMINATED";
                title.style.color = "red";
                document.getElementById('go-stats').innerText = `Eliminations: ${player.eliminations}`;
            }
            screen.style.display = 'flex';
        }

        window.restartGame = restartGame; 
        
        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            weaponCamera.aspect = window.innerWidth / window.innerHeight;
            weaponCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
