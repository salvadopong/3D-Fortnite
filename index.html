<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Battle Royale V2 - Advanced</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; background: #000; }
        
        /* --- UI LAYER --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Crosshair */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px; 
            transform: translate(-50%, -50%);
        }
        .crosshair-line { position: absolute; background: white; box-shadow: 0 0 2px black; }
        .ch-h { width: 100%; height: 2px; top: 50%; left: 0; margin-top: -1px; }
        .ch-v { height: 100%; width: 2px; left: 50%; top: 0; margin-left: -1px; }

        /* HUD Stats */
        #status-area { position: absolute; bottom: 30px; left: 30px; display: flex; flex-direction: column; gap: 10px; width: 300px; }
        .bar-container { width: 100%; height: 25px; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.3); transform: skewX(-15deg); overflow: hidden; position: relative; }
        .bar-fill { height: 100%; transition: width 0.2s; }
        #shield-bar { background: linear-gradient(90deg, #007bff, #00d4ff); width: 0%; }
        #health-bar { background: linear-gradient(90deg, #28a745, #7aff94); width: 100%; }
        .bar-text { position: absolute; top: 0; left: 10px; color: white; font-weight: 900; font-size: 14px; line-height: 25px; text-shadow: 1px 1px 0 #000; transform: skewX(15deg); }

        /* Inventory */
        #inventory { 
            position: absolute; bottom: 30px; right: 30px; 
            display: flex; gap: 8px; 
        }
        .slot { 
            width: 70px; height: 70px; 
            background: rgba(20, 20, 20, 0.8); 
            border: 2px solid #555; 
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            color: white; font-size: 10px; text-align: center;
            position: relative;
            transition: transform 0.1s;
        }
        .slot.active { border-color: #ffd700; transform: scale(1.1); z-index: 2; box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
        .slot-key { position: absolute; top: 2px; left: 4px; font-weight: bold; color: #aaa; }
        .slot-ammo { position: absolute; bottom: 2px; right: 4px; font-weight: bold; color: #fff; font-size: 14px; }
        .slot-icon { font-size: 24px; margin-bottom: 5px; }
        
        /* Rarity Borders */
        .rarity-common { border-bottom: 4px solid #b0b0b0; }
        .rarity-uncommon { border-bottom: 4px solid #28a745; }
        .rarity-rare { border-bottom: 4px solid #007bff; }
        .rarity-epic { border-bottom: 4px solid #a335ee; }
        .rarity-legendary { border-bottom: 4px solid #ffd700; }

        /* Interaction Prompt */
        #interact-msg {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7); color: white; padding: 10px 20px;
            font-size: 18px; border-radius: 5px; display: none;
            border: 1px solid white;
        }
        
        /* Storm & Killfeed */
        #top-hud { position: absolute; top: 20px; left: 0; width: 100%; display: flex; justify-content: center; }
        #storm-timer { background: #333; color: white; padding: 5px 15px; border-radius: 20px; font-weight: bold; border: 2px solid #a335ee; }
        #kill-feed { position: absolute; top: 50px; left: 20px; color: white; font-family: monospace; font-size: 14px; text-shadow: 1px 1px 0 #000; }
        #mats-display { position: absolute; right: 30px; top: 110px; color: white; font-size: 20px; font-weight: bold; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px;}

        /* Game Over */
        #game-over-screen {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 999; pointer-events: auto;
        }
        #go-title { font-size: 80px; font-weight: 900; margin: 0; text-transform: uppercase; letter-spacing: 5px; }
        .btn { margin-top: 30px; padding: 15px 40px; font-size: 24px; cursor: pointer; background: #007bff; color: white; border: none; font-weight: bold; }
        .btn:hover { background: #0056b3; }

        #storm-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(148, 0, 211, 0.2);
            box-shadow: inset 0 0 150px rgba(148, 0, 211, 0.6);
            display: none; pointer-events: none; z-index: 1;
        }

        /* Hit Marker */
        #hit-marker {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%) rotate(45deg);
            border: 2px solid transparent;
            border-top-color: white; border-right-color: white;
            opacity: 0; transition: opacity 0.1s;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="crosshair">
            <div class="crosshair-line ch-h"></div>
            <div class="crosshair-line ch-v"></div>
        </div>
        <div id="hit-marker"></div>

        <div id="top-hud">
            <div id="storm-timer">STORM: 02:00</div>
        </div>

        <div id="mats-display">ðŸªµ <span id="wood-val">0</span></div>

        <div id="kill-feed"></div>

        <div id="interact-msg">Press E to Open Chest</div>

        <div id="status-area">
            <div class="bar-container">
                <div id="shield-bar" class="bar-fill"></div>
                <div class="bar-text">SHIELD <span id="shield-val">0</span></div>
            </div>
            <div class="bar-container">
                <div id="health-bar" class="bar-fill"></div>
                <div class="bar-text">HEALTH <span id="health-val">100</span></div>
            </div>
        </div>

        <div id="inventory">
            <div class="slot" id="slot-0"><span class="slot-key">1</span></div>
            <div class="slot" id="slot-1"><span class="slot-key">2</span></div>
            <div class="slot" id="slot-2"><span class="slot-key">3</span></div>
            <div class="slot" id="slot-3"><span class="slot-key">4</span></div>
            <div class="slot" id="slot-4"><span class="slot-key">5</span></div>
        </div>
        
        <div id="storm-overlay"></div>
    </div>

    <div id="game-over-screen">
        <div id="go-title">VICTORY ROYALE!</div>
        <div id="go-stats" style="font-size: 24px; margin-top: 10px;"></div>
        <button class="btn" onclick="location.reload()">RETURN TO LOBBY</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIGURATION ---
        const WORLD_SIZE = 500;
        const PLAYER_HEIGHT = 1.7;
        const GRAVITY = 30.0;
        const JUMP_FORCE = 12.0;
        const WALK_SPEED = 8.0;
        const SPRINT_SPEED = 14.0;
        const BOT_COUNT = 30;

        // Rarity Colors & Multipliers
        const RARITY = {
            COMMON:     { id: 0, name: 'Common',    color: '#b0b0b0', hex: 0xb0b0b0, mul: 1.0 },
            UNCOMMON:   { id: 1, name: 'Uncommon',  color: '#28a745', hex: 0x28a745, mul: 1.2 },
            RARE:       { id: 2, name: 'Rare',      color: '#007bff', hex: 0x007bff, mul: 1.4 },
            EPIC:       { id: 3, name: 'Epic',      color: '#a335ee', hex: 0xa335ee, mul: 1.6 },
            LEGENDARY:  { id: 4, name: 'Legendary', color: '#ffd700', hex: 0xffd700, mul: 2.0 }
        };

        // Weapon Definitions (Base Stats)
        const WEAPON_TYPES = {
            AR:     { name: "Assault Rifle",    dmg: 30, range: 250, fireRate: 0.15, spread: 0.02, auto: true, icon: 'ðŸ”«' },
            PUMP:   { name: "Pump Shotgun",     dmg: 90, range: 40,  fireRate: 0.9,  spread: 0.08, auto: false, pellets: 8, icon: 'ðŸ§¨' },
            SMG:    { name: "Paced SMG",        dmg: 18, range: 80,  fireRate: 0.08, spread: 0.05, auto: true, icon: 'ðŸ–Šï¸' },
            SNIPER: { name: "Eagle Eye",        dmg: 110,range: 500, fireRate: 1.5,  spread: 0.001,auto: false, icon: 'ðŸ”­' },
            RIFLE:  { name: "Heavy Rifle",      dmg: 45, range: 150, fireRate: 0.35, spread: 0.01, auto: false, icon: 'ðŸ' }
        };

        const CONSUMABLES = {
            MINI: { name: "Small Shield", val: 25, type: 'shield', max: 50, icon: 'ðŸ›¡ï¸', time: 2000, color: 0x55aaff },
            BIG:  { name: "Shield Potion", val: 50, type: 'shield', max: 100,icon: 'âš—ï¸', time: 4000, color: 0x0000ff },
            MED:  { name: "Med Kit",       val: 100,type: 'health', max: 100,icon: 'ðŸ’Š', time: 8000, color: 0xff0000 }
        };

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer, controls;
        let weaponCamera, weaponScene; // Second scene for weapon view model
        let raycaster;
        let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, isSprinting=false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let frameCount = 0;
        
        // Game State
        let player = {
            health: 100,
            shield: 0,
            wood: 0,
            inventory: [null, null, null, null, null], // 5 Slots
            selectedSlot: 0,
            isDead: false,
            isConsuming: false
        };

        // World Objects
        let terrainMesh;
        let objects = []; // Collidables
        let bots = [];
        let chests = [];
        let lootItems = [];
        let buildings = [];
        let projectiles = []; // For sniper trails

        // Storm
        let stormStartTime = Date.now(); // Initialized immediately
        let stormRadius = WORLD_SIZE;
        let stormCenter = new THREE.Vector2(0,0);

        // Weapon View Model
        let currentViewModel = null;
        let gunRecoil = 0;

        init();
        animate();

        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 300);

            // 2. Camera & Rendering
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = PLAYER_HEIGHT;

            // Weapon View Layer (Prevents clipping into walls)
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.autoClear = false;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // 3. Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            weaponScene.add(ambient.clone());

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            scene.add(dirLight);

            // Light for weapon view
            const weaponLight = new THREE.DirectionalLight(0xffffff, 1);
            weaponLight.position.set(0, 10, 0);
            weaponScene.add(weaponLight);

            // 4. Controls
            controls = new PointerLockControls(camera, document.body);
            document.addEventListener('click', () => {
                if(!player.isDead) controls.lock();
            });

            setupInputs();
            
            // 5. World Generation
            generateTerrain();
            generatePOIs();
            spawnBots();

            // 6. Init Player
            giveStarterLoot();
            updateUI();
            
            raycaster = new THREE.Raycaster();
        }

        // --- INPUT HANDLING ---
        function setupInputs() {
            const onKeyDown = (e) => {
                if(player.isDead) return;
                switch(e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if(canJump) velocity.y += JUMP_FORCE; canJump=false; break;
                    case 'ShiftLeft': isSprinting = true; break;
                    case 'Digit1': switchSlot(0); break;
                    case 'Digit2': switchSlot(1); break;
                    case 'Digit3': switchSlot(2); break;
                    case 'Digit4': switchSlot(3); break;
                    case 'Digit5': switchSlot(4); break;
                    case 'KeyR': reloadWeapon(); break;
                    case 'KeyE': tryInteract(); break;
                    case 'KeyQ': buildWall(); break;
                }
            };
            const onKeyUp = (e) => {
                switch(e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': isSprinting = false; break;
                }
            };
            const onMouseDown = (e) => {
                if(!controls.isLocked) return;
                if(e.button === 0) fireWeapon();
                if(e.button === 2) toggleAds(true);
            };
            const onMouseUp = (e) => {
                if(e.button === 0) stopFiring();
                if(e.button === 2) toggleAds(false);
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
        }

        // --- TERRAIN GENERATION ---
        function generateTerrain() {
            const geometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 128, 128);
            geometry.rotateX(-Math.PI / 2);
            
            const pos = geometry.attributes.position;
            const colors = [];
            const colorAttr = new THREE.BufferAttribute(new Float32Array(pos.count * 3), 3);

            for(let i=0; i<pos.count; i++) {
                const x = pos.getX(i);
                const z = pos.getZ(i);
                // Advanced noise-like height
                let y = (Math.sin(x/30)*4 + Math.cos(z/30)*4) + (Math.sin(x/10 + z/10)*2);
                if(Math.abs(x) > 150 || Math.abs(z) > 150) y += 10 + Math.random()*5; // Mountains at edge
                
                pos.setY(i, y);

                // Colors
                if(y > 12) colors.push(1,1,1); // Snow
                else if(y > 4) colors.push(0.4, 0.3, 0.2); // Dirt/Rock
                else colors.push(0.1, 0.6, 0.1); // Grass
            }
            
            geometry.setAttribute('color', colorAttr.copyArray(colors));
            geometry.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 1.0 });
            terrainMesh = new THREE.Mesh(geometry, mat);
            terrainMesh.receiveShadow = true;
            scene.add(terrainMesh);
            objects.push(terrainMesh);
        }

        function getTerrainHeight(x, z) {
            // Approximate height sync with generation logic to save raycasts
            // Note: For perfect collision, Raycasting down is better but expensive.
            // Using a simple Math approximation of the terrain generation:
            let y = (Math.sin(x/30)*4 + Math.cos(z/30)*4) + (Math.sin(x/10 + z/10)*2);
            if(Math.abs(x) > 150 || Math.abs(z) > 150) y += 10;
            return y;
        }

        // --- POIS & STRUCTURES ---
        function generatePOIs() {
            createTiltedTowers(-80, -80);
            createFlowerMeadow(60, 60);
            createOutpost(0, 80);
        }

        function createTiltedTowers(ox, oz) {
            for(let i=0; i<6; i++) {
                for(let j=0; j<6; j++) {
                    if(Math.random() > 0.4) {
                        const h = 10 + Math.random()*20;
                        const w = 8 + Math.random()*4;
                        createBuilding(ox + i*15, oz + j*15, w, h);
                    }
                }
            }
            // Add Chests
            spawnChest(ox+10, getTerrainHeight(ox+10, oz+10)+1, oz+10);
            spawnChest(ox+30, getTerrainHeight(ox+30, oz+30)+1, oz+30);
        }

        function createBuilding(x, z, w, h) {
            const geo = new THREE.BoxGeometry(w, h, w);
            const mat = new THREE.MeshStandardMaterial({color: 0x444444});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, h/2 + getTerrainHeight(x,z), z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh); // Collision
        }

        function createFlowerMeadow(ox, oz) {
            for(let i=0; i<40; i++) {
                const x = ox + (Math.random()-0.5)*60;
                const z = oz + (Math.random()-0.5)*60;
                const y = getTerrainHeight(x,z);
                
                // Tree
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.8,4), new THREE.MeshStandardMaterial({color:0x8B4513}));
                trunk.position.set(x, y+2, z);
                scene.add(trunk);
                objects.push(trunk);
                
                const top = new THREE.Mesh(new THREE.ConeGeometry(3,6,8), new THREE.MeshStandardMaterial({color:0x228B22}));
                top.position.set(x, y+6, z);
                scene.add(top);
            }
            spawnChest(ox, getTerrainHeight(ox,oz)+1, oz);
        }

        function createOutpost(x, z) {
            const h = getTerrainHeight(x, z);
            const floor = new THREE.Mesh(new THREE.BoxGeometry(20, 1, 20), new THREE.MeshStandardMaterial({color: 0x333333}));
            floor.position.set(x, h+0.5, z);
            scene.add(floor);
            spawnChest(x, h+2, z);
        }

        // --- INTERACTION & LOOT ---
        function spawnChest(x, y, z) {
            const geo = new THREE.BoxGeometry(1.5, 1, 1);
            const mat = new THREE.MeshStandardMaterial({color: 0xFFD700, roughness: 0.3, metalness: 0.8});
            const chest = new THREE.Mesh(geo, mat);
            chest.position.set(x, y, z);
            chest.userData = { type: 'chest' };
            scene.add(chest);
            chests.push(chest);
        }

        function spawnLoot(x, y, z, fixedItem = null) {
            const item = fixedItem || generateRandomItem();
            
            // Create Visual
            const group = new THREE.Group();
            
            // Glow pillar
            const glowGeo = new THREE.CylinderGeometry(0.2, 0.2, 20, 8);
            const glowMat = new THREE.MeshBasicMaterial({ color: item.rarity?.hex || item.color, transparent: true, opacity: 0.3 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.y = 10;
            group.add(glow);

            // Item representation (Simple box for now)
            const box = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({color: item.rarity?.hex || item.color}));
            box.position.y = 0.5;
            group.add(box);

            group.position.set(x, y, z);
            group.userData = { type: 'loot', data: item };
            scene.add(group);
            lootItems.push({ mesh: group, data: item });
        }

        function generateRandomItem() {
            const rand = Math.random();
            // 30% Consumable, 70% Weapon
            if (rand < 0.3) {
                const types = [CONSUMABLES.MINI, CONSUMABLES.BIG, CONSUMABLES.MED];
                const type = types[Math.floor(Math.random() * types.length)];
                return { category: 'consumable', ...type, count: 1 };
            } else {
                const keys = Object.keys(WEAPON_TYPES);
                const typeKey = keys[Math.floor(Math.random() * keys.length)];
                const base = WEAPON_TYPES[typeKey];
                
                // Rarity Roll
                const rRand = Math.random();
                let rarity = RARITY.COMMON;
                if(rRand > 0.95) rarity = RARITY.LEGENDARY;
                else if(rRand > 0.85) rarity = RARITY.EPIC;
                else if(rRand > 0.70) rarity = RARITY.RARE;
                else if(rRand > 0.40) rarity = RARITY.UNCOMMON;

                return {
                    category: 'weapon',
                    ...base,
                    rarity: rarity,
                    currentAmmo: 30, // simplified
                    damage: Math.floor(base.dmg * rarity.mul)
                };
            }
        }

        function tryInteract() {
            // Check chests or Loot
            const pos = camera.position;
            
            // Chests
            for(let i=chests.length-1; i>=0; i--) {
                const c = chests[i];
                if(c.position.distanceTo(pos) < 3) {
                    scene.remove(c);
                    chests.splice(i, 1);
                    // Spawn 3 items
                    spawnLoot(c.position.x - 1, c.position.y, c.position.z);
                    spawnLoot(c.position.x + 1, c.position.y, c.position.z);
                    spawnLoot(c.position.x, c.position.y, c.position.z + 1);
                    return;
                }
            }

            // Loot
            for(let i=lootItems.length-1; i>=0; i--) {
                const l = lootItems[i];
                if(l.mesh.position.distanceTo(pos) < 2.5) {
                    if(addToInventory(l.data)) {
                        scene.remove(l.mesh);
                        lootItems.splice(i, 1);
                        return;
                    }
                }
            }
        }

        // --- INVENTORY SYSTEM ---
        function addToInventory(item) {
            // Find empty slot
            for(let i=0; i<5; i++) {
                if(player.inventory[i] == null) {
                    player.inventory[i] = item;
                    updateInventoryUI();
                    if(i === player.selectedSlot) switchSlot(i);
                    return true;
                }
            }
            // If full, replace current slot? (Simple: Just return false for now)
            return false;
        }

        function switchSlot(index) {
            player.selectedSlot = index;
            document.querySelectorAll('.slot').forEach((el, i) => {
                el.classList.toggle('active', i === index);
            });
            
            // Construct Weapon Model
            const item = player.inventory[index];
            if(item && item.category === 'weapon') {
                buildWeaponModel(item);
            } else {
                if(currentViewModel) weaponScene.remove(currentViewModel);
                currentViewModel = null;
            }
        }

        function updateInventoryUI() {
            player.inventory.forEach((item, i) => {
                const el = document.getElementById(`slot-${i}`);
                if(item) {
                    el.className = `slot active rarity-${item.rarity?.name.toLowerCase() || 'common'}`;
                    el.innerHTML = `<span class="slot-key">${i+1}</span>
                                    <div class="slot-icon">${item.icon}</div>
                                    <div class="slot-name" style="font-size:8px;">${item.name}</div>`;
                } else {
                    el.className = 'slot';
                    el.innerHTML = `<span class="slot-key">${i+1}</span>`;
                }
            });
            switchSlot(player.selectedSlot); // Refresh selection highlight
        }

        function giveStarterLoot() {
            // Start with a Pickaxe (represented as null weapon logic) or Common Pistol?
            // Let's give a Common AR
            addToInventory({
                category: 'weapon',
                ...WEAPON_TYPES.AR,
                rarity: RARITY.COMMON,
                currentAmmo: 30,
                damage: 30
            });
        }

        // --- WEAPON RENDERING (PROCEDURAL) ---
        function buildWeaponModel(item) {
            if(currentViewModel) weaponScene.remove(currentViewModel);
            
            const group = new THREE.Group();
            const col = item.rarity ? item.rarity.hex : 0x555555;
            const mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.4, metalness: 0.6 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

            if(item.name.includes("Rifle") || item.name.includes("AR")) {
                // Stock
                const stock = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.4), darkMat);
                stock.position.set(0, -0.1, 0.3);
                group.add(stock);
                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.6), mat);
                group.add(body);
                // Barrel
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.6), darkMat);
                barrel.rotation.x = -Math.PI/2;
                barrel.position.set(0, 0.05, -0.5);
                group.add(barrel);
            } else if (item.name.includes("Shotgun")) {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.8), mat);
                group.add(body);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5), darkMat);
                barrel.rotation.x = -Math.PI/2;
                barrel.position.set(0, 0, -0.6);
                group.add(barrel);
            } else if (item.name.includes("Sniper")) {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.8), mat);
                group.add(body);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.0), darkMat);
                barrel.rotation.x = -Math.PI/2;
                barrel.position.set(0, 0, -0.8);
                group.add(barrel);
                // Scope
                const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.3), darkMat);
                scope.rotation.x = -Math.PI/2;
                scope.position.set(0, 0.12, 0);
                group.add(scope);
            } else {
                // Generic SMG
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.4), mat);
                group.add(body);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.3), darkMat);
                barrel.rotation.x = -Math.PI/2;
                barrel.position.set(0, 0, -0.3);
                group.add(barrel);
            }

            // Positioning relative to camera
            group.position.set(0.3, -0.3, -0.5);
            weaponScene.add(group);
            currentViewModel = group;
        }

        // --- COMBAT ---
        let isFiring = false;
        let lastFireTime = 0;
        let isAds = false;

        function toggleAds(active) {
            isAds = active;
            if(currentViewModel) {
                // Move gun to center or side
                const targetX = active ? 0 : 0.3;
                const targetY = active ? -0.21 : -0.3; // Align sights
                // We'll tween this in update
            }
        }

        function fireWeapon() {
            const item = player.inventory[player.selectedSlot];
            if(!item) return;

            if(item.category === 'consumable') {
                useConsumable(item);
                return;
            }

            isFiring = true;
        }

        function stopFiring() {
            isFiring = false;
        }

        function useConsumable(item) {
            if(player.isConsuming) return;
            // Prevent using shield if full etc
            if(item.type === 'shield' && player.shield >= item.max) return;
            if(item.type === 'health' && player.health >= 100) return;

            player.isConsuming = true;
            // Simple animation or timer
            const startTxt = document.getElementById('interact-msg');
            startTxt.style.display = 'block';
            startTxt.innerText = `Using ${item.name}...`;

            setTimeout(() => {
                if(player.isDead) return;
                
                if(item.type === 'shield') player.shield = Math.min(player.shield + item.val, item.max);
                if(item.type === 'health') player.health = Math.min(player.health + item.val, 100);
                
                // Remove item
                player.inventory[player.selectedSlot] = null;
                updateInventoryUI();
                updateUI();
                
                player.isConsuming = false;
                startTxt.style.display = 'none';
            }, item.time);
        }

        function processShooting(time) {
            const item = player.inventory[player.selectedSlot];
            if(!item || item.category !== 'weapon' || !isFiring) return;
            
            // Fire Rate Check
            if(time - lastFireTime < item.fireRate * 1000) return;
            
            // Trigger Pull (If semi-auto, stop firing until click again)
            if(!item.auto) isFiring = false; 

            lastFireTime = time;

            // Recoil Animation
            if(currentViewModel) {
                currentViewModel.position.z += 0.1; // kick back
                currentViewModel.rotation.x += 0.1; // kick up
            }

            // Raycast Shoot
            // Spread
            const spread = isAds ? item.spread / 2 : item.spread;
            const x = (Math.random()-0.5) * spread;
            const y = (Math.random()-0.5) * spread;

            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            
            // Check Hits
            // 1. Bots
            const botMeshes = bots.map(b => b.mesh);
            const hits = raycaster.intersectObjects([...botMeshes, ...buildings]);
            
            if(hits.length > 0) {
                const hit = hits[0];
                if(hit.distance < item.range) {
                    // Check if it's a bot
                    const bot = bots.find(b => b.mesh === hit.object);
                    if(bot) {
                        const isHead = hit.point.y > bot.mesh.position.y + 0.6;
                        const dmg = Math.floor(isHead ? item.damage * 2 : item.damage);
                        
                        bot.health -= dmg;
                        showHitMarker();
                        createHitEffect(hit.point, 0xff0000);

                        if(bot.health <= 0) {
                            killBot(bot);
                        }
                    } else {
                        // Wall hit
                        createHitEffect(hit.point, 0xaaaaaa);
                    }
                }
            }
        }

        function showHitMarker() {
            const el = document.getElementById('hit-marker');
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 100);
        }
        
        function createHitEffect(pos, color) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.1), new THREE.MeshBasicMaterial({color:color}));
            p.position.copy(pos);
            scene.add(p);
            setTimeout(()=>scene.remove(p), 500);
        }

        // --- BOTS & AI ---
        function spawnBots() {
            const geo = new THREE.CapsuleGeometry(0.6, 1.8, 4, 8);
            const mat = new THREE.MeshStandardMaterial({color: 0xaa3333});
            
            for(let i=0; i<BOT_COUNT; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                const x = (Math.random()-0.5)*WORLD_SIZE*0.8;
                const z = (Math.random()-0.5)*WORLD_SIZE*0.8;
                mesh.position.set(x, 10, z); // Drop from sky
                scene.add(mesh);
                
                bots.push({
                    mesh: mesh,
                    health: 100,
                    state: 'idle',
                    nextMove: 0,
                    lastShot: 0
                });
            }
        }

        function updateBots(delta, now) {
            const pPos = camera.position;
            
            bots.forEach(bot => {
                if(bot.health <= 0) return;
                
                const dist = bot.mesh.position.distanceTo(pPos);
                
                // Gravity
                const floorY = getTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                if(bot.mesh.position.y > floorY + 0.9) {
                    bot.mesh.position.y -= GRAVITY * delta * 0.5;
                } else {
                    bot.mesh.position.y = floorY + 0.9;
                }

                // AI Logic
                if(dist < 50) {
                    // Chase/Combat
                    bot.mesh.lookAt(pPos.x, bot.mesh.position.y, pPos.z);
                    // Move towards player slowly
                    if(dist > 10) bot.mesh.translateZ(3 * delta);

                    // Shoot
                    if(now - bot.lastShot > 1500) { // Fire every 1.5s
                        bot.lastShot = now;
                        // Accuracy Roll
                        if(Math.random() < 0.4) {
                            // Hit
                            const isHead = Math.random() < 0.1;
                            damagePlayer(isHead ? 16 : 7);
                            // Visual Tracer
                            createTracer(bot.mesh.position, pPos);
                        }
                    }
                } else {
                    // Wander
                    if(now > bot.nextMove) {
                        bot.mesh.rotation.y = Math.random() * Math.PI * 2;
                        bot.nextMove = now + 2000 + Math.random()*3000;
                    }
                    bot.mesh.translateZ(2 * delta);
                }
            });
        }

        function createTracer(start, end) {
            // Simple line
            const points = [start, end];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            setTimeout(() => scene.remove(line), 100);
        }

        function killBot(bot) {
            scene.remove(bot.mesh);
            const index = bots.indexOf(bot);
            if(index > -1) bots.splice(index, 1);
            
            // Log
            const feed = document.getElementById('kill-feed');
            const entry = document.createElement('div');
            entry.innerText = "You eliminated a bot";
            entry.style.color = "#ff4444";
            feed.prepend(entry);
            setTimeout(()=>entry.remove(), 4000);

            // Give Mats
            player.wood += 50;
            
            // Drop Loot
            spawnLoot(bot.mesh.position.x, bot.mesh.position.y, bot.mesh.position.z);

            updateUI();
            checkWin();
        }

        // --- PLAYER HEALTH & BUILDING ---
        function damagePlayer(amt) {
            if(player.isDead) return;

            // Shield first
            if(player.shield > 0) {
                if(player.shield >= amt) {
                    player.shield -= amt;
                } else {
                    const rem = amt - player.shield;
                    player.shield = 0;
                    player.health -= rem;
                }
            } else {
                player.health -= amt;
            }

            // Flash red
            document.body.style.boxShadow = "inset 0 0 50px red";
            setTimeout(() => document.body.style.boxShadow = "none", 100);

            updateUI();

            if(player.health <= 0) {
                player.health = 0;
                player.isDead = true;
                controls.unlock();
                document.getElementById('game-over-screen').style.display = 'flex';
                document.getElementById('go-title').innerText = "ELIMINATED";
                document.getElementById('go-title').style.color = "red";
                document.getElementById('go-stats').innerText = `Placed #${bots.length + 1}`;
            }
        }

        function buildWall() {
            if(player.wood < 10) return;
            player.wood -= 10;
            updateUI();

            const geo = new THREE.BoxGeometry(4, 3, 0.2);
            const mat = new THREE.MeshStandardMaterial({map: null, color: 0x8B4513});
            const wall = new THREE.Mesh(geo, mat);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const pos = camera.position.clone().add(dir.multiplyScalar(3));
            
            wall.position.set(pos.x, pos.y, pos.z);
            wall.lookAt(camera.position.x, wall.position.y, camera.position.z);
            
            scene.add(wall);
            buildings.push(wall);
        }

        function updateUI() {
            document.getElementById('health-val').innerText = Math.ceil(player.health);
            document.getElementById('health-bar').style.width = player.health + '%';
            
            document.getElementById('shield-val').innerText = Math.ceil(player.shield);
            document.getElementById('shield-bar').style.width = player.shield + '%';
            
            document.getElementById('wood-val').innerText = player.wood;
        }

        function checkWin() {
            if(bots.length === 0) {
                player.isDead = true; // Stop inputs
                controls.unlock();
                document.getElementById('game-over-screen').style.display = 'flex';
                document.getElementById('go-title').innerText = "VICTORY ROYALE!";
                document.getElementById('go-title').style.color = "#ffd700";
            }
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if(player.isDead) return;

            // 1. Storm Logic
            updateStorm();

            // 2. Physics & Movement
            if(controls.isLocked) {
                // Movement
                const actualSpeed = isSprinting ? SPRINT_SPEED : WALK_SPEED;
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= GRAVITY * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta * (actualSpeed/10);
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta * (actualSpeed/10);

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // Ground Collision
                const h = getTerrainHeight(camera.position.x, camera.position.z);
                if(camera.position.y < h + PLAYER_HEIGHT) {
                    velocity.y = 0;
                    camera.position.y = h + PLAYER_HEIGHT;
                    canJump = true;
                }

                // Weapon Sway & Recoil Recovery
                if(currentViewModel) {
                    // Sway based on movement
                    const swayX = Math.sin(time * 0.01) * (velocity.length() > 1 ? 0.05 : 0.005);
                    const swayY = Math.cos(time * 0.01) * (velocity.length() > 1 ? 0.05 : 0.005);
                    
                    // ADS Position lerp
                    const targetX = isAds ? 0 : 0.3;
                    const targetY = isAds ? -0.21 : -0.3;
                    const targetZ = isAds ? -0.4 : -0.5;

                    currentViewModel.position.x += (targetX + swayX - currentViewModel.position.x) * 10 * delta;
                    currentViewModel.position.y += (targetY + swayY - currentViewModel.position.y) * 10 * delta;
                    currentViewModel.position.z += (targetZ - currentViewModel.position.z) * 5 * delta;
                    
                    // Reset rotation from recoil
                    currentViewModel.rotation.x *= 0.9;
                }
            }

            // 3. Game Logic
            processShooting(time);
            updateBots(delta, time);
            
            // Check interaction distance for UI
            checkInteractUI();

            // 4. Render
            renderer.clear();
            renderer.render(scene, camera);
            renderer.clearDepth();
            renderer.render(weaponScene, weaponCamera);
        }

        function updateStorm() {
            const now = Date.now();
            const elapsed = (now - stormStartTime) / 1000;
            const totalTime = 120; // 2 mins to full close
            
            let timeLeft = totalTime - elapsed;
            if(timeLeft < 0) timeLeft = 0;

            const mins = Math.floor(timeLeft / 60);
            const secs = Math.floor(timeLeft % 60);
            document.getElementById('storm-timer').innerText = `STORM: ${mins}:${secs<10?'0':''}${secs}`;

            // Shrink Radius
            stormRadius = THREE.MathUtils.lerp(WORLD_SIZE, 0, elapsed / totalTime);
            
            // Damage Check
            const dist = new THREE.Vector2(camera.position.x, camera.position.z).distanceTo(stormCenter);
            const overlay = document.getElementById('storm-overlay');
            
            if(dist > stormRadius) {
                overlay.style.display = 'block';
                // Damage tick every second
                if(Math.floor(elapsed) % 1 === 0 && Math.random() < 0.1) {
                   damagePlayer(1);
                }
            } else {
                overlay.style.display = 'none';
            }
        }

        function checkInteractUI() {
            const pos = camera.position;
            let found = false;
            // Check chests
            for(let c of chests) {
                if(c.position.distanceTo(pos) < 3) found = true;
            }
            // Check loot
            for(let l of lootItems) {
                if(l.mesh.position.distanceTo(pos) < 2.5) found = true;
            }

            const ui = document.getElementById('interact-msg');
            if(found && !player.isConsuming) {
                ui.style.display = 'block';
                ui.innerText = "Press E to Interact";
            } else if (!player.isConsuming) {
                ui.style.display = 'none';
            }
        }

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            weaponCamera.aspect = window.innerWidth / window.innerHeight;
            weaponCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
