<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Battle Royale: V19.4 - UI Revolution</title>
    <style>
        /* ======================================= */
        /* === V19.4 COMPLETE UI REVOLUTION === */
        /* ======================================= */
        
        * {
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Poppins', 'Verdana', sans-serif; 
            user-select: none; 
            background: #000;
            touch-action: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            color: white;
        }

        /* --- PRE-GAME START SCREEN (Ultimate Design) --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a2a 0%, #1a1a4a 50%, #0a0a2a 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 1000;
            text-align: center;
            animation: fadeIn 0.8s ease-out;
            overflow: hidden;
        }
        
        /* Animated background particles */
        .particles {
            position: absolute;
            width: 100%; height: 100%;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            background: rgba(0, 210, 255, 0.1);
            border-radius: 50%;
            animation: float 20s infinite linear;
        }
        
        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); }
            100% { transform: translateY(-100px) rotate(360deg); }
        }

        #start-screen h1 { 
            font-size: 5rem; 
            margin-bottom: 1rem; 
            background: linear-gradient(135deg, #00d2ff 0%, #0072ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            letter-spacing: 2px;
            animation: slideDown 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            z-index: 2;
            text-shadow: 0 10px 30px rgba(0, 210, 255, 0.3);
        }
        
        #start-screen h1::after {
            content: 'V19.4';
            display: block;
            font-size: 1.5rem;
            color: #ffd700;
            margin-top: 0.5rem;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            animation: glow 3s infinite alternate;
        }
        
        @keyframes glow {
            0% { text-shadow: 0 0 10px rgba(255, 215, 0, 0.7); }
            100% { text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 50px rgba(255, 215, 0, 0.5); }
        }

        #start-screen .subtitle { 
            font-size: 1.3rem; 
            margin-bottom: 3rem; 
            color: rgba(255,255,255,0.8);
            animation: fadeIn 1s ease-out 0.5s backwards;
            position: relative;
            z-index: 2;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
            z-index: 2;
            animation: scaleIn 0.8s ease-out 0.8s backwards;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        
        .game-button {
            padding: 1.2rem 2.5rem; 
            margin: 0; 
            font-size: 1.3rem;
            background: linear-gradient(135deg, #00d2ff, #0072ff);
            color: white; 
            border: none; 
            border-radius: 15px; 
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Poppins', sans-serif; 
            font-weight: 600;
            box-shadow: 
                0 10px 30px rgba(0, 114, 255, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        .game-button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.6s;
        }
        
        .game-button:hover::before {
            left: 100%;
        }
        
        .game-button:hover { 
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 15px 40px rgba(0, 114, 255, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        .game-button:active { 
            transform: scale(0.98) translateY(0); 
            box-shadow: 0 5px 20px rgba(0, 114, 255, 0.3);
            transition: transform 0.1s;
        }
        
        .game-button.mobile { 
            background: linear-gradient(135deg, #ffaa00, #ff6600);
        }
        
        .game-button.mobile:hover { 
            background: linear-gradient(135deg, #ff8800, #ff4400); 
        }
        
        /* Stats display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-top: 3rem;
            animation: fadeIn 1s ease-out 1s backwards;
            position: relative;
            z-index: 2;
            max-width: 800px;
            width: 100%;
        }
        
        .stat-item {
            background: rgba(0, 0, 0, 0.6);
            padding: 1.2rem;
            border-radius: 12px;
            border: 2px solid rgba(0, 210, 255, 0.2);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
        }
        
        .stat-item:hover {
            transform: translateY(-5px);
            border-color: rgba(0, 210, 255, 0.4);
            box-shadow: 0 10px 30px rgba(0, 210, 255, 0.2);
        }
        
        .stat-item h3 {
            margin: 0 0 0.5rem 0;
            color: #00d2ff;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-item p {
            margin: 0;
            color: #ffd700;
            font-size: 1.8rem;
            font-weight: 700;
        }
        
        #victory-royales-stat {
            position: absolute; 
            bottom: 2rem; 
            font-size: 1.1rem;
            color: #ffd700; 
            font-weight: 600;
            background: rgba(0,0,0,0.7);
            padding: 1rem 2rem;
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            z-index: 2;
            animation: fadeIn 1s ease-out 1.5s backwards;
            backdrop-filter: blur(10px);
        }
        
        /* --- REVOLUTIONARY NEW CROSSHAIR --- */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 24px; height: 24px; 
            transform: translate(-50%, -50%); 
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.9;
            z-index: 10;
            pointer-events: none;
        }
        
        .crosshair-dot {
            position: absolute;
            width: 4px; height: 4px;
            background: #ff4d4d;
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 10px #ff4d4d,
                0 0 20px rgba(255, 77, 77, 0.5);
        }
        
        .crosshair-line {
            position: absolute;
            background: #ff4d4d;
            border-radius: 1px;
            box-shadow: 0 0 5px rgba(255, 77, 77, 0.8);
        }
        
        .ch-h { 
            width: 100%; height: 2px; 
            top: 50%; left: 0; 
            margin-top: -1px; 
        }
        
        .ch-v { 
            height: 100%; width: 2px; 
            left: 50%; top: 0; 
            margin-left: -1px; 
        }

        /* Enhanced Scopes */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 18%, rgba(0, 0, 0, 0.98) 19%, black 100%);
            display: none; pointer-events: none; z-index: 100; 
        }
        
        #scope-lines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(to right, rgba(255,255,255,0.1) 1px, transparent 1px) 0 0 / 25px 25px,
                linear-gradient(to bottom, rgba(255,255,255,0.1) 1px, transparent 1px) 0 0 / 25px 25px;
            opacity: 0.5;
        }
        
        #red-dot-scope {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none;
            pointer-events: none;
            background: radial-gradient(circle, transparent 45%, rgba(0,0,0,0.85) 46%, rgba(0,0,0,0.95) 100%);
        }
        
        .red-dot {
            width: 6px; height: 6px; border-radius: 50%;
            background: #ff0000; 
            box-shadow: 
                0 0 15px #ff0000,
                0 0 30px #ff0000,
                0 0 45px rgba(255, 0, 0, 0.5);
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            animation: pulseRed 0.8s infinite alternate;
        }
        
        @keyframes pulseRed {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.8; }
        }
        
        .red-line {
            position: absolute; background: rgba(255, 0, 0, 0.2);
        }
        .red-line.h { width: 100%; height: 1px; top: 50%; }
        .red-line.v { height: 100%; width: 1px; left: 50%; }

        /* Storm Visuals */
        #storm-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, 
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.15) 40%,
                rgba(75, 0, 130, 0.25) 60%,
                rgba(75, 0, 130, 0.35) 80%,
                rgba(75, 0, 130, 0.45) 100%);
            mix-blend-mode: multiply; 
            pointer-events: none; 
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 50; 
        }
        
        #storm-overlay.in-storm {
            background: radial-gradient(circle at 50% 50%,
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.25) 30%,
                rgba(75, 0, 130, 0.45) 50%,
                rgba(75, 0, 130, 0.65) 70%,
                rgba(75, 0, 130, 0.85) 100%);
            animation: stormPulse 2s infinite alternate;
        }
        
        @keyframes stormPulse {
            0% { opacity: 0.9; }
            100% { opacity: 1; }
        }

        /* === REVOLUTIONARY NEW HUD DESIGN === */
        #hud-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        /* Top Bar - Modern Design */
        #top-bar {
            position: absolute;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1.5rem;
            background: rgba(10, 10, 30, 0.85);
            backdrop-filter: blur(20px);
            padding: 0.8rem 1.5rem;
            border-radius: 15px;
            border: 2px solid rgba(0, 210, 255, 0.3);
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.1);
            z-index: 20;
        }
        
        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 120px;
        }
        
        .hud-label {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.3rem;
            font-weight: 600;
        }
        
        .hud-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        #alive-count { color: #4CAF50; }
        #storm-timer { color: #a335ee; }

        /* Player Stats - Left Side (Modern Cards) */
        #player-stats {
            position: absolute;
            bottom: 1.5rem;
            left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 350px;
            z-index: 20;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            padding: 1rem 1.2rem;
            border: 2px solid rgba(255,255,255,0.1);
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255,255,255,0.05);
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            border-color: rgba(0, 210, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .stat-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.8rem;
        }
        
        .stat-icon {
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }
        
        .stat-title {
            flex: 1;
            font-size: 1.1rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffd700;
            min-width: 60px;
            text-align: right;
        }
        
        .stat-bar-container {
            height: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .stat-bar {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.3), 
                transparent);
            animation: barShine 2s infinite linear;
        }
        
        @keyframes barShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #health-bar { 
            background: linear-gradient(90deg, #ff4d4d, #ff8888, #ffaaaa);
        }
        
        #shield-bar { 
            background: linear-gradient(90deg, #0072ff, #00a8ff, #00d2ff);
        }
        
        #overshield-bar { 
            background: linear-gradient(90deg, #ffaa00, #ffcc00, #ffff00);
        }

        /* Resources Bar */
        #resources-bar {
            display: flex;
            gap: 1.5rem;
            margin-top: 0.5rem;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .resource-icon {
            font-size: 1.3rem;
            color: #deb887;
        }
        
        .resource-amount {
            font-size: 1.2rem;
            font-weight: 700;
            color: white;
        }

        /* Inventory - Right Side (Modern Design) */
        #inventory-hud {
            position: absolute;
            bottom: 1.5rem;
            right: 1.5rem;
            display: flex;
            gap: 0.8rem;
            z-index: 20;
        }
        
        .inventory-slot {
            width: 80px;
            height: 100px;
            background: rgba(10, 10, 30, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            border: 3px solid rgba(255,255,255,0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        
        .inventory-slot:hover {
            transform: translateY(-5px) scale(1.05);
            border-color: rgba(255,255,255,0.3);
            box-shadow: 0 15px 35px rgba(0,0,0,0.6);
        }
        
        .inventory-slot.active {
            border-color: #ff4d4d;
            transform: translateY(-8px) scale(1.1);
            background: rgba(30, 30, 50, 0.95);
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.7),
                0 0 30px rgba(255, 77, 77, 0.3);
        }
        
        .slot-key {
            position: absolute;
            top: 8px;
            left: 8px;
            font-size: 0.9rem;
            color: rgba(255,255,255,0.7);
            font-weight: 600;
            background: rgba(0,0,0,0.5);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }
        
        .slot-icon {
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px currentColor;
        }
        
        .slot-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: rgba(255,255,255,0.9);
            text-transform: uppercase;
            text-align: center;
            max-width: 70px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 0 0.3rem;
        }
        
        .slot-count {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 0.9rem;
            font-weight: 700;
            color: #ffd700;
            background: rgba(0,0,0,0.5);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }
        
        /* Rarity Borders */
        .rarity-common { border-bottom: 5px solid #b0b0b0; }
        .rarity-uncommon { border-bottom: 5px solid #28a745; }
        .rarity-rare { border-bottom: 5px solid #007bff; }
        .rarity-epic { border-bottom: 5px solid #a335ee; }
        .rarity-legendary { border-bottom: 5px solid #ffd700; }
        .rarity-mythic { border-bottom: 5px solid #ff4d4d; }

        /* Center HUD Elements */
        #center-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            z-index: 15;
        }

        /* Interaction Prompt */
        #interact-prompt {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 170, 0, 0.95));
            color: #000;
            padding: 1rem 2rem;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 700;
            display: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 10px 30px rgba(255, 215, 0, 0.4),
                0 5px 15px rgba(0,0,0,0.3);
            border: 3px solid rgba(255,255,255,0.5);
            backdrop-filter: blur(10px);
            animation: pulsePrompt 1.5s infinite alternate;
            pointer-events: none;
        }
        
        @keyframes pulsePrompt {
            0% { transform: translateY(-50%) scale(1); }
            100% { transform: translateY(-50%) scale(1.05); }
        }

        /* Reload Indicator */
        #reload-indicator {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.95), rgba(255, 68, 68, 0.95));
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 700;
            display: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.4);
            border: 2px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(10px);
        }

        /* Healing Progress */
        #healing-progress {
            position: absolute;
            bottom: 12rem;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            display: none;
            overflow: hidden;
            border: 3px solid rgba(0, 210, 255, 0.5);
            box-shadow: 0 10px 40px rgba(0, 210, 255, 0.3);
            backdrop-filter: blur(10px);
        }
        
        #healing-bar {
            height: 100%;
            background: linear-gradient(90deg, #0072ff, #00d2ff, #00ffff);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        #healing-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.4), 
                transparent);
            animation: healShine 1s infinite linear;
        }
        
        @keyframes healShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #healing-text {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 1.1rem;
            text-shadow: 0 2px 5px rgba(0,0,0,0.8);
            letter-spacing: 1px;
        }

        /* Damage Numbers */
        .dmg-number {
            position: absolute;
            color: white;
            font-weight: 900;
            font-size: 2rem;
            text-shadow: 
                2px 2px 5px rgba(0,0,0,0.8),
                0 0 15px currentColor;
            pointer-events: none;
            animation: damageFloat 1.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            z-index: 999;
            font-family: 'Poppins', sans-serif;
        }
        
        .dmg-number.headshot {
            color: #ff0000;
            font-size: 2.5rem;
            text-shadow: 
                0 0 20px #ff0000,
                0 0 40px rgba(255, 0, 0, 0.5);
        }
        
        .dmg-number.storm {
            color: #a335ee;
            font-size: 1.8rem;
            text-shadow: 
                0 0 20px #a335ee,
                0 0 35px rgba(163, 53, 238, 0.5);
        }
        
        @keyframes damageFloat { 
            0% { opacity: 1; transform: translateY(0) scale(1); } 
            70% { opacity: 1; transform: translateY(-50px) scale(1.2); }
            100% { opacity: 0; transform: translateY(-70px) scale(1.3); } 
        }

        /* --- MOBILE CONTROLS (Stabilized) --- */
        #mobile-controls {
            display: none; 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none;
        }
        
        #touch-left {
            position: absolute;
            top: 0; left: 0;
            width: 50%; height: 100%;
            pointer-events: auto;
            touch-action: none;
        }
        
        #touch-right {
            position: absolute;
            top: 0; right: 0;
            width: 50%; height: 100%;
            background: none;
            pointer-events: auto;
            z-index: 1;
            touch-action: none;
        }
        
        /* Movement Zone */
        #movement-zone {
            position: absolute;
            bottom: 100px;
            left: 80px;
            width: 180px;
            height: 180px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.05) 0%,
                rgba(255,255,255,0.02) 70%,
                transparent 71%);
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.15);
            pointer-events: none;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.4),
                inset 0 0 20px rgba(255,255,255,0.05);
        }
        
        .joystick-thumb {
            position: absolute;
            top: 50%; left: 50%;
            width: 70px; height: 70px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.3) 0%,
                rgba(255,255,255,0.15) 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 5px 20px rgba(0,0,0,0.5),
                inset 0 0 15px rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            pointer-events: none;
            transition: transform 0.1s ease;
        }

        /* Mobile Action Buttons */
        .mobile-button {
            position: absolute;
            width: 80px; height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, 
                rgba(30, 30, 40, 0.9),
                rgba(20, 20, 30, 0.9));
            border: 3px solid rgba(255,255,255,0.3);
            color: white;
            font-weight: 700;
            font-size: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            text-align: center;
            text-transform: uppercase;
            z-index: 5;
            box-shadow: 
                0 8px 25px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.2);
            transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .mobile-button:active {
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.3),
                rgba(255,255,255,0.2));
            transform: scale(0.85);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        #btn-fire { 
            bottom: 100px; right: 30px; 
            width: 100px; height: 100px;
            border-color: #ff4444;
            background: linear-gradient(135deg, 
                rgba(255,0,0,0.5),
                rgba(255,68,68,0.4));
            font-size: 1.2rem;
        }
        
        #btn-jump { 
            bottom: 220px; right: 40px;
            border-color: #00d2ff;
            background: linear-gradient(135deg,
                rgba(0,210,255,0.5),
                rgba(0,168,255,0.4));
        }
        
        #btn-interact { 
            bottom: 180px; right: 120px;
            border-color: #ffd700;
            color: #ffd700;
            background: linear-gradient(135deg,
                rgba(255,215,0,0.3),
                rgba(255,170,0,0.2));
        }
        
        #btn-build { 
            bottom: 260px; right: 120px;
            border-color: #8B4513;
            background: linear-gradient(135deg,
                rgba(139,69,19,0.5),
                rgba(160,82,45,0.4));
        }
        
        #btn-ads { 
            bottom: 60px; right: 140px;
            width: 70px; height: 70px;
            font-size: 0.9rem;
            border-color: #007bff;
            background: linear-gradient(135deg,
                rgba(0,123,255,0.5),
                rgba(0,82,204,0.4));
        }
        
        #btn-reload { 
            top: 200px; right: 30px;
            width: 65px; height: 65px;
            font-size: 0.8rem;
            border-color: #00d2ff;
            background: linear-gradient(135deg,
                rgba(0,210,255,0.5),
                rgba(0,168,255,0.4));
            display: none;
        }

        /* --- GAME OVER SCREENS --- */
        #victory-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(255, 215, 0, 0.4),
                rgba(255, 0, 0, 0.5));
            backdrop-filter: blur(15px);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            animation: fadeIn 0.8s ease-out forwards;
        }
        
        #victory-text {
            font-size: 0;
            background: linear-gradient(135deg, #ffd700, #ffaa00, #ff6600);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            animation: victoryText 3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards,
                       victoryPulse 2s infinite alternate 3s;
            position: relative;
            text-shadow: 
                0 10px 40px rgba(255, 215, 0, 0.5),
                0 0 60px rgba(255, 170, 0, 0.3);
            letter-spacing: -10px;
            opacity: 0;
            white-space: nowrap;
        }
        
        @keyframes victoryText {
            0% { font-size: 0; transform: scale(0) rotate(-20deg); opacity: 0; letter-spacing: 100px; }
            50% { font-size: 8rem; transform: scale(1.3) rotate(10deg); opacity: 1; letter-spacing: -5px; }
            100% { font-size: 5rem; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0; }
        }
        
        @keyframes victoryPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }
        
        #game-over {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(200, 0, 0, 0.9),
                rgba(50, 0, 0, 0.95));
            backdrop-filter: blur(15px);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 999;
            pointer-events: auto;
            text-align: center;
        }
        
        #go-title {
            font-size: 6rem;
            background: linear-gradient(135deg, #ff4d4d, #ff0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
            font-weight: 900;
            animation: slideIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 10px 40px rgba(255, 0, 0, 0.5);
        }
        
        #go-stats {
            font-size: 2.5rem;
            color: rgba(255,255,255,0.9);
            margin-bottom: 4rem;
            animation: slideIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.5s backwards;
            text-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }

        /* Restart Button */
        .restart-btn {
            margin-top: 3rem;
            padding: 1.2rem 3rem;
            font-size: 1.4rem;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            box-shadow: 
                0 10px 30px rgba(0, 123, 255, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        .restart-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        .restart-btn:hover::before {
            left: 100%;
        }
        
        .restart-btn:hover {
            background: linear-gradient(135deg, #0056b3, #003d82);
            transform: translateY(-3px);
            box-shadow: 
                0 15px 40px rgba(0, 123, 255, 0.8),
                inset 0 1px 0 rgba(255,255,255,0.4);
        }
        
        #game-over .restart-btn {
            animation: slideIn 1s ease-out 1s backwards;
        }
        
        #victory-overlay .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 3s forwards;
        }

        /* Animations */
        @keyframes fadeIn { 
            0% { opacity: 0; } 
            100% { opacity: 1; } 
        }
        
        @keyframes slideDown {
            0% { opacity: 0; transform: translateY(-50px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes scaleIn {
            0% { opacity: 0; transform: scale(0.7) rotate(-5deg); }
            70% { opacity: 1; transform: scale(1.05) rotate(2deg); }
            100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }
        
        @keyframes slideIn {
            0% { opacity: 0; transform: translateY(-50px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes fadeUp {
            0% { transform: translateY(50px) scale(0.8); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>

    <div id="start-screen">
        <div class="particles" id="particles-container"></div>
        <h1>WEB BATTLE ROYALE</h1>
        <p class="subtitle">Experience the ultimate browser-based shooter</p>
        <div class="button-container">
            <button class="game-button mobile" onclick="startGame(true)">üì± Mobile Mode</button>
            <button class="game-button" onclick="startGame(false)">üñ•Ô∏è Desktop Mode</button>
        </div>
        <div class="stats-grid">
            <div class="stat-item">
                <h3>Active Players</h3>
                <p id="total-players">21</p>
            </div>
            <div class="stat-item">
                <h3>Map Size</h3>
                <p>600x600</p>
            </div>
            <div class="stat-item">
                <h3>Version</h3>
                <p>V19.4</p>
            </div>
        </div>
        <div id="victory-royales-stat">üèÜ Victory Royales: 0</div>
    </div>
    
    <div id="game-container"></div>

    <div id="ui-layer">
        <!-- Crosshair -->
        <div id="crosshair">
            <div class="crosshair-dot"></div>
            <div class="crosshair-line ch-h"></div>
            <div class="crosshair-line ch-v"></div>
        </div>
        
        <!-- Scopes -->
        <div id="scope-overlay">
            <div id="scope-lines"></div>
        </div>
        
        <div id="red-dot-scope">
            <div class="red-line h"></div>
            <div class="red-line v"></div>
            <div class="red-dot"></div>
        </div>

        <!-- Storm Overlay -->
        <div id="storm-overlay"></div>

        <!-- HUD Container -->
        <div id="hud-container">
            <!-- Top Bar -->
            <div id="top-bar">
                <div class="hud-item">
                    <div class="hud-label">Players Alive</div>
                    <div class="hud-value" id="alive-count">21</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Phase</div>
                    <div class="hud-value" id="storm-status">WAIT</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Timer</div>
                    <div class="hud-value" id="storm-timer">04:00</div>
                </div>
            </div>

            <!-- Player Stats (Left) -->
            <div id="player-stats">
                <!-- Health -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">‚ù§Ô∏è</div>
                        <div class="stat-title">Health</div>
                        <div class="stat-value" id="health-value">100</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="health-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Shield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">üõ°Ô∏è</div>
                        <div class="stat-title">Shield</div>
                        <div class="stat-value" id="shield-value">25</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="shield-bar" class="stat-bar" style="width: 25%"></div>
                    </div>
                </div>
                
                <!-- Overshield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">üî•</div>
                        <div class="stat-title">Overshield</div>
                        <div class="stat-value" id="overshield-value">50</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="overshield-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Resources -->
                <div id="resources-bar">
                    <div class="resource-item">
                        <div class="resource-icon">ü™µ</div>
                        <div class="resource-amount" id="wood-value">0</div>
                    </div>
                </div>
            </div>

            <!-- Inventory (Right) -->
            <div id="inventory-hud">
                <div class="inventory-slot" id="slot-0" onclick="selectSlot(0)" ontouchstart="selectSlotMobile(0)"></div>
                <div class="inventory-slot" id="slot-1" onclick="selectSlot(1)" ontouchstart="selectSlotMobile(1)"></div>
                <div class="inventory-slot" id="slot-2" onclick="selectSlot(2)" ontouchstart="selectSlotMobile(2)"></div>
                <div class="inventory-slot" id="slot-3" onclick="selectSlot(3)" ontouchstart="selectSlotMobile(3)"></div>
                <div class="inventory-slot" id="slot-4" onclick="selectSlot(4)" ontouchstart="selectSlotMobile(4)"></div>
            </div>

            <!-- Center HUD -->
            <div id="center-hud">
                <div id="interact-prompt">Interact (E)</div>
                <div id="reload-indicator">RELOADING...</div>
            </div>

            <!-- Healing Progress -->
            <div id="healing-progress">
                <div id="healing-bar"></div>
                <div id="healing-text">USING SHIELD...</div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div id="touch-left"></div>
            <div id="touch-right"></div>
            
            <div id="movement-zone">
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
            
            <div id="btn-fire" class="mobile-button">FIRE</div>
            <div id="btn-jump" class="mobile-button">JUMP</div>
            <div id="btn-interact" class="mobile-button">INTERACT</div>
            <div id="btn-build" class="mobile-button">BUILD</div>
            <div id="btn-ads" class="mobile-button">AIM</div>
            <div id="btn-reload" class="mobile-button">RELOAD</div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-overlay">
        <div id="victory-text">VICTORY ROYALE</div>
        <button class="restart-btn" onclick="location.reload()">üèÜ RETURN TO LOBBY</button>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <h1 id="go-title">ELIMINATED</h1>
        <h3 id="go-stats">Eliminations: 0</h3>
        <button class="restart-btn" onclick="location.reload()">üîÑ RETURN TO LOBBY</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ===============================================================
        // === CORE CONSTANTS AND CONFIGURATION (V19.4) ===================
        // ===============================================================
        
        const WORLD_SIZE = 600;
        let BOT_COUNT = 20; 
        const GRAVITY = 40.0; 
        const WALK_SPEED = 10; 
        const SPRINT_SPEED = 20; 
        const JUMP_FORCE = 15;
        const PLAYER_HEIGHT = 1.8;
        const SHOTGUN_PELLETS = 4;
        
        // --- UPDATED: Overshield regenerates after 7 seconds when broken ---
        const OVER_SHIELD_MAX = 50;
        const OVER_SHIELD_REGEN_RATE = 15; // Faster regen
        const OVER_SHIELD_REGEN_DELAY = 7000; // 7 seconds delay
        
        // --- WEAPONS CONFIG ---
        const RARITY_MULTIPLIERS = {
            COMMON: { dmg: 1.0, reload: 1.0, color: '#b0b0b0' },
            UNCOMMON: { dmg: 1.15, reload: 0.9, color: '#28a745' },
            RARE: { dmg: 1.3, reload: 0.8, color: '#007bff' },
            EPIC: { dmg: 1.45, reload: 0.7, color: '#a335ee' },
            LEGENDARY: { dmg: 1.6, reload: 0.6, color: '#ffd700' },
            MYTHIC: { dmg: 1.8, reload: 0.5, color: '#ff4d4d' } 
        };
        const RARITY_KEYS = Object.keys(RARITY_MULTIPLIERS);

        // Weapons configuration (same as V19.3)
        const WEAPONS_BASE = {
            PUMP: { name: "Pump Shotgun", dmg: 30 * 1.5, head: 35 * 1.5, rate: 1.2, mag: 5, range: 30, spread: 0.25, pellets: SHOTGUN_PELLETS, auto: false, icon: 'üí•', reload: 3000, recoil: 0.0, bulletType: 'hitscan' }, 
            AUTO_SHG: { name: "Auto Shotgun", dmg: 15, head: 25, rate: 0.4, mag: 8, range: 25, spread: 0.3, pellets: SHOTGUN_PELLETS, auto: true, icon: 'üî•', reload: 3500, recoil: 0.0, bulletType: 'hitscan' },
            RFAR: { name: "Rapid Fire AR", dmg: 14, head: 21, rate: 0.1, mag: 30, range: 150, spread: 0.04, pellets: 1, auto: true, icon: 'üí®', reload: 2500, recoil: 0.0, bulletType: 'hitscan' }, 
            DMR: { name: "DMR", dmg: 25, head: 40, rate: 0.35, mag: 15, range: 250, spread: 0.015, pellets: 1, auto: false, icon: 'üéØ', reload: 2800, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            STINGER: { name: "Stinger SMG", dmg: 12, head: 18, rate: 0.07, mag: 20, range: 70, spread: 0.07, pellets: 1, auto: true, icon: '‚ö°', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            BURST_SMG: { name: "Burst SMG", dmg: 18, head: 30, rate: 0.15, mag: 30, burst: 2, burstDelay: 300, range: 80, spread: 0.05, pellets: 1, auto: false, icon: '‚ú®', reload: 2000, recoil: 0.0, bulletType: 'hitscan' },
            BOLT_SNIPER: { name: "Bolt Sniper", dmg: 85 * 1.25, head: 105 * 1.25, rate: 2.5, mag: 2, range: 600, spread: 0.001, pellets: 1, auto: false, icon: 'üíÄ', reload: 4000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            SCOPED_SMG: { name: "Scoped SMG", dmg: 12, head: 18, rate: 0.1, mag: 40, range: 100, spread: 0.03, pellets: 1, auto: true, icon: 'üëÅÔ∏è', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            DRUM_SMG: { name: "Drum SMG", dmg: 10, head: 15, rate: 0.08, mag: 50, range: 80, spread: 0.08, pellets: 1, auto: true, icon: 'ü•Å', reload: 1200, recoil: 0.0, bulletType: 'hitscan' },
            FALCON_SNIPER: { name: "Falcon Sniper", dmg: 65 * 1.25, head: 90 * 1.25, rate: 0.7, mag: 3, range: 500, spread: 0.005, pellets: 1, auto: false, icon: 'ü¶Ö', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' }, 
            STRANGLED_RIFLE: { name: "Strangled Rifle", dmg: 35, head: 55, rate: 0.45, mag: 30, range: 180, spread: 0.02, pellets: 1, auto: false, icon: '‚õìÔ∏è', reload: 2500, recoil: 0.0, bulletType: 'hitscan' },
            SNIPER:{name: "Sniper", dmg: 100 * 1.25, head: 130 * 1.25, rate: 1.5, mag: 1,  range: 600,spread: 0.001,pellets:1, auto: false,icon:'üî≠', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            PISTOL: { name: "Pistol", dmg: 12, head: 18, rate: 0.5, mag: 15, range: 100, spread: 0.05, pellets: 1, auto: false, icon: 'üí£', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            ROCKET_LAUNCHER: { name: "R. Launcher", dmg: 50, head: 0, rate: 4.0, mag: 1, range: 300, spread: 0.0, pellets: 1, auto: false, icon: 'üöÄ', reload: 4500, recoil: 0.0, bulletType: 'projectile', explosionRadius: 5, explosionDamage: 200 },
            DUAL_SMG: { name: "Dual Micro SMGS", dmg: 9, head: 14, rate: 0.05, mag: 130, range: 70, spread: 0.1, pellets: 1, auto: true, icon: 'üî™', reload: 2250, recoil: 0.0, bulletType: 'hitscan' }
        };
        const MYTHIC_WEAPON_KEY = 'STRANGLED_RIFLE'; 
        const BOT_WEAPON_KEY = 'RFAR'; 
        
        // --- CONSUMABLES CONFIG ---
        const CONSUMABLES = {
            MINI: { name: "Small Shield", val: 25, type: 'shield', max: 50, icon: 'üíß', time: 1, continuous: false, instant: true, maxStack: 6, rarity: 'COMMON' },
            BIG:  { name: "Big Shield", val: 50, type: 'shield', max: 100, icon: '‚öóÔ∏è', time: 5000, continuous: false, instant: false, maxStack: 3, rarity: 'UNCOMMON' },
            CHUG: { name: "Chug Jug", val: 3, shieldVal: 3, type: 'continuous', max: 100, icon: 'ü•§', time: 20000, continuous: true, instant: false, maxStack: 1, rarity: 'LEGENDARY' },
            MEDKIT: { name: "Med Kit", val: 100, type: 'health', max: 100, icon: 'ü©π', time: 10000, continuous: false, instant: false, maxStack: 3, rarity: 'RARE' }
        };
        const CONSUMABLE_KEYS = Object.keys(CONSUMABLES);

        // --- STORM PHASES ---
        const STORM_PHASES = [
            { time: 60, radius: WORLD_SIZE * 0.5, damage: 3, status: "Wait" }, 
            { time: 60, radius: WORLD_SIZE * 0.4, damage: 3, status: "Shrink" }, 
            { time: 120, radius: WORLD_SIZE * 0.4, damage: 3, status: "Hold" }, 
            { time: 60, radius: WORLD_SIZE * 0.3, damage: 5, status: "Shrink" }, 
            { time: 60, radius: 0, damage: 10, status: "Deathmatch" } 
        ];
        const BOT_STORM_DAMAGE = 5;

        // ===============================================================
        // === GLOBAL STATE VARIABLES ====================================
        // ===============================================================

        let scene, camera, renderer, controls;
        let weaponScene, weaponCamera, viewModel;
        let raycaster, downRay;
        
        // UPDATED: Player starts with 100 Health, 25 Shields, 50 Overshields
        let player = { 
            health: 100, shield: 25, overshield: 50, wood: 0, 
            inventory: [null, null, null, null, null], slot: 0, 
            dead: false, ads: false, vehicle: null, eliminations: 0,
            isReloading: false,
            isHealing: false,
            healingItem: null,
            healingStartTime: 0,
            lastStormDamage: 0,
            isBursting: false,
            burstCount: 0,
            burstTimer: null,
            lastOvershieldDamage: 0, 
            overshieldRegenTimer: null,
            lastOvershieldBreak: 0
        };
        
        let inputs = { w: false, a: false, s: false, d: false, jump: false, sprint: false, fire: false, reload: false, use: false };
        let velocity = new THREE.Vector3();
        let isGrounded = false;
        let lastTime = performance.now();
        let lastShot = 0;
        let isMobileMode = false; 
        let gameStarted = false;
        let victoryRoyales = 0;
        
        // Mobile control variables (Stabilized camera)
        let mobileTouchActive = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let touchDeltaX = 0;
        let touchDeltaY = 0;
        const MOBILE_SENSITIVITY = 0.002;
        const MOBILE_SMOOTHING = 0.1;
        const MAX_CAMERA_ANGLE = Math.PI / 2 - 0.1; // 89 degrees max
        
        // Dynamic Arrays for Entities
        let bots = [];
        let objects = []; 
        let chests = [];
        let cars = [];
        let loot = [];
        let buildings = []; 
        let projectiles = []; 
        let doors = []; 

        // Storm State
        let stormRadius = STORM_PHASES[0].radius;
        let stormCenter = new THREE.Vector2(0, 0);
        let stormDamageRate = STORM_PHASES[0].damage;
        let stormPhaseTime = STORM_PHASES[0].time; 
        let stormPhaseTimer = stormPhaseTime;
        let stormPhase = 0;
        let stormActive = false;
        let stormTimerInterval;

        // ===============================================================
        // === SOUND EFFECT UTILITIES ====================================
        // ===============================================================

        function playSound(type) {
            // console.log(`[SOUND]: Playing ${type} sound.`); 
        }

        // ===============================================================
        // === UTILITY FUNCTIONS =========================================
        // ===============================================================

        function getTerrainHeight(x, z) {
            const scale1 = 0.02;
            const scale2 = 0.05;
            let y = (Math.sin(x * scale1) * 10 + Math.cos(z * scale1) * 10) + 
                    (Math.sin(x * scale2 + z * scale2) * 5);
            const dist = Math.sqrt(x*x + z*z);
            if (dist > WORLD_SIZE * 0.45) y += (dist - WORLD_SIZE * 0.45) * 0.2;
            return y;
        }
        
        function createBox(x, y, z, w, h, d, col, type='solid') {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: col}));
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh); 
            buildings.push({ mesh: mesh, type: type, health: 100 });
            return mesh;
        }

        function createDoor(x, y, z, rotationY) {
            const doorGeo = new THREE.BoxGeometry(1.5, 3, 0.1);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, transparent: true, opacity: 0.8 });
            const doorMesh = new THREE.Mesh(doorGeo, doorMat);
            doorMesh.position.set(x, y + 1.5, z);
            doorMesh.rotation.y = rotationY;
            scene.add(doorMesh);
            
            objects.push(doorMesh); 
            doors.push({ mesh: doorMesh, open: false, initialRotation: rotationY });
            
            return doorMesh;
        }
        
        function checkWin() {
            if (bots.length === 0 && !player.dead) {
                handleGameOver(true);
            }
        }
        
        function handleGameOver(win) {
            player.dead = true;
            if (controls && controls.isLocked) controls.unlock(); 
            
            if (win) {
                victoryRoyales = (parseInt(localStorage.getItem('victoryRoyales')) || 0) + 1;
                localStorage.setItem('victoryRoyales', victoryRoyales);

                document.getElementById('victory-overlay').style.display = 'flex';
                playSound('victory');
            } else {
                document.getElementById('go-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('game-over').style.display = 'flex';
                playSound('defeat');
            }
        }

        function toggleADS(bool) {
            player.ads = bool;
            const item = player.inventory[player.slot];
            const isClassicScope = item && item.category === 'weapon' && item.stats.scope === 'classic';
            const isRedDotScope = item && item.category === 'weapon' && item.stats.scope === 'red_dot';
            
            const scopeOverlay = document.getElementById('scope-overlay');
            const redDotScope = document.getElementById('red-dot-scope');
            const crosshair = document.getElementById('crosshair');

            scopeOverlay.style.display = 'none';
            redDotScope.style.display = 'none';
            
            const isScoped = isClassicScope || isRedDotScope;
            
            if (bool && isScoped) {
                crosshair.style.display = 'none';
                if (isClassicScope) {
                    scopeOverlay.style.display = 'block';
                    camera.fov = 10;
                } else if (isRedDotScope) {
                    redDotScope.style.display = 'block';
                    camera.fov = (item.stats.name === WEAPONS_BASE.FALCON_SNIPER.name) ? 20 : 35;
                }
            } else {
                const isSniperFamily = item && item.category === 'weapon' && (item.stats.scope === 'classic' || item.stats.scope === 'red_dot');
                crosshair.style.display = (isSniperFamily && !bool) ? 'none' : 'block';
                camera.fov = 75;
            }

            camera.updateProjectionMatrix();
        }

        function showDamage(amount, position, type = 'body', isHeadshot = false) {
            const dmgNumber = document.createElement('div');
            dmgNumber.className = 'dmg-number' + (isHeadshot ? ' headshot' : '') + (type === 'storm' ? ' storm' : '');
            dmgNumber.innerText = Math.round(amount);
            
            const worldPoint = position.clone().project(camera);
            
            const x = (worldPoint.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-worldPoint.y * 0.5 + 0.5) * window.innerHeight;
            
            dmgNumber.style.left = `${x}px`;
            dmgNumber.style.top = `${y}px`;
            
            document.getElementById('ui-layer').appendChild(dmgNumber);
            
            setTimeout(() => {
                dmgNumber.remove();
            }, 1200);
        }

        function reload() {
            const item = player.inventory[player.slot];
            if (!item || item.category !== 'weapon' || item.stats.currentMag === item.stats.mag || player.isReloading) return;
            
            // Interrupt Healing
            if (player.isHealing) finishHealing();
            
            playSound('reload');

            player.isReloading = true;
            document.getElementById('reload-indicator').style.display = 'block';
            updateUI();

            const reloadTime = item.stats.reload * item.rarity.reload;

            setTimeout(() => {
                item.stats.currentMag = item.stats.mag;
                player.isReloading = false;
                document.getElementById('reload-indicator').style.display = 'none';
                updateUI();
            }, reloadTime);
        }

        function buildWall() {
            if (player.wood < 10) return;
            
            playSound('build');

            const wallGeo = new THREE.BoxGeometry(4, 4, 0.1);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, transparent: true, opacity: 0.8 });
            const wall = new THREE.Mesh(wallGeo, wallMat);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0;
            dir.normalize();

            wall.position.copy(camera.position).add(dir.multiplyScalar(5)).setY(getTerrainHeight(camera.position.x, camera.position.z) + 2);
            wall.rotation.y = camera.rotation.y;
            scene.add(wall);
            
            objects.push(wall);
            buildings.push({ mesh: wall, type: 'indestructible_wood', health: Infinity }); 
            player.wood -= 10;
            updateUI();
        }

        // ===============================================================
        // === STORM LOGIC ===============================================
        // ===============================================================

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function startStormTimer() {
            if (stormTimerInterval) clearInterval(stormTimerInterval);

            const nextPhase = STORM_PHASES[stormPhase];
            if (!nextPhase) {
                document.getElementById('storm-status').innerText = "FINAL";
                document.getElementById('storm-timer').innerText = "00:00";
                return;
            }
            
            stormPhaseTimer = nextPhase.time;
            document.getElementById('storm-status').innerText = nextPhase.status;
            stormDamageRate = nextPhase.damage; 
            
            const startRadius = stormRadius;
            const endRadius = nextPhase.radius;
            const startTime = performance.now();

            stormTimerInterval = setInterval(() => {
                if (player.dead) {
                    clearInterval(stormTimerInterval);
                    return;
                }
                
                stormPhaseTimer -= 1;
                document.getElementById('storm-timer').innerText = formatTime(stormPhaseTimer);
                
                if (nextPhase.status === "Shrink" || nextPhase.status === "Deathmatch") {
                    const elapsed = performance.now() - startTime;
                    const duration = nextPhase.time * 1000;
                    const t = Math.min(1, elapsed / duration);
                    stormRadius = startRadius + (endRadius - startRadius) * t;
                    stormActive = true; 
                } else if (nextPhase.status === "Hold") {
                    stormActive = true;
                } else if (nextPhase.status === "Wait") {
                    stormActive = false;
                }

                if (stormPhaseTimer <= 0) {
                    clearInterval(stormTimerInterval);
                    stormPhase++;
                    startStormTimer();
                }
            }, 1000);
        }
        
        function updateStorm(now) {
            const playerPos2D = new THREE.Vector2(camera.position.x, camera.position.z);
            const distToStorm = playerPos2D.distanceTo(stormCenter);
            const inStorm = stormActive && distToStorm > stormRadius;

            // Storm visual is ALWAYS visible
            document.getElementById('storm-overlay').classList.toggle('in-storm', inStorm);

            // Damage Application - Player
            if (inStorm && stormDamageRate > 0) {
                if (now - player.lastStormDamage > 1000) {
                    takeDamage(stormDamageRate, camera.position, 'storm'); 
                    player.lastStormDamage = now;
                    playSound('storm_damage');
                }
            } 

            // Damage Application - Bots
            bots.forEach(bot => {
                const botPos2D = new THREE.Vector2(bot.mesh.position.x, bot.mesh.position.z);
                const botDistToStorm = botPos2D.distanceTo(stormCenter);
                const botInStorm = stormActive && botDistToStorm > stormRadius;
                
                if (botInStorm && BOT_STORM_DAMAGE > 0) {
                     if (now - (bot.lastStormDamage || 0) > 1000) {
                        bot.health = Math.max(0, bot.health - BOT_STORM_DAMAGE); 
                        bot.lastStormDamage = now;
                        showDamage(BOT_STORM_DAMAGE, bot.mesh.position.clone().setY(bot.mesh.position.y + 1), 'storm');
                        
                        if (bot.health <= 0) {
                            scene.remove(bot.mesh);
                            bots = bots.filter(b => b !== bot);
                            player.wood += 50;
                            checkWin();
                        }
                    }
                }
            });
        }

        // ===============================================================
        // === WORLD GENERATION & GEOMETRY ===============================
        // ===============================================================

        function generateTerrain() {
            const size = WORLD_SIZE;
            const segments = 128;
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            geometry.rotateX(-Math.PI / 2);

            const position = geometry.attributes.position;
            for (let i = 0; i < position.count; i++) {
                const x = position.getX(i);
                const z = position.getZ(i);
                const y = getTerrainHeight(x, z);
                position.setY(i, y);
            }
            position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50 }); 
            const terrain = new THREE.Mesh(geometry, grassMat);
            terrain.receiveShadow = true;
            scene.add(terrain);
            objects.push(terrain); 
        }

        function createTower(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+10, z, 5, 20, 5, 0x999999);
            createBox(x, h+21, z, 7, 2, 7, 0xAAAAAA);
            spawnChest(x, h+23, z); 
        }
        
        function createBuilding(x, z, size, height, depth, color, rotation) {
            const h = getTerrainHeight(x, z);
            const mesh = createBox(x, h + height/2, z, size, height, depth, color);
            mesh.rotation.y = rotation;
            spawnChest(x+size/4, h+1, z+depth/4); 
        }
        
        function createWoodHouse(x, z, size, height, depth) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+height/2, z, size, height, depth, 0x8B4513);
            createBox(x, h+height+1, z, size+2, 2, depth+2, 0x555555); 
            spawnChest(x, h+1, z); 
        }
        
        function createTree(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+2, z, 0.5, 4, 0.5, 0x8B4513, 'tree'); 
            createBox(x, h+5, z, 3, 3, 3, 0x228B22, 'tree'); 
        }

        // NEW: 5 Additional Fortnite POIs
        function generatePOIs() {
            // Original POIs
            for(let i=0; i<3; i++) {
                const x = (Math.random()-0.5)*80;
                const z = (Math.random()-0.5)*80;
                createTower(x, z);
            }

            createBuilding(-200, -200, 20, 10, 30, 0x444444, Math.PI/2);
            createWoodHouse(-200, 200, 10, 12, 15); 
            createBuilding(250, 250, 15, 8, 15, 0xFF7F50, 0); 
            createBox(-250, getTerrainHeight(-250, 250)+0.1, 250, 50, 0.2, 50, 0x00BFFF); 
            createBox(-250, getTerrainHeight(-250, -250)-5, -250, 30, 10, 30, 0x696969); 
            createWoodHouse(-280, 0, 10, 8, 10); 
            createBox(280, getTerrainHeight(280, 0)+5, 0, 10, 10, 10, 0xFF6347); 
            createBuilding(50, 200, 12, 6, 12, 0x808080, Math.PI/4); 
            createWoodHouse(150, -100, 20, 5, 20); 
            createBox(-150, getTerrainHeight(-150, 100)+10, 100, 2, 20, 10, 0x000000); 
            createBox(100, getTerrainHeight(100, -250)-10, -250, 40, 20, 40, 0x222222); 
            createBox(-100, getTerrainHeight(-100, -300)+0.1, -300, 30, 0.2, 30, 0x00FF7F); 
            createBuilding(300, 150, 18, 10, 18, 0x9370DB, -Math.PI/4); 
            createBox(0, getTerrainHeight(0, 300), 300, 40, 0.5, 40, 0xADD8E6); 
            createBox(300, getTerrainHeight(300, -300)+15, -300, 8, 30, 8, 0xEEEEEE); 
            createBox(-300, getTerrainHeight(-300, 150)+0.5, 150, 25, 1, 25, 0xF4A460); 
            createWoodHouse(200, 0, 20, 10, 10); 

            // NEW FORTNITE POIs (5 additional)
            
            // 1. Boney Burbs (Desert Village)
            for(let i=0; i<3; i++) {
                for(let j=0; j<3; j++) {
                    const x = -350 + (i*25);
                    const z = -250 + (j*25);
                    createBox(x, getTerrainHeight(x, z)+0.5, z, 8, 6, 8, 0xD2B48C);
                }
            }
            createBox(-325, getTerrainHeight(-325, -225)+10, -225, 5, 20, 5, 0x8B7355);
            
            // 2. Coney Crossroads (Amusement Park)
            createBox(350, getTerrainHeight(350, -350)+0.1, -350, 60, 0.5, 60, 0xFF6B6B);
            for(let i=0; i<4; i++) {
                const angle = (i*Math.PI*2)/4;
                const x = 350 + Math.cos(angle)*30;
                const z = -350 + Math.sin(angle)*30;
                createBuilding(x, z, 10, 8, 10, 0xFFD166, angle);
            }
            createBox(350, getTerrainHeight(350, -350)+15, -350, 5, 30, 5, 0x06D6A0);
            
            // 3. Logjam Lumberyard (Industrial Wood)
            for(let i=0; i<8; i++) {
                const x = 400 + (Math.random()-0.5)*40;
                const z = 150 + (Math.random()-0.5)*40;
                createTree(x, z);
            }
            createBuilding(400, 150, 25, 12, 25, 0x8B4513, 0);
            createBox(380, getTerrainHeight(380, 170)+6, 170, 20, 2, 20, 0xA0522D);
            
            // 4. Sleepy Sound (Coastal Town)
            createBox(-400, getTerrainHeight(-400, 400)+0.1, 400, 80, 0.5, 60, 0x1E90FF);
            for(let i=0; i<5; i++) {
                const x = -430 + (i*20);
                createWoodHouse(x, 380, 8, 7, 8);
            }
            createBox(-420, getTerrainHeight(-420, 420)+12, 420, 4, 24, 4, 0x708090);
            
            // 5. Shifty Shafts (Underground Mining)
            createBox(0, getTerrainHeight(0, -400)-10, -400, 50, 20, 50, 0x696969);
            createBuilding(20, -380, 15, 8, 15, 0x333333, Math.PI/4);
            createBuilding(-20, -420, 15, 8, 15, 0x333333, -Math.PI/4);
            createBox(0, getTerrainHeight(0, -400)+5, -400, 10, 10, 10, 0xFFD700);

            // Original Trees (additional)
            for(let i=0; i<50; i++) {
                const x = (Math.random()-0.5)*400;
                const z = (Math.random()-0.5)*400;
                createTree(x, z);
            }
        }

        function spawnCars() {
            for(let i=0; i<4; i++) {
                const x = (Math.random()-0.5)*200;
                const z = (Math.random()-0.5)*200;
                const h = getTerrainHeight(x, z);
                
                const carGroup = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 5), new THREE.MeshStandardMaterial({color: Math.random() * 0xffffff}));
                body.position.y = 1;
                carGroup.add(body);
                
                carGroup.position.set(x, h, z); 
                scene.add(carGroup);
                
                cars.push({ mesh: carGroup, speed: 0, rotationY: carGroup.rotation.y, driving: false, raycaster: new THREE.Raycaster() });
            }
        }

        function spawnChest(x, y, z) {
            const chest = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1), new THREE.MeshStandardMaterial({color: 0xFFD700}));
            chest.position.set(x, y, z);
            scene.add(chest);
            chests.push(chest);
        }
        
        function createBotMesh(x, y, z) {
            const group = new THREE.Group();
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({color: 0xFFA07A}));
            head.position.y = 2.4; 
            group.add(head);

            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.5), new THREE.MeshStandardMaterial({color: 0x007bff}));
            body.position.y = 1.6;
            group.add(body);

            const legGeo = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const legMat = new THREE.MeshStandardMaterial({color: 0x444444});
            const legL = new THREE.Mesh(legGeo, legMat);
            legL.position.set(-0.3, 0.6, 0);
            const legR = new THREE.Mesh(legGeo, legMat);
            legR.position.set(0.3, 0.6, 0);
            group.add(legL);
            group.add(legR);

            group.position.set(x, y, z);
            return group;
        }

        function spawnBots() {
            for(let i=0; i<BOT_COUNT; i++) { 
                let x, z;
                do {
                    x = (Math.random()-0.5)*WORLD_SIZE*0.8;
                    z = (Math.random()-0.5)*WORLD_SIZE*0.8;
                } while (Math.abs(x) < 100 && Math.abs(z) < 100); 

                const h = getTerrainHeight(x, z);
                
                const mesh = createBotMesh(x, h + 1, z);
                scene.add(mesh);
                
                const botWeapon = createWeaponItem(BOT_WEAPON_KEY, 'COMMON');
                botWeapon.stats.currentMag = botWeapon.stats.mag; 
                
                bots.push({ 
                    mesh: mesh, 
                    health: 200, 
                    shield: 100, 
                    target: null, 
                    lastShot: 0, 
                    weapon: botWeapon, 
                    lastMove: performance.now(),
                    velocity: new THREE.Vector3(0, 0, 0),
                    lastStormDamage: 0,
                    moveCooldown: 0, 
                    currentDirection: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize() 
                });
            }
        }

        // ===============================================================
        // === ITEM & HEALING LOGIC (UPDATED: Swap functionality) ========
        // ===============================================================

        function useHealingItem() {
            const item = player.inventory[player.slot];
            
            if (player.isHealing) {
                if (!player.healingItem.continuous) finishHealing();
                return;
            }

            if (!item || item.category !== 'consumable' || item.count <= 0) return;
            
            if (item.instant) {
                 if (item.type === 'shield' && (player.shield < item.max || player.overshield < OVER_SHIELD_MAX)) {
                    if(player.shield < 100) {
                        player.shield = Math.min(item.max, player.shield + item.val);
                    } else if (player.overshield < OVER_SHIELD_MAX) {
                        player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + item.val);
                    } else {
                        return; 
                    }
                    item.count -= 1; 
                    if (item.count <= 0) player.inventory[player.slot] = null;
                    updateUI();
                    playSound('use_mini');
                    if (player.overshield < OVER_SHIELD_MAX) {
                        player.lastOvershieldDamage = performance.now();
                        player.lastOvershieldBreak = performance.now();
                    }
                    return;
                }
            }

            let canUse = false;
            if (item.type === 'shield' && (player.shield < item.max || player.overshield < OVER_SHIELD_MAX)) canUse = true;
            if (item.type === 'health' && player.health < item.max) canUse = true;
            if (item.type === 'continuous') canUse = (player.health < 100 || player.shield < 100 || player.overshield < OVER_SHIELD_MAX);

            if (canUse) {
                player.isHealing = true;
                player.healingItem = item;
                player.healingStartTime = performance.now();
                document.getElementById('healing-progress').style.display = 'block';
                document.getElementById('healing-text').innerText = `USING ${item.name.toUpperCase()}...`;
                updateUI();
                
                if (!item.continuous && !item.instant) {
                    playSound('use_timed_start');
                    setTimeout(() => {
                        if(player.isHealing && player.healingItem === item) {
                            applyHealing(item);
                            finishHealing();
                            playSound('use_timed_finish');
                        }
                    }, item.time);
                } else if (item.continuous) {
                    playSound('use_chug_start');
                }
            }
        }
        
        function applyHealing(item) {
            if (item.type === 'shield') {
                player.shield = Math.min(item.max, player.shield + item.val); 
            } else if (item.type === 'health') {
                player.health = Math.min(item.max, player.health + item.val);
            } 
            
            item.count -= 1;
            if (item.count <= 0) {
                const slotIndex = player.inventory.findIndex(i => i === item);
                if (slotIndex !== -1) player.inventory[slotIndex] = null;
            }
            updateUI();
        }
        
        function applyContinuousHealing(item, dt) {
            const timeElapsed = performance.now() - player.healingStartTime;
            const percentage = Math.min(1, timeElapsed / item.time);
            document.getElementById('healing-bar').style.width = `${percentage * 100}%`;
            
            const interval = 1000; 
            if (!player.lastHealTick || (performance.now() - player.lastHealTick) >= interval) {
                if(player.overshield < OVER_SHIELD_MAX) {
                    player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + item.shieldVal); 
                    player.lastOvershieldBreak = performance.now();
                } else if(player.shield < 100) {
                    player.shield = Math.min(100, player.shield + item.shieldVal); 
                } else if (player.health < 100) {
                    player.health = Math.min(100, player.health + item.val);
                }
                updateUI();
                player.lastHealTick = performance.now();
            }

            if (timeElapsed >= item.time || (player.health === 100 && player.shield === 100 && player.overshield === OVER_SHIELD_MAX)) {
                finishHealing();
                playSound('use_chug_finish');
            }
        }

        function finishHealing() {
            if (!player.isHealing) return; 

            player.isHealing = false;
            
            const item = player.healingItem;
            if (item && item.continuous) {
                 item.count -= 1;
                 if (item.count <= 0) {
                    const slotIndex = player.inventory.findIndex(i => i === item);
                    if (slotIndex !== -1) player.inventory[slotIndex] = null;
                 }
            }

            player.healingItem = null;
            player.lastHealTick = 0;
            document.getElementById('healing-progress').style.display = 'none';
            
            updateUI();
        }

        // UPDATED: Enhanced swap functionality between guns and healing items
        function tryInteract() {
            const pos = camera.position;
            
            // Check Doors
            for(let door of doors) {
                if(pos.distanceTo(door.mesh.position) < 5) {
                    door.open = !door.open;
                    const rotation = door.open ? door.initialRotation + Math.PI / 2 : door.initialRotation;
                    door.mesh.rotation.y = rotation;
                    
                    const shiftDir = new THREE.Vector3();
                    shiftDir.setFromEuler(new THREE.Euler(0, door.initialRotation + Math.PI / 4, 0));
                    door.mesh.position.sub(shiftDir.multiplyScalar(0.75)); 
                    playSound('open_door');
                    if (player.isHealing) finishHealing();
                    return;
                }
            }

            // Check Cars
            for(let c of cars) {
                if(pos.distanceTo(c.mesh.position) < 5) {
                    if(player.vehicle) {
                        player.vehicle.driving = false;
                        player.vehicle = null;
                        camera.position.y += 2; 
                        camera.position.x = c.mesh.position.x + 5; 
                        camera.position.z = c.mesh.position.z + 5; 
                        playSound('exit_vehicle');
                    } else {
                        if (player.isHealing) finishHealing();
                        player.vehicle = c;
                        c.driving = true;
                        playSound('enter_vehicle');
                    }
                    updateUI();
                    return;
                }
            }
            
            // Check Chests
            for(let i=chests.length-1; i>=0; i--) {
                if(pos.distanceTo(chests[i].position) < 4) {
                    const chestPos = chests[i].position.clone();
                    scene.remove(chests[i]);
                    chests.splice(i, 1);
                    
                    if (player.isHealing) finishHealing();

                    const randomWeaponKey = getRandomWeaponKey();
                    const randomRarity = getRandomRarity();
                    spawnLoot(chestPos.x + 0.5, chestPos.y, chestPos.z + 0.5, 'weapon', randomRarity, randomWeaponKey);
                    
                    const randomConsumableKey = getRandomConsumableKey();
                    spawnLoot(chestPos.x - 0.5, chestPos.y, chestPos.z - 0.5, 'consumable', randomConsumableKey);
                    
                    if (Math.random() < 0.3) {
                        spawnLoot(chestPos.x, chestPos.y, chestPos.z, 'weapon', getRandomRarity(), getRandomWeaponKey());
                    }
                    
                    playSound('open_chest');
                    return;
                }
            }

            // UPDATED: Enhanced loot pickup with better swap logic
            for(let i=loot.length-1; i>=0; i--) {
                const currentLoot = loot[i];
                if(pos.distanceTo(currentLoot.mesh.position) < 4) {
                    const currentItem = player.inventory[player.slot];
                    
                    if (player.isHealing) finishHealing();

                    // Always try to stack consumables first
                    if (currentLoot.data.category === 'consumable') {
                        const stackSlot = player.inventory.find(item => item && item.name === currentLoot.data.name && item.count < item.maxStack);
                        if (stackSlot) {
                            stackSlot.count = Math.min(stackSlot.maxStack, stackSlot.count + currentLoot.data.count);
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            return;
                        }
                    }

                    // UPDATED: You can swap guns for healing items and vice versa
                    // If slot has item and we're picking up a different type, offer swap
                    if (currentItem) {
                        // Different categories (gun vs healing) - allow swap
                        if (currentItem.category !== currentLoot.data.category) {
                            if(confirm(`Swap ${currentItem.name} for ${currentLoot.data.name}?`)) {
                                dropItem(player.slot, currentLoot.mesh.position.clone().add(new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2)));
                                giveItem(currentLoot.data, player.slot);
                                scene.remove(currentLoot.mesh);
                                loot.splice(i, 1);
                                updateUI();
                                playSound('pickup_item');
                                return;
                            }
                        } 
                        // Same category - check if we want to replace
                        else if (currentLoot.data.category === 'weapon') {
                            if(confirm(`Replace ${currentItem.name} with ${currentLoot.data.name}?`)) {
                                dropItem(player.slot, currentLoot.mesh.position.clone().add(new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2)));
                                giveItem(currentLoot.data, player.slot);
                                scene.remove(currentLoot.mesh);
                                loot.splice(i, 1);
                                updateUI();
                                playSound('pickup_item');
                                return;
                            }
                        }
                    } else {
                        // Empty slot - just pick up
                        if(giveItem(currentLoot.data, player.slot)) {
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            playSound('pickup_item');
                            return;
                        }
                    }
                }
            }
            
            // Check Resources
            for (let b of buildings) {
                if (b.type === 'tree' && pos.distanceTo(b.mesh.position) < 5) {
                    player.wood += 5;
                    updateUI();
                    
                    b.health -= 50; 
                    if (b.health <= 0) {
                        scene.remove(b.mesh);
                        objects = objects.filter(obj => obj !== b.mesh);
                        buildings = buildings.filter(bldg => bldg !== b);
                        playSound('harvest_break');
                    } else {
                        playSound('harvest_hit');
                    }
                    return;
                }
            }
            
            // If no other interaction, try to use healing item
            useHealingItem();
        }
        
        function dropItem(slotIndex, position) {
            const itemToDrop = player.inventory[slotIndex];
            if (!itemToDrop) return;
            
            if (player.isHealing && player.healingItem === itemToDrop) {
                finishHealing();
            }

            spawnLoot(position.x, position.y + 1, position.z, itemToDrop);
            player.inventory[slotIndex] = null;
            playSound('drop_item');
        }

        function createWeaponItem(typeKey, rarityKey) {
            const base = WEAPONS_BASE[typeKey];
            const rar = RARITY_MULTIPLIERS[rarityKey];
            
            return {
                category: 'weapon',
                name: base.name,
                rarity: rar,
                stats: { 
                    ...base, 
                    dmg: base.dmg * rar.dmg, 
                    head: base.head * rar.dmg, 
                    reload: base.reload * rar.reload, 
                    currentMag: base.mag 
                }, 
                maxAmmo: base.mag
            };
        }
        
        function getRandomRarity() {
            const rarityPool = ['COMMON', 'COMMON', 'UNCOMMON', 'UNCOMMON', 'RARE', 'EPIC', 'LEGENDARY'];
            return rarityPool[Math.floor(Math.random() * rarityPool.length)];
        }

        function getRandomWeaponKey() {
            const keys = Object.keys(WEAPONS_BASE).filter(k => k !== MYTHIC_WEAPON_KEY && k !== 'ROCKET_LAUNCHER');
            return keys[Math.floor(Math.random() * keys.length)];
        }

        function getRandomConsumableKey() {
            return CONSUMABLE_KEYS[Math.floor(Math.random() * CONSUMABLE_KEYS.length)];
        }

        // UPDATED: Better item giving with category handling
        function giveItem(itemData, slot) {
            if (itemData.category === 'weapon') {
                player.inventory[slot] = itemData;
            } else if (itemData.category === 'consumable') {
                const existing = player.inventory.find(i => i && i.name === itemData.name);
                if (existing) {
                    existing.count = Math.min(existing.maxStack, existing.count + itemData.count);
                } else if (player.inventory[slot] === null) {
                    player.inventory[slot] = itemData;
                } else {
                    return false; 
                }
            } else if (itemData === 'mythic') {
                const mythicWeapon = createWeaponItem(MYTHIC_WEAPON_KEY, 'MYTHIC');
                player.inventory[slot] = mythicWeapon;
            }
            return true;
        }

        function spawnLoot(x, y, z, type, rarity = null, weaponKey = null) {
            let item;
            if(type === 'weapon' || type === 'mythic') {
                const typeKey = type === 'mythic' ? MYTHIC_WEAPON_KEY : (weaponKey || getRandomWeaponKey());
                const rarityKey = type === 'mythic' ? 'MYTHIC' : (rarity || getRandomRarity());
                item = createWeaponItem(typeKey, rarityKey);
            } else if (type === 'consumable') {
                const consKey = rarity; 
                const base = CONSUMABLES[consKey];
                item = { category: 'consumable', ...base, count: 1 };
                item.rarity = RARITY_MULTIPLIERS[base.rarity]; 
            } else if (typeof type === 'object') {
                item = type; 
                if (item.category === 'consumable' && typeof item.rarity === 'string') {
                    item.rarity = RARITY_MULTIPLIERS[item.rarity];
                }
            } else {
                return;
            }

            let color = 0x808080;
            if (item.rarity && item.rarity.color) color = parseInt(item.rarity.color.substring(1), 16);
            else if (item.category === 'consumable') color = 0x00d2ff;

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({color: color}));
            mesh.position.set(x, y, z);
            scene.add(mesh);
            loot.push({ mesh: mesh, data: item });
        }

        // ===============================================================
        // === SHOOTING & DAMAGE SYSTEM ==================================
        // ===============================================================

        function shoot(item, isBurst = false) {
            if (item.stats.currentMag <= 0 || player.isReloading || player.isHealing) {
                if (!player.isReloading) reload();
                return;
            }
            
            if (player.isHealing) finishHealing();

            if (item.stats.burst && !isBurst) {
                if (player.isBursting) return;
                player.isBursting = true;
                player.burstCount = 0;
                
                const burstShot = () => {
                    if (player.burstCount < item.stats.burst && item.stats.currentMag > 0) {
                        doSingleShot(item);
                        player.burstCount++;
                        player.burstTimer = setTimeout(burstShot, 100); 
                    } else {
                        player.isBursting = false;
                        if (item.stats.currentMag > 0) {
                             player.burstTimer = setTimeout(() => {}, item.stats.burstDelay);
                        }
                    }
                };
                burstShot();
                return;
            } else if (item.stats.burst && isBurst) {
                doSingleShot(item);
                return;
            }
            
            doSingleShot(item);
        }
        
        function doSingleShot(item) {
            const fireOrigin = camera.position.clone();
            const fireDirection = new THREE.Vector3();
            camera.getWorldDirection(fireDirection);

            playSound('shoot');
            
            if (item.stats.bulletType === 'hitscan') {
                handleHitscan(item, fireOrigin, fireDirection, player);
            } else if (item.stats.bulletType === 'projectile') {
                handleProjectile(item, fireOrigin, fireDirection);
            }
            
            item.stats.currentMag -= 1;
            lastShot = performance.now();
            updateUI();
        }

        function handleHitscan(item, fireOrigin, fireDirection, shooter) {
            const spread = shooter === player ? (player.ads ? 0.005 : item.stats.spread) : item.stats.spread; 
            
            for(let p = 0; p < item.stats.pellets; p++) {
                
                const ray = new THREE.Raycaster(fireOrigin);
                const spreadDir = fireDirection.clone();
                
                const randomX = (Math.random() - 0.5) * spread;
                const randomY = (Math.random() - 0.5) * spread;
                spreadDir.x += randomX;
                spreadDir.y += randomY;
                spreadDir.normalize();

                if (shooter !== player && Math.random() < 0.3) { 
                    spreadDir.x += (Math.random() - 0.5) * 0.5;
                    spreadDir.y += (Math.random() - 0.5) * 0.5;
                    spreadDir.normalize();
                }

                ray.ray.direction.copy(spreadDir);

                const targets = bots.map(b => b.mesh).concat(objects).concat(cars.map(c=>c.mesh));
                const hits = ray.intersectObjects(targets, true);
                
                if(hits.length > 0) {
                    const hit = hits[0];
                    let hitBot = null;
                    let hitPlayer = false;
                    let isHeadshot = false;

                    let obj = hit.object;
                    while(obj && obj.parent && obj.parent.type !== 'Scene') {
                        const b = bots.find(bot => bot.mesh === obj.parent);
                        if(b) { hitBot = b; break; }
                        obj = obj.parent;
                    }
                    if(!hitBot) hitBot = bots.find(bot => bot.mesh === hit.object);
                    
                    if (shooter !== player) {
                        const playerDist = hit.point.distanceTo(camera.position);
                        if (playerDist < 2 && hit.distance < item.stats.range) hitPlayer = true; 
                    }

                    if(hitBot && hitBot !== shooter) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > hitBot.mesh.position.y + 2.2) { 
                            dmg = item.stats.head; 
                            isHeadshot = true;
                        }
                        applyDamage(hitBot, dmg, hit.point, shooter, isHeadshot);
                    } else if (hitPlayer) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > camera.position.y + 0.5) { 
                            dmg = item.stats.head; 
                        }
                        takeDamage(dmg, hit.point); 
                        playSound('player_hit');
                    } else {
                        const buildingHit = buildings.find(b => b.mesh === hit.object);
                        if (buildingHit) {
                            if (buildingHit.type !== 'indestructible_wood') {
                                buildingHit.health -= 50; 
                                if (buildingHit.health <= 0) {
                                    scene.remove(buildingHit.mesh);
                                    objects = objects.filter(obj => obj !== buildingHit.mesh);
                                    buildings = buildings.filter(bldg => bldg !== buildingHit);
                                }
                            }
                        }
                        playSound('impact_hit');
                    }
                }
            }
        }
        
        function handleProjectile(item, fireOrigin, fireDirection) {
            const rocketGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const rocketMat = new THREE.MeshBasicMaterial({ color: 0xff4d4d });
            const rocketMesh = new THREE.Mesh(rocketGeo, rocketMat);
            rocketMesh.position.copy(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(1))); 
            scene.add(rocketMesh);
            
            projectiles.push({
                mesh: rocketMesh,
                velocity: fireDirection.clone().multiplyScalar(50), 
                damage: item.stats.explosionDamage,
                radius: item.stats.explosionRadius,
                shooter: player,
                isExpired: false
            });
        }
        
        function updateProjectiles(dt) {
            for(let i=projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (p.isExpired) continue;
                
                const oldPos = p.mesh.position.clone();
                p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                
                const collisionRay = new THREE.Raycaster(oldPos, p.velocity.clone().normalize(), 0, p.mesh.position.distanceTo(oldPos));
                const targets = bots.map(b => b.mesh).concat(objects).concat(cars.map(c=>c.mesh));
                const hits = collisionRay.intersectObjects(targets, true);

                if (hits.length > 0) {
                    const hit = hits[0];
                    explode(p, hit.point);
                    p.isExpired = true; 
                }

                if (Math.abs(p.mesh.position.x) > WORLD_SIZE / 2 || Math.abs(p.mesh.position.z) > WORLD_SIZE / 2) {
                    explode(p, p.mesh.position);
                    p.isExpired = true;
                }
            }
            
            projectiles = projectiles.filter(p => !p.isExpired);
        }

        function explode(projectile, hitPoint) {
            playSound('explosion');
            
            if (hitPoint.distanceTo(camera.position) < projectile.radius) {
                const dist = hitPoint.distanceTo(camera.position);
                const reduction = Math.max(0, dist / projectile.radius);
                const damage = projectile.damage * (1 - reduction);
                takeDamage(damage, hitPoint);
            }

            bots.forEach(bot => {
                if (hitPoint.distanceTo(bot.mesh.position) < projectile.radius) {
                    const dist = hitPoint.distanceTo(bot.mesh.position);
                    const reduction = Math.max(0, dist / projectile.radius);
                    const damage = projectile.damage * (1 - reduction);
                    applyDamage(bot, damage, bot.mesh.position, projectile.shooter, false);
                }
            });
            
            scene.remove(projectile.mesh);
        }
        
        function applyDamage(target, amount, hitPoint, source, isHeadshot = false, type = 'body') {
            amount = Math.round(amount);
            let remainingDmg = amount;

            if(target === player) {
                 takeDamage(amount, hitPoint, type); 
                 return;
            }

            if(target.shield > 0) {
                target.shield -= remainingDmg;
                if(target.shield < 0) { 
                    remainingDmg = -target.shield; 
                    target.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            } 
            
            if (remainingDmg > 0) {
                target.health -= remainingDmg;
            }
            
            showDamage(amount, hitPoint, type, isHeadshot);
            
            if(target.health <= 0) {
                if (bots.includes(target)) {
                    if (source === player) player.eliminations += 1;
                    scene.remove(target.mesh);
                    bots = bots.filter(b => b !== target);
                    
                    const randomWeaponKey = getRandomWeaponKey();
                    const randomRarity = getRandomRarity(); 
                    const botWeapon = createWeaponItem(randomWeaponKey, randomRarity);
                    
                    const dropConsumableKey = getRandomConsumableKey();
                    const consumableBase = CONSUMABLES[dropConsumableKey];
                    const healingItemDrop = { 
                        category: 'consumable', 
                        ...CONSUMABLES[dropConsumableKey], 
                        count: 1, 
                        rarity: consumableBase.rarity 
                    };
                    
                    spawnLoot(hitPoint.x + 1, hitPoint.y, hitPoint.z, botWeapon); 
                    spawnLoot(hitPoint.x - 1, hitPoint.y, hitPoint.z, healingItemDrop); 
                    player.wood += 50; 
                    
                    playSound('elimination');
                    checkWin();
                }
            }
        }
        
        function takeDamage(amount, sourcePoint, type = 'body') {
            amount = Math.floor(amount);
            if (amount <= 0 || player.dead) return;
            
            let remainingDmg = amount;
            
            // Track when overshield is broken
            const overshieldBefore = player.overshield;
            
            // Damage Overshield first
            if(player.overshield > 0) {
                player.overshield -= remainingDmg;
                if(player.overshield < 0) { 
                    remainingDmg = -player.overshield; 
                    player.overshield = 0; 
                    
                    // UPDATED: Mark when overshield breaks
                    if (overshieldBefore > 0) {
                        player.lastOvershieldBreak = performance.now();
                    }
                } else {
                    remainingDmg = 0;
                }
                player.lastOvershieldDamage = performance.now();
            }

            // Damage Shield
            if (remainingDmg > 0 && player.shield > 0) {
                player.shield -= remainingDmg;
                if(player.shield < 0) { 
                    remainingDmg = -player.shield; 
                    player.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            }
            
            // Damage Health
            if (remainingDmg > 0) {
                player.health -= remainingDmg;
            }
            
            showDamage(amount, camera.position.clone().setY(camera.position.y - 0.5), type); 
            updateUI();
            
            if(player.health <= 0) {
                player.dead = true;
                handleGameOver(false);
            }
        }

        // UPDATED: Overshield regen - regenerates to full after 7 seconds when broken
        function overshieldRegen(dt) {
             if (player.dead || player.overshield === OVER_SHIELD_MAX) return;

             const timeSinceDamage = performance.now() - player.lastOvershieldDamage;
             const timeSinceBreak = performance.now() - player.lastOvershieldBreak;
             
             // Only regenerate if:
             // 1. Not taking damage for 7 seconds
             // 2. Overshield was broken at least 7 seconds ago
             if (timeSinceDamage >= OVER_SHIELD_REGEN_DELAY && timeSinceBreak >= OVER_SHIELD_REGEN_DELAY) {
                 // Regenerate to full
                 player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + (OVER_SHIELD_REGEN_RATE * dt));
                 updateUI();
             }
        }

        // ===============================================================
        // === BOT AI & LIFE CYCLE =======================================
        // ===============================================================

        function findClosestTarget(bot) {
            if (player.health > 0 && !player.dead) {
                return player;
            } else {
                return null; 
            }
        }

        function updateBots(dt, now) {
            document.getElementById('alive-count').innerText = bots.length + 1;
            const BOT_MOVE_SPEED = WALK_SPEED * 0.3; 
            const BOT_MOVE_COOLDOWN_RANGE = 2000; 

            for(let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];
                if (bot.health <= 0) continue;

                const h = getTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                bot.mesh.position.y = h + 1; 

                const target = findClosestTarget(bot);
                
                if(target) {
                    const targetPos = camera.position; 
                    const dist = bot.mesh.position.distanceTo(targetPos);
                    
                    if (dist < 30) {
                        bot.mesh.lookAt(targetPos.x, bot.mesh.position.y + 2.4, targetPos.z);
                        
                        if(dist > 15) {
                            bot.mesh.translateZ(BOT_MOVE_SPEED * dt * 2); 
                        } else if (dist < 8) {
                            bot.mesh.rotation.y += Math.PI/2 * (Math.random() > 0.5 ? 1 : -1) * dt;
                            bot.mesh.translateZ(BOT_MOVE_SPEED * dt);
                        } else {
                            bot.mesh.translateZ(BOT_MOVE_SPEED * dt * 0.5);
                        }
                        
                        bot.moveCooldown = 1000; 

                        const weaponStats = bot.weapon.stats; 
                        if(dist < weaponStats.range && now - bot.lastShot > weaponStats.rate * 1000) { 
                            bot.lastShot = now;
                            
                            const fireOrigin = bot.mesh.position.clone().setY(bot.mesh.position.y + 2.4);
                            const fireDirection = new THREE.Vector3();
                            fireDirection.subVectors(targetPos.clone().setY(targetPos.y - 0.5), fireOrigin).normalize();

                            handleHitscan(bot.weapon, fireOrigin, fireDirection, bot);
                        }
                    } else {
                        bot.moveCooldown -= dt * 1000;
                        if (bot.moveCooldown <= 0) {
                            bot.currentDirection = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                            bot.mesh.lookAt(bot.mesh.position.clone().add(bot.currentDirection));
                            bot.moveCooldown = Math.random() * BOT_MOVE_COOLDOWN_RANGE + 1000;
                        }
                        bot.mesh.translateZ(BOT_MOVE_SPEED * dt);
                    }
                } else {
                    bot.moveCooldown -= dt * 1000;
                    if (bot.moveCooldown <= 0) {
                        bot.currentDirection = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                        bot.mesh.lookAt(bot.mesh.position.clone().add(bot.currentDirection));
                        bot.moveCooldown = Math.random() * BOT_MOVE_COOLDOWN_RANGE + 1000;
                    }
                    bot.mesh.translateZ(BOT_MOVE_SPEED * dt);
                }
            }
        }

        // ===============================================================
        // === VEHICLE LOGIC =============================================
        // ===============================================================

        function updateCars(dt) {
            for(const car of cars) {
                if(car.driving) {
                    const speed = inputs.w ? 15 : inputs.s ? -5 : 0;
                    car.speed = THREE.MathUtils.lerp(car.speed, speed, 0.1);

                    if (inputs.a || inputs.d) {
                        const rotationSpeed = dt * 1.5 * (inputs.d ? -1 : 1);
                        car.mesh.rotation.y += rotationSpeed * Math.sign(car.speed || 1);
                    }
                    
                    car.mesh.translateZ(car.speed * dt);
                    
                    if (Math.abs(car.speed) > 5) {
                        const currentPos = car.mesh.position;
                        
                        bots.forEach(bot => {
                            if (currentPos.distanceTo(bot.mesh.position) < 3) {
                                applyDamage(bot, 100, bot.mesh.position, player);
                            }
                        });
                    }

                    const h = getTerrainHeight(car.mesh.position.x, car.mesh.position.z);
                    car.mesh.position.y = h;

                    if(player.vehicle === car) {
                        camera.position.copy(car.mesh.position).add(new THREE.Vector3(0, PLAYER_HEIGHT + 1, 0));
                    }
                }
            }
        }

        // ===============================================================
        // === REVOLUTIONARY UI FUNCTIONS ================================
        // ===============================================================
        
        function updateUI() {
            player.health = Math.max(0, Math.min(100, player.health));
            player.shield = Math.max(0, Math.min(100, player.shield));
            player.overshield = Math.max(0, Math.min(OVER_SHIELD_MAX, player.overshield));
            
            // Update values
            document.getElementById('health-value').innerText = Math.ceil(player.health);
            document.getElementById('shield-value').innerText = Math.ceil(player.shield);
            document.getElementById('overshield-value').innerText = Math.ceil(player.overshield);
            document.getElementById('wood-value').innerText = player.wood;
            
            // Update bars
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('shield-bar').style.width = player.shield + '%';
            document.getElementById('overshield-bar').style.width = (player.overshield / OVER_SHIELD_MAX) * 100 + '%';
            
            // Update inventory slots
            player.inventory.forEach((item, i) => {
                const slot = document.getElementById(`slot-${i}`);
                slot.innerHTML = '';
                
                if(item) {
                    const icon = item.category === 'weapon' ? item.stats.icon : item.icon;
                    const name = item.name; 
                    const count = item.category === 'consumable' ? item.count : '';
                    
                    slot.innerHTML = `
                        <div class="slot-key">${i+1}</div>
                        <div class="slot-icon">${icon}</div>
                        <div class="slot-name">${name}</div>
                        ${count ? `<div class="slot-count">${count}</div>` : ''}
                    `;
                    
                    let rarityKey = '';
                    if (item.rarity && item.rarity.color) {
                        const rarityEntry = Object.entries(RARITY_MULTIPLIERS).find(([, value]) => value === item.rarity);
                        if (rarityEntry) {
                            rarityKey = rarityEntry[0].toLowerCase(); 
                        } else if (typeof item.rarity === 'string') {
                            rarityKey = item.rarity.toLowerCase();
                        }
                    }
                    
                    slot.className = `inventory-slot ${i===player.slot ? 'active' : ''} rarity-${rarityKey}`;
                } else {
                    slot.className = `inventory-slot ${i===player.slot ? 'active' : ''}`;
                    slot.innerHTML = `<div class="slot-key">${i+1}</div>`;
                }
            });
            
            // Update interaction prompt
            let msg = "Interact (E)";
            const pos = camera.position;
            const nearestChest = chests.some(c => pos.distanceTo(c.position) < 6);
            const nearestLoot = loot.some(l => pos.distanceTo(l.mesh.position) < 4);
            const nearestDoor = doors.some(d => pos.distanceTo(d.mesh.position) < 5);
            const nearestCar = cars.some(c => pos.distanceTo(c.mesh.position) < 5);

            const showInteract = nearestChest || nearestLoot || nearestDoor || nearestCar || player.vehicle;
            
            if (!showInteract) {
                const currentItem = player.inventory[player.slot];
                if (currentItem && currentItem.category === 'consumable' && currentItem.count > 0 && 
                    ((currentItem.type === 'shield' && (player.shield < 100 || player.overshield < OVER_SHIELD_MAX)) || (currentItem.type === 'health' && player.health < 100) || currentItem.type === 'continuous')) {
                     msg = player.isHealing ? `Cancel Healing (E)` : `Use ${currentItem.name} (E)`;
                     document.getElementById('interact-prompt').style.display = 'block';
                } else {
                    document.getElementById('interact-prompt').style.display = 'none';
                }
            } else {
                 if (player.vehicle) msg = "Exit Vehicle (E)";
                 else if (nearestChest) msg = "Open Chest (E)";
                 else if (nearestLoot) msg = "Pickup/Swap (E)";
                 else if (nearestDoor) msg = "Open Door (E)";
                 else if (nearestCar) msg = "Enter Vehicle (E)";
                 document.getElementById('interact-prompt').style.display = 'block';
            }
            
            document.getElementById('interact-prompt').innerText = msg;
            
            // Update reload button visibility for mobile
            const item = player.inventory[player.slot];
            const isWeapon = item && item.category === 'weapon';
            const showReload = isWeapon && item.stats.currentMag < item.stats.mag;
            document.getElementById('btn-reload').style.display = isMobileMode && isWeapon && showReload && !player.isReloading ? 'flex' : 'none';
        }
        
        function switchSlot(idx) {
            if (player.isHealing) {
                const currentHealingSlot = player.inventory.findIndex(i => i === player.healingItem);
                if (currentHealingSlot === player.slot && !player.healingItem.continuous) {
                    finishHealing();
                } else if (currentHealingSlot !== player.slot) {
                    finishHealing();
                }
            }

            if(idx < 0 || idx > 4) return;
            player.slot = idx;
            
            // Update slot visuals
            document.querySelectorAll('.inventory-slot').forEach((el, i) => {
                el.classList.toggle('active', i === idx);
            });
            
            // Update weapon model
            if(viewModel) weaponScene.remove(viewModel);
            const item = player.inventory[idx];
            
            if(item && item.category === 'weapon') {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
                const color = item.rarity && item.rarity.color ? item.rarity.color : '#FFFFFF'; 
                const mat = new THREE.MeshStandardMaterial({ color: color });
                viewModel = new THREE.Mesh(geo, mat);
                viewModel.position.set(0.2, -0.2, -0.5);
                weaponScene.add(viewModel);
                
                toggleADS(player.ads); 
            } else {
                document.getElementById('crosshair').style.display = 'block';
                toggleADS(false);
            }
            
            updateUI(); 
        }
        
        // Mobile-specific slot selection
        function selectSlotMobile(idx) {
            if (isMobileMode) {
                switchSlot(idx);
            }
        }

        // ===============================================================
        // === INPUT & CONTROL MANAGEMENT (UPDATED: Stabilized Mobile) ===
        // ===============================================================
        
        function setMobileMode(enable) {
            isMobileMode = enable;
            const mobileControls = document.getElementById('mobile-controls');
            const gameContainer = document.getElementById('game-container');

            if (enable) {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'block';
                gameContainer.removeEventListener('mousedown', lockPointer);
                
                // Initialize mobile controls
                initMobileControls();
            } else {
                if (controls) controls.enabled = true;
                mobileControls.style.display = 'none';
                gameContainer.addEventListener('mousedown', lockPointer);
            }
        }
        
        function lockPointer() {
            if (controls && !isMobileMode) {
                controls.lock();
                inputs.fire = false; 
            }
        }

        function setupPCLock() {
            if (controls) controls.enabled = true;
            document.getElementById('game-container').addEventListener('mousedown', lockPointer);
        }

        // UPDATED: Stabilized mobile camera controls
        function initMobileControls() {
            const touchLeft = document.getElementById('touch-left');
            const touchRight = document.getElementById('touch-right');
            const joystickThumb = document.getElementById('joystick-thumb');
            const movementZone = document.getElementById('movement-zone');
            
            // Movement joystick
            let touchStartX = 0;
            let touchStartY = 0;
            let isTouchingLeft = false;
            
            touchLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isTouchingLeft = true;
                const touch = e.touches[0];
                const rect = movementZone.getBoundingClientRect();
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            });
            
            touchLeft.addEventListener('touchmove', (e) => {
                if (!isTouchingLeft) return;
                e.preventDefault();
                const touch = e.touches[0];
                const rect = movementZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const maxDist = rect.width / 2;
                
                if(dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio;
                    dy *= ratio;
                }
                
                joystickThumb.style.transform = `translate(${dx}px, ${dy}px)`;
                
                // Movement inputs
                inputs.w = dy < -15;
                inputs.s = dy > 15;
                inputs.a = dx < -15;
                inputs.d = dx > 15;
                inputs.sprint = dist > 40;
            });
            
            touchLeft.addEventListener('touchend', (e) => {
                isTouchingLeft = false;
                joystickThumb.style.transform = `translate(-50%, -50%)`;
                inputs.w = inputs.s = inputs.a = inputs.d = inputs.sprint = false;
            });
            
            // UPDATED: Stabilized camera controls
            touchRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mobileTouchActive = true;
                const touch = e.touches[0];
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                touchDeltaX = 0;
                touchDeltaY = 0;
            });
            
            touchRight.addEventListener('touchmove', (e) => {
                if (!mobileTouchActive) return;
                e.preventDefault();
                const touch = e.touches[0];
                
                // Calculate smooth delta
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;
                
                // Apply smoothing
                touchDeltaX = touchDeltaX * (1 - MOBILE_SMOOTHING) + deltaX * MOBILE_SMOOTHING;
                touchDeltaY = touchDeltaY * (1 - MOBILE_SMOOTHING) + deltaY * MOBILE_SMOOTHING;
                
                // Apply rotation with sensitivity
                camera.rotation.y -= touchDeltaX * MOBILE_SENSITIVITY;
                camera.rotation.x -= touchDeltaY * MOBILE_SENSITIVITY;
                
                // Clamp vertical rotation to prevent going upside down
                camera.rotation.x = Math.max(-MAX_CAMERA_ANGLE, Math.min(MAX_CAMERA_ANGLE, camera.rotation.x));
                
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            });
            
            touchRight.addEventListener('touchend', (e) => {
                mobileTouchActive = false;
                touchDeltaX = 0;
                touchDeltaY = 0;
            });
            
            // Mobile button handlers
            document.getElementById('btn-fire').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                inputs.fire = true; 
            });
            document.getElementById('btn-fire').addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                inputs.fire = false; 
            });
            
            document.getElementById('btn-jump').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                inputs.jump = true; 
            });
            document.getElementById('btn-jump').addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                inputs.jump = false; 
            });
            
            document.getElementById('btn-interact').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                tryInteract(); 
            });
            
            document.getElementById('btn-build').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                buildWall(); 
            });
            
            document.getElementById('btn-ads').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                toggleADS(true); 
            });
            document.getElementById('btn-ads').addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                toggleADS(false); 
            });
            
            document.getElementById('btn-reload').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                reload(); 
            });
        }

        function setupInputs() {
            const gameContainer = document.getElementById('game-container');
            
            // PC Keyboard Controls
            const onKey = (e, v) => {
                if (!isMobileMode && controls && controls.isLocked) {
                    if(e.code === 'KeyW') inputs.w = v;
                    if(e.code === 'KeyS') inputs.s = v;
                    if(e.code === 'KeyA') inputs.a = v;
                    if(e.code === 'KeyD') inputs.d = v;
                    if(e.code === 'ShiftLeft') inputs.sprint = v;
                    
                    if(e.code === 'Space' && v) inputs.jump = true; 
                    if(e.code === 'KeyR' && v) inputs.reload = true; 
                    if(e.code === 'KeyX' && v) useHealingItem();
                }
            };
            
            document.addEventListener('keydown', e => {
                onKey(e, true);
                if(!isMobileMode && controls && controls.isLocked) {
                    if(e.code === 'Digit1') switchSlot(0);
                    if(e.code === 'Digit2') switchSlot(1);
                    if(e.code === 'Digit3') switchSlot(2);
                    if(e.code === 'Digit4') switchSlot(3);
                    if(e.code === 'Digit5') switchSlot(4);
                    if(e.code === 'KeyE') tryInteract();
                    if(e.code === 'KeyB') buildWall(); 
                }
            });
            
            document.addEventListener('keyup', e => onKey(e, false));
            
            // PC Mouse Controls
            document.addEventListener('mousedown', e => {
                if(player.dead || isMobileMode || !controls || !controls.isLocked) return;
                if(e.button === 0) inputs.fire = true;
                if(e.button === 2) toggleADS(true);
            });
            
            document.addEventListener('mouseup', e => {
                if(player.dead || isMobileMode) return;
                if(e.button === 0) inputs.fire = false;
                if(e.button === 2) toggleADS(false);
            });
            
            // Prevent context menu on right click
            document.addEventListener('contextmenu', e => e.preventDefault());
        }

        // ===============================================================
        // === INITIALIZATION & START GAME ===============================
        // ===============================================================

        function init() {
            victoryRoyales = parseInt(localStorage.getItem('victoryRoyales')) || 0;
            document.getElementById('victory-royales-stat').innerText = `üèÜ Victory Royales: ${victoryRoyales}`;
            
            // Create particles for start screen
            createParticles();
            
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false; 
            const gameContainer = document.getElementById('game-container');
            gameContainer.appendChild(renderer.domElement);
            
            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(100, 200, 100);
            sun.castShadow = true;
            sun.shadow.camera.right = 200; sun.shadow.camera.left = -200;
            sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            scene.add(sun);
            
            weaponScene.add(ambient.clone());
            weaponScene.add(sun.clone());
            
            // Controls
            controls = new PointerLockControls(camera, document.body);
            setupInputs(); 

            // Raycasters
            raycaster = new THREE.Raycaster();
            downRay = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, PLAYER_HEIGHT + 0.1);
            
            animate();
        }
        
        function createParticles() {
            const container = document.getElementById('particles-container');
            for(let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = `${Math.random() * 20 + 5}px`;
                particle.style.height = particle.style.width;
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 20}s`;
                particle.style.animationDuration = `${Math.random() * 10 + 15}s`;
                container.appendChild(particle);
            }
        }

        window.startGame = (isMobile) => {
            document.getElementById('start-screen').style.display = 'none';
            gameStarted = true;
            
            isMobileMode = isMobile;
            
            if (isMobile) {
                setMobileMode(true);
            } else {
                setMobileMode(false);
                setupPCLock(); 
            }
            
            // UPDATED: Player starts with 100 Health, 25 Shields, 50 Overshields
            player.health = 100;
            player.shield = 25;
            player.overshield = 50;
            player.wood = 0;
            player.inventory = [null, null, null, null, null];
            player.slot = 0;
            
            // Generate world
            generateTerrain(); 
            generatePOIs(); 
            spawnBots();
            spawnCars();

            // Set starting position
            camera.position.set(0, getTerrainHeight(0, 0) + PLAYER_HEIGHT + 2, 0);
            
            // Start storm timer
            startStormTimer(); 
            switchSlot(0);
            
            // Initial UI update
            updateUI();
        };

        // ===============================================================
        // === CORE GAME LOOP ============================================
        // ===============================================================

        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            if(!gameStarted || player.dead) {
                renderer.clear();
                renderer.render(scene, camera);
                return;
            }

            // Healing & Overshield Regen
            if (player.isHealing && player.healingItem) {
                if (player.healingItem.continuous) {
                    applyContinuousHealing(player.healingItem, dt);
                } else if (!player.healingItem.instant) {
                    inputs.fire = false;
                    inputs.w = inputs.a = inputs.s = inputs.d = false;
                }
            }
            overshieldRegen(dt);

            // Player Physics & Movement
            if(player.vehicle) {
                updateCars(dt);
            } else {
                const canMove = isMobileMode || (controls && controls.isLocked); 
                if (canMove) {
                    const speedMultiplier = player.ads ? 0.5 : 1.0; 
                    const currentSpeed = (inputs.sprint ? SPRINT_SPEED : WALK_SPEED) * speedMultiplier;
                    
                    const direction = new THREE.Vector3();
                    direction.setFromMatrixColumn(camera.matrix, 0); 
                    direction.crossVectors(camera.up, direction);
                    direction.y = 0;
                    direction.normalize();
                    
                    const right = new THREE.Vector3(-direction.z, 0, direction.x);

                    const yVelocity = velocity.y; 
                    velocity.set(0, yVelocity, 0); 

                    if(inputs.w) velocity.add(direction.clone().multiplyScalar(currentSpeed));
                    if(inputs.s) velocity.add(direction.clone().multiplyScalar(-currentSpeed));
                    if(inputs.a) velocity.add(right.clone().multiplyScalar(-currentSpeed));
                    if(inputs.d) velocity.add(right.clone().multiplyScalar(currentSpeed));
                    
                    camera.position.x += velocity.x * dt;
                    camera.position.z += velocity.z * dt;
                    velocity.y -= GRAVITY * dt; 
                    
                    const groundY = getTerrainHeight(camera.position.x, camera.position.z);
                    let floorY = groundY;
                    
                    downRay.ray.origin.copy(camera.position);
                    const hits = downRay.intersectObjects(objects.filter(obj => !doors.map(d=>d.mesh).includes(obj) && !buildings.some(b => b.mesh === obj && b.type === 'indestructible_wood')), false); 
                    
                    if(hits.length > 0) {
                        const closestHit = hits[0];
                        if (closestHit.point.y > groundY + 0.1) { 
                            floorY = closestHit.point.y;
                        }
                    }
                    
                    if (camera.position.y <= floorY + PLAYER_HEIGHT && velocity.y <= 0) {
                        camera.position.y = floorY + PLAYER_HEIGHT;
                        velocity.y = 0;
                        isGrounded = true;
                    } else {
                        isGrounded = false;
                    }
                    
                    if(inputs.jump && isGrounded) {
                        velocity.y = JUMP_FORCE;
                        isGrounded = false;
                        inputs.jump = false; 
                        playSound('jump');
                    }
                    
                    camera.position.y += velocity.y * dt;
                } else {
                    velocity.x = 0; 
                    velocity.z = 0;
                }
            }

            // Shooting
            const canFire = isMobileMode || (controls && controls.isLocked); 
            if(inputs.fire && !player.vehicle && !player.isHealing && canFire) {
                const item = player.inventory[player.slot];
                if(item && item.category === 'weapon') {
                    if (item.stats.burst) {
                        if (now - lastShot > item.stats.burstDelay) {
                            shoot(item);
                        }
                    } else if(now - lastShot > item.stats.rate * 1000) {
                        shoot(item);
                    }
                }
            } else if (inputs.reload) {
                reload();
                inputs.reload = false;
            }
            
            updateProjectiles(dt);

            // AI Update
            updateBots(dt, now);
            updateStorm(now); 

            // Render
            renderer.clear();
            renderer.render(scene, camera);
            renderer.clearDepth();
            renderer.render(weaponScene, weaponCamera);
            
            // UI Updates
            updateUI();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            weaponCamera.aspect = window.innerWidth / window.innerHeight;
            weaponCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.selectSlot = switchSlot;
        window.selectSlotMobile = selectSlotMobile;
        
        init();
    </script>
</body>
</html>
