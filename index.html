<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Battle Royale: V19.8 - Ultimate Edition</title>
    <style>
        /* ======================================= */
        /* === V19.8 ULTIMATE UI REDESIGN === */
        /* ======================================= */
        
        * {
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Poppins', 'Verdana', sans-serif; 
            user-select: none; 
            background: #000;
            touch-action: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            color: white;
        }

        /* FPS Counter */
        #fps-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            font-family: monospace;
            font-weight: bold;
            font-size: 1rem;
            z-index: 1000;
            border: 1px solid #00ff00;
            pointer-events: none;
        }

        /* Level System UI - ENHANCED */
        #level-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: white;
            padding: 0.8rem 1.2rem;
            border-radius: 15px;
            z-index: 1000;
            border: 2px solid rgba(0, 210, 255, 0.6);
            backdrop-filter: blur(15px);
            min-width: 250px;
            box-shadow: 0 10px 30px rgba(0, 210, 255, 0.3);
        }
        
        .level-info {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .level-text {
            font-size: 1.3rem;
            font-weight: 900;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .level-text::before {
            content: 'âš¡';
            font-size: 1.1rem;
        }
        
        .xp-progress {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .progress-container {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 0.3rem 0;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00d2ff, #0072ff, #a335ee);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.6), 
                transparent);
            animation: progressShine 2s infinite linear;
        }
        
        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .points-text {
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            min-width: 80px;
            text-align: right;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .level-perks {
            display: flex;
            gap: 0.8rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }
        
        .level-perk {
            background: rgba(0, 210, 255, 0.15);
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 600;
            color: #00d2ff;
            border: 1px solid rgba(0, 210, 255, 0.3);
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .level-perk.unlocked {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            border-color: rgba(255, 215, 0, 0.4);
        }

        /* End Game Stats */
        #endgame-stats {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
            padding: 2rem;
            border-radius: 20px;
            color: white;
            z-index: 1002;
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            min-width: 400px;
            border: 3px solid rgba(0, 210, 255, 0.4);
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8);
        }
        
        .stats-header {
            text-align: center;
            font-size: 1.8rem;
            font-weight: 900;
            color: #00d2ff;
            margin-bottom: 1rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .stat-value {
            color: #ffd700;
            font-weight: 700;
        }
        
        .total-points {
            text-align: center;
            font-size: 1.5rem;
            color: #00ff00;
            font-weight: 900;
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 10px;
            border: 2px solid #00ff00;
        }

        /* --- PRE-GAME START SCREEN (Ultimate Design) --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a2a 0%, #1a1a4a 50%, #0a0a2a 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 1000;
            text-align: center;
            animation: fadeIn 0.8s ease-out;
            overflow: hidden;
        }
        
        /* Animated background particles */
        .particles {
            position: absolute;
            width: 100%; height: 100%;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            background: rgba(0, 210, 255, 0.1);
            border-radius: 50%;
            animation: float 20s infinite linear;
        }
        
        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); }
            100% { transform: translateY(-100px) rotate(360deg); }
        }

        #start-screen h1 { 
            font-size: 5rem; 
            margin-bottom: 1rem; 
            background: linear-gradient(135deg, #00d2ff 0%, #0072ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            letter-spacing: 2px;
            animation: slideDown 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            z-index: 2;
            text-shadow: 0 10px 30px rgba(0, 210, 255, 0.3);
        }
        
        #start-screen h1::after {
            content: 'V19.8';
            display: block;
            font-size: 1.5rem;
            color: #ffd700;
            margin-top: 0.5rem;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            animation: glow 3s infinite alternate;
        }
        
        @keyframes glow {
            0% { text-shadow: 0 0 10px rgba(255, 215, 0, 0.7); }
            100% { text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 50px rgba(255, 215, 0, 0.5); }
        }

        #start-screen .subtitle { 
            font-size: 1.3rem; 
            margin-bottom: 3rem; 
            color: rgba(255,255,255,0.8);
            animation: fadeIn 1s ease-out 0.5s backwards;
            position: relative;
            z-index: 2;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
            z-index: 2;
            animation: scaleIn 0.8s ease-out 0.8s backwards;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        
        .game-button {
            padding: 1.2rem 2.5rem; 
            margin: 0; 
            font-size: 1.3rem;
            background: linear-gradient(135deg, #00d2ff, #0072ff);
            color: white; 
            border: none; 
            border-radius: 15px; 
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Poppins', sans-serif; 
            font-weight: 600;
            box-shadow: 
                0 10px 30px rgba(0, 114, 255, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        .game-button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.6s;
        }
        
        .game-button:hover::before {
            left: 100%;
        }
        
        .game-button:hover { 
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 15px 40px rgba(0, 114, 255, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        .game-button:active { 
            transform: scale(0.98) translateY(0); 
            box-shadow: 0 5px 20px rgba(0, 114, 255, 0.3);
            transition: transform 0.1s;
        }
        
        .game-button.mobile { 
            background: linear-gradient(135deg, #ffaa00, #ff6600);
        }
        
        .game-button.mobile:hover { 
            background: linear-gradient(135deg, #ff8800, #ff4400); 
        }
        
        .game-button.controller { 
            background: linear-gradient(135deg, #8a2be2, #4b0082);
        }
        
        .game-button.controller:hover { 
            background: linear-gradient(135deg, #7a1bd2, #3b0072); 
        }
        
        /* Controller Connected Notification */
        .controller-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #8a2be2, #4b0082);
            color: white;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-weight: 600;
            z-index: 1001;
            display: none;
            animation: slideInRight 0.5s ease-out;
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.4);
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        @keyframes slideInRight {
            0% { transform: translateX(100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }
        
        /* Stats display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-top: 3rem;
            animation: fadeIn 1s ease-out 1s backwards;
            position: relative;
            z-index: 2;
            max-width: 800px;
            width: 100%;
        }
        
        .stat-item {
            background: rgba(0, 0, 0, 0.6);
            padding: 1.2rem;
            border-radius: 12px;
            border: 2px solid rgba(0, 210, 255, 0.2);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
        }
        
        .stat-item:hover {
            transform: translateY(-5px);
            border-color: rgba(0, 210, 255, 0.4);
            box-shadow: 0 10px 30px rgba(0, 210, 255, 0.2);
        }
        
        .stat-item h3 {
            margin: 0 0 0.5rem 0;
            color: #00d2ff;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-item p {
            margin: 0;
            color: #ffd700;
            font-size: 1.8rem;
            font-weight: 700;
        }
        
        #victory-royales-stat {
            position: absolute; 
            bottom: 2rem; 
            font-size: 1.1rem;
            color: #ffd700; 
            font-weight: 600;
            background: rgba(0,0,0,0.7);
            padding: 1rem 2rem;
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            z-index: 2;
            animation: fadeIn 1s ease-out 1.5s backwards;
            backdrop-filter: blur(10px);
        }
        
        /* === NEW ULTIMATE CROSSHAIR === */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 32px; height: 32px; 
            transform: translate(-50%, -50%); 
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.95;
            z-index: 10;
            pointer-events: none;
            filter: drop-shadow(0 0 8px rgba(255, 77, 77, 0.7));
        }
        
        .crosshair-dot {
            position: absolute;
            width: 6px; height: 6px;
            background: #ff4d4d;
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 12px #ff4d4d,
                0 0 24px rgba(255, 77, 77, 0.7);
            animation: crosshairPulse 2s infinite alternate;
        }
        
        @keyframes crosshairPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            100% { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        .crosshair-line {
            position: absolute;
            background: #ff4d4d;
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(255, 77, 77, 0.9);
        }
        
        .ch-h { 
            width: 100%; height: 3px; 
            top: 50%; left: 0; 
            margin-top: -1.5px; 
        }
        
        .ch-v { 
            height: 100%; width: 3px; 
            left: 50%; top: 0; 
            margin-left: -1.5px; 
        }

        /* Enhanced Scopes - IMPROVED ADS */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 18%, rgba(0, 0, 0, 0.98) 19%, black 100%);
            display: none; pointer-events: none; z-index: 100; 
        }
        
        #scope-lines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(to right, rgba(255,255,255,0.1) 1px, transparent 1px) 0 0 / 25px 25px,
                linear-gradient(to bottom, rgba(255,255,255,0.1) 1px, transparent 1px) 0 0 / 25px 25px;
            opacity: 0.5;
        }
        
        #red-dot-scope {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none;
            pointer-events: none;
            background: radial-gradient(circle, transparent 45%, rgba(0,0,0,0.85) 46%, rgba(0,0,0,0.95) 100%);
        }
        
        .red-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: #ff0000; 
            box-shadow: 
                0 0 20px #ff0000,
                0 0 40px #ff0000,
                0 0 60px rgba(255, 0, 0, 0.5);
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            animation: pulseRed 0.8s infinite alternate;
        }
        
        @keyframes pulseRed {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.4); opacity: 0.8; }
        }
        
        .red-line {
            position: absolute; background: rgba(255, 0, 0, 0.2);
        }
        .red-line.h { width: 100%; height: 1px; top: 50%; }
        .red-line.v { height: 100%; width: 1px; left: 50%; }

        /* Storm Visuals */
        #storm-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, 
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.15) 40%,
                rgba(75, 0, 130, 0.25) 60%,
                rgba(75, 0, 130, 0.35) 80%,
                rgba(75, 0, 130, 0.45) 100%);
            mix-blend-mode: multiply; 
            pointer-events: none; 
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 50; 
        }
        
        #storm-overlay.in-storm {
            background: radial-gradient(circle at 50% 50%,
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.25) 30%,
                rgba(75, 0, 130, 0.45) 50%,
                rgba(75, 0, 130, 0.65) 70%,
                rgba(75, 0, 130, 0.85) 100%);
            animation: stormPulse 2s infinite alternate;
        }
        
        @keyframes stormPulse {
            0% { opacity: 0.9; }
            100% { opacity: 1; }
        }

        /* === REDESIGNED ULTIMATE HUD === */
        #hud-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        /* Top Bar - Redesigned and Smaller */
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1.5rem;
            background: rgba(10, 10, 30, 0.9);
            backdrop-filter: blur(20px);
            padding: 0.8rem 1.5rem;
            border-radius: 15px;
            border: 2px solid rgba(0, 210, 255, 0.4);
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.7),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 20px rgba(0, 210, 255, 0.3);
            z-index: 20;
        }
        
        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 100px;
        }
        
        .hud-label {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.8);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.3rem;
            font-weight: 600;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        
        .hud-value {
            font-size: 1.5rem;
            font-weight: 800;
            color: white;
            text-shadow: 
                0 2px 5px rgba(0,0,0,0.5),
                0 0 15px currentColor;
            letter-spacing: 0.5px;
        }
        
        #alive-count { 
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        #storm-timer { 
            color: #a335ee;
            text-shadow: 0 0 15px rgba(163, 53, 238, 0.5);
        }
        #storm-status {
            color: #00d2ff;
            text-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
        }

        /* Player Stats - Left Side (Redesigned and Smaller) */
        #player-stats {
            position: absolute;
            bottom: 1.5rem;
            left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            width: 240px;
            z-index: 20;
        }
        
        .stat-card {
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, 0.85) 0%,
                rgba(20, 20, 40, 0.85) 100%);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            padding: 0.7rem 1rem;
            border: 2px solid rgba(255,255,255,0.15);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.1),
                0 0 20px rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.05) 0%,
                transparent 100%);
            z-index: 1;
        }
        
        .stat-card:hover {
            border-color: rgba(0, 210, 255, 0.4);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 30px rgba(0, 210, 255, 0.4);
        }
        
        .stat-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.5rem;
            position: relative;
            z-index: 2;
        }
        
        .stat-icon {
            font-size: 1rem;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.15) 0%,
                rgba(255,255,255,0.05) 100%);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.1),
                0 3px 10px rgba(0,0,0,0.3);
        }
        
        .stat-title {
            flex: 1;
            font-size: 0.8rem;
            font-weight: 700;
            color: rgba(255,255,255,0.95);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        
        .stat-value {
            font-size: 1.1rem;
            font-weight: 900;
            color: #ffd700;
            min-width: 45px;
            text-align: right;
            text-shadow: 
                0 2px 5px rgba(0,0,0,0.5),
                0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        .stat-bar-container {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            z-index: 2;
            box-shadow: 
                inset 0 1px 2px rgba(0,0,0,0.5),
                0 1px 3px rgba(0,0,0,0.3);
        }
        
        .stat-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.4), 
                transparent);
            animation: barShine 2.5s infinite linear;
        }
        
        .stat-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.2) 0%,
                transparent 50%,
                rgba(255,255,255,0.1) 100%);
        }
        
        @keyframes barShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #health-bar { 
            background: linear-gradient(90deg, 
                #ff4d4d 0%, 
                #ff8888 50%, 
                #ffaaaa 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(255, 77, 77, 0.5);
        }
        
        #shield-bar { 
            background: linear-gradient(90deg, 
                #0072ff 0%, 
                #00a8ff 50%, 
                #00d2ff 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(0, 114, 255, 0.5);
        }
        
        #overshield-bar { 
            background: linear-gradient(90deg, 
                #ffaa00 0%, 
                #ffcc00 50%, 
                #ffff00 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(255, 170, 0, 0.5);
        }

        /* Resources Bar - Redesigned and Smaller */
        #resources-bar {
            display: flex;
            gap: 0.8rem;
            margin-top: 0.8rem;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.8rem;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.1) 0%,
                rgba(255,255,255,0.05) 100%);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 
                0 4px 12px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .resource-item:hover {
            transform: translateY(-2px);
            border-color: rgba(222, 184, 135, 0.4);
            box-shadow: 
                0 6px 20px rgba(0,0,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 15px rgba(222, 184, 135, 0.3);
        }
        
        .resource-icon {
            font-size: 1.1rem;
            color: #deb887;
            text-shadow: 0 0 8px rgba(222, 184, 135, 0.5);
        }
        
        .resource-amount {
            font-size: 1rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        /* Inventory - Right Side (Redesigned and Smaller) */
        #inventory-hud {
            position: absolute;
            bottom: 1.5rem;
            right: 1.5rem;
            display: flex;
            gap: 0.6rem;
            z-index: 20;
        }
        
        .inventory-slot {
            width: 70px;
            height: 85px;
            background: linear-gradient(135deg, 
                rgba(10, 10, 30, 0.95) 0%,
                rgba(20, 20, 40, 0.95) 100%);
            backdrop-filter: blur(15px);
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 
                0 8px 20px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .inventory-slot::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.05) 0%,
                transparent 100%);
        }
        
        .inventory-slot:hover {
            transform: translateY(-6px) scale(1.06);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 
                0 15px 30px rgba(0,0,0,0.7),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 25px rgba(255,255,255,0.2);
        }
        
        .inventory-slot.active {
            border-color: #ff4d4d;
            transform: translateY(-8px) scale(1.1);
            background: linear-gradient(135deg, 
                rgba(30, 30, 50, 0.98) 0%,
                rgba(40, 40, 60, 0.98) 100%);
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.8),
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 0 30px rgba(255, 77, 77, 0.5);
        }
        
        .slot-key {
            position: absolute;
            top: 6px;
            left: 6px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.8);
            font-weight: 700;
            background: rgba(0,0,0,0.6);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            text-shadow: 0 2px 3px rgba(0,0,0,0.5);
        }
        
        .slot-icon {
            font-size: 1.8rem;
            margin-bottom: 0.3rem;
            text-shadow: 0 0 10px currentColor;
            filter: drop-shadow(0 0 3px currentColor);
        }
        
        .slot-name {
            font-size: 0.6rem;
            font-weight: 700;
            color: rgba(255,255,255,0.95);
            text-transform: uppercase;
            text-align: center;
            max-width: 60px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 0 0.2rem;
            text-shadow: 0 2px 3px rgba(0,0,0,0.5);
        }
        
        .slot-count {
            position: absolute;
            bottom: 6px;
            right: 6px;
            font-size: 0.7rem;
            font-weight: 900;
            color: #ffd700;
            background: rgba(0,0,0,0.6);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            text-shadow: 
                0 2px 3px rgba(0,0,0,0.5),
                0 0 8px rgba(255, 215, 0, 0.5);
        }
        
        /* Rarity Borders */
        .rarity-common { 
            border-bottom: 4px solid #b0b0b0;
            box-shadow: 0 0 15px rgba(176, 176, 176, 0.3);
        }
        .rarity-uncommon { 
            border-bottom: 4px solid #28a745;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.3);
        }
        .rarity-rare { 
            border-bottom: 4px solid #007bff;
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.3);
        }
        .rarity-epic { 
            border-bottom: 4px solid #a335ee;
            box-shadow: 0 0 15px rgba(163, 53, 238, 0.3);
        }
        .rarity-legendary { 
            border-bottom: 4px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }
        .rarity-mythic { 
            border-bottom: 4px solid #ff4d4d;
            box-shadow: 0 0 15px rgba(255, 77, 77, 0.3);
        }

        /* Center HUD Elements */
        #center-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            z-index: 15;
        }

        /* Interaction Prompt - Redesigned */
        #interact-prompt {
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.98), 
                rgba(255, 170, 0, 0.98));
            color: #000;
            padding: 1rem 2rem;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 800;
            display: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 10px 30px rgba(255, 215, 0, 0.5),
                0 6px 20px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.6);
            border: 3px solid rgba(255,255,255,0.6);
            backdrop-filter: blur(10px);
            animation: pulsePrompt 1.5s infinite alternate;
            pointer-events: none;
            position: relative;
            overflow: hidden;
        }
        
        #interact-prompt::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                transparent 0%,
                rgba(255,255,255,0.3) 50%,
                transparent 100%);
            animation: promptShine 3s infinite linear;
        }
        
        @keyframes promptShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes pulsePrompt {
            0% { transform: translateY(-50%) scale(1); box-shadow: 0 10px 30px rgba(255, 215, 0, 0.5); }
            100% { transform: translateY(-50%) scale(1.06); box-shadow: 0 15px 40px rgba(255, 215, 0, 0.7); }
        }

        /* Reload Indicator - Redesigned */
        #reload-indicator {
            background: linear-gradient(135deg, 
                rgba(255, 0, 0, 0.98), 
                rgba(255, 68, 68, 0.98));
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 800;
            display: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 10px 30px rgba(255, 0, 0, 0.5),
                0 6px 20px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.4);
            backdrop-filter: blur(10px);
            animation: reloadPulse 1s infinite alternate;
        }
        
        @keyframes reloadPulse {
            0% { opacity: 0.9; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.03); }
        }

        /* Healing Progress - Redesigned */
        #healing-progress {
            position: absolute;
            bottom: 10rem;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            height: 35px;
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, 0.9) 0%,
                rgba(20, 20, 40, 0.9) 100%);
            border-radius: 20px;
            display: none;
            overflow: hidden;
            border: 2px solid rgba(0, 210, 255, 0.6);
            box-shadow: 
                0 10px 30px rgba(0, 210, 255, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
        }
        
        #healing-bar {
            height: 100%;
            background: linear-gradient(90deg, 
                #0072ff 0%, 
                #00d2ff 50%, 
                #00ffff 100%);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        #healing-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.5), 
                transparent);
            animation: healShine 1.2s infinite linear;
        }
        
        #healing-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.3) 0%,
                transparent 50%,
                rgba(255,255,255,0.1) 100%);
        }
        
        @keyframes healShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #healing-text {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 800;
            font-size: 1rem;
            text-shadow: 
                0 2px 5px rgba(0,0,0,0.8),
                0 0 15px rgba(0, 210, 255, 0.5);
            letter-spacing: 1px;
        }

        /* Damage Numbers - Redesigned */
        .dmg-number {
            position: absolute;
            color: white;
            font-weight: 900;
            font-size: 2rem;
            text-shadow: 
                2px 2px 6px rgba(0,0,0,0.9),
                0 0 15px currentColor,
                0 0 30px currentColor;
            pointer-events: none;
            animation: damageFloat 1.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            z-index: 999;
            font-family: 'Poppins', sans-serif;
            letter-spacing: 0.5px;
        }
        
        .dmg-number.headshot {
            color: #ff0000;
            font-size: 2.4rem;
            text-shadow: 
                0 0 20px #ff0000,
                0 0 40px #ff0000,
                0 0 60px rgba(255, 0, 0, 0.7);
        }
        
        .dmg-number.storm {
            color: #a335ee;
            font-size: 1.8rem;
            text-shadow: 
                0 0 20px #a335ee,
                0 0 35px rgba(163, 53, 238, 0.7);
        }
        
        @keyframes damageFloat { 
            0% { opacity: 1; transform: translateY(0) scale(1) rotate(0deg); } 
            30% { opacity: 1; transform: translateY(-15px) scale(1.1) rotate(-5deg); }
            70% { opacity: 1; transform: translateY(-45px) scale(1.2) rotate(5deg); }
            100% { opacity: 0; transform: translateY(-70px) scale(1.3) rotate(0deg); } 
        }

        /* Visual Effects */
        .muzzle-flash {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #ff9900 0%, #ff3300 50%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            animation: muzzleFlash 0.1s forwards;
        }
        
        @keyframes muzzleFlash {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(2); }
        }
        
        .bullet-trail {
            position: absolute;
            width: 2px;
            height: 50px;
            background: linear-gradient(to bottom, #ffff00 0%, #ff9900 50%, transparent 100%);
            pointer-events: none;
            z-index: 998;
            transform-origin: top center;
        }
        
        .impact-effect {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff4444 0%, #ff0000 50%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 997;
            animation: impactEffect 0.3s forwards;
        }
        
        @keyframes impactEffect {
            0% { opacity: 1; transform: scale(0.5); }
            50% { opacity: 0.8; transform: scale(1.2); }
            100% { opacity: 0; transform: scale(1.5); }
        }
        
        .blood-effect {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #cc0000 0%, #990000 50%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 996;
            animation: bloodEffect 0.5s forwards;
        }
        
        @keyframes bloodEffect {
            0% { opacity: 1; transform: scale(0.5) rotate(0deg); }
            50% { opacity: 0.8; transform: scale(1.3) rotate(180deg); }
            100% { opacity: 0; transform: scale(1.5) rotate(360deg); }
        }

        /* Controller Layout Display */
        #controller-layout {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 1rem;
            border-radius: 12px;
            display: none;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.8rem;
            z-index: 1001;
            border: 2px solid rgba(138, 43, 226, 0.5);
            backdrop-filter: blur(8px);
            font-size: 0.8rem;
        }
        
        .controller-button {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 6px;
            padding: 0.5rem;
            text-align: center;
            color: white;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 0.7rem;
        }
        
        .controller-button.active {
            background: rgba(138, 43, 226, 0.5);
            border-color: rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.7);
        }

        /* --- MOBILE CONTROLS (UPDATED FOR V19.8) --- */
        #mobile-controls {
            display: none; 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none;
            z-index: 5;
        }
        
        /* IMPROVED: Mobile control zones */
        #touch-left {
            position: absolute;
            top: 0; left: 0;
            width: 40%; height: 100%;
            pointer-events: auto;
            touch-action: none;
            z-index: 6;
        }
        
        /* IMPROVED: Camera control area - now 60% of screen for better control */
        #touch-right {
            position: absolute;
            top: 0; right: 0;
            width: 60%; height: 100%;
            background: transparent;
            pointer-events: auto;
            touch-action: none;
            z-index: 6;
        }
        
        /* Movement Zone - Updated */
        #movement-zone {
            position: absolute;
            bottom: 100px;
            left: 80px;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.08) 0%,
                rgba(255,255,255,0.03) 70%,
                transparent 71%);
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.2);
            pointer-events: none;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.5),
                inset 0 0 20px rgba(255,255,255,0.1);
            z-index: 7;
            opacity: 0.9;
        }
        
        .joystick-thumb {
            position: absolute;
            top: 50%; left: 50%;
            width: 60px; height: 60px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.4) 0%,
                rgba(255,255,255,0.2) 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 6px 20px rgba(0,0,0,0.6),
                inset 0 0 15px rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.4);
            pointer-events: none;
            transition: transform 0.08s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 8;
        }

        /* Mobile Action Buttons - Updated */
        .mobile-button {
            position: absolute;
            width: 75px; height: 75px;
            border-radius: 50%;
            background: linear-gradient(135deg, 
                rgba(30, 30, 40, 0.95),
                rgba(20, 20, 30, 0.95));
            border: 3px solid rgba(255,255,255,0.3);
            color: white;
            font-weight: 800;
            font-size: 0.9rem;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(12px);
            text-align: center;
            text-transform: uppercase;
            z-index: 10;
            box-shadow: 
                0 8px 25px rgba(0,0,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(255,255,255,0.1);
            transition: all 0.12s cubic-bezier(0.4, 0, 0.2, 1);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .mobile-button:active {
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.4),
                rgba(255,255,255,0.3));
            transform: scale(0.85);
            box-shadow: 
                0 4px 15px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 20px rgba(255,255,255,0.3);
        }
        
        #btn-fire { 
            bottom: 100px; right: 30px; 
            width: 90px; height: 90px;
            border-color: #ff4444;
            background: linear-gradient(135deg, 
                rgba(255,0,0,0.6),
                rgba(255,68,68,0.5));
            font-size: 1.2rem;
            box-shadow: 
                0 10px 30px rgba(255,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 20px rgba(255,0,0,0.3);
        }
        
        #btn-fire:active {
            box-shadow: 
                0 6px 20px rgba(255,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 30px rgba(255,0,0,0.5);
        }
        
        #btn-jump { 
            bottom: 200px; right: 40px;
            border-color: #00d2ff;
            background: linear-gradient(135deg,
                rgba(0,210,255,0.6),
                rgba(0,168,255,0.5));
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.4);
        }
        
        #btn-interact { 
            bottom: 160px; right: 120px;
            border-color: #ffd700;
            color: #ffd700;
            background: linear-gradient(135deg,
                rgba(255,215,0,0.4),
                rgba(255,170,0,0.3));
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        #btn-build { 
            bottom: 230px; right: 120px;
            border-color: #8B4513;
            background: linear-gradient(135deg,
                rgba(139,69,19,0.6),
                rgba(160,82,45,0.5));
            box-shadow: 0 0 20px rgba(139, 69, 19, 0.3);
        }
        
        #btn-ads { 
            bottom: 60px; right: 130px;
            width: 65px; height: 65px;
            font-size: 0.9rem;
            border-color: #007bff;
            background: linear-gradient(135deg,
                rgba(0,123,255,0.6),
                rgba(0,82,204,0.5));
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.3);
        }
        
        #btn-reload { 
            top: 180px; right: 30px;
            width: 60px; height: 60px;
            font-size: 0.8rem;
            border-color: #00d2ff;
            background: linear-gradient(135deg,
                rgba(0,210,255,0.6),
                rgba(0,168,255,0.5));
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.3);
            display: none;
        }

        /* === ULTIMATE VICTORY & ELIMINATED SCREENS === */
        #victory-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(255, 215, 0, 0.9),
                rgba(255, 140, 0, 0.95));
            backdrop-filter: blur(25px);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            animation: fadeIn 0.5s ease-out forwards;
            overflow: hidden;
        }
        
        .victory-particles {
            position: absolute;
            width: 100%; height: 100%;
        }
        
        .victory-particle {
            position: absolute;
            width: 10px; height: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            animation: victoryParticleFloat 6s infinite linear;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.7);
        }
        
        @keyframes victoryParticleFloat {
            0% { transform: translateY(100vh) rotate(0deg) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(90vh) rotate(0deg) scale(1); }
            90% { opacity: 1; transform: translateY(10vh) rotate(360deg) scale(1); }
            100% { transform: translateY(0) rotate(720deg) scale(0); opacity: 0; }
        }
        
        #victory-text {
            font-size: 0;
            background: linear-gradient(135deg, #ffd700, #ffaa00, #ff6600, #ff0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            animation: victoryText 3.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards,
                       victoryPulse 2s infinite alternate 3.5s;
            position: relative;
            text-shadow: 
                0 12px 40px rgba(255, 215, 0, 0.6),
                0 0 60px rgba(255, 170, 0, 0.4),
                0 0 90px rgba(255, 100, 0, 0.3);
            letter-spacing: -8px;
            opacity: 0;
            white-space: nowrap;
            z-index: 2;
        }
        
        #victory-text::after {
            content: 'V19.8';
            display: block;
            font-size: 2rem;
            margin-top: 1rem;
            color: #ffffff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.9);
            animation: versionPulse 3s infinite alternate;
        }
        
        @keyframes versionPulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.1); }
        }
        
        @keyframes victoryText {
            0% { font-size: 0; transform: scale(0) rotate(-20deg); opacity: 0; letter-spacing: 80px; }
            30% { font-size: 7rem; transform: scale(1.4) rotate(15deg); opacity: 1; letter-spacing: -8px; }
            50% { font-size: 7rem; transform: scale(1.4) rotate(-5deg); opacity: 1; letter-spacing: -4px; }
            70% { font-size: 7rem; transform: scale(1.2) rotate(5deg); opacity: 1; letter-spacing: -2px; }
            100% { font-size: 5.5rem; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0; }
        }
        
        @keyframes victoryPulse {
            0% { transform: scale(1); text-shadow: 0 12px 40px rgba(255, 215, 0, 0.6); }
            100% { transform: scale(1.08); text-shadow: 0 15px 50px rgba(255, 215, 0, 0.9), 0 0 80px rgba(255, 170, 0, 0.5); }
        }
        
        #victory-stats {
            font-size: 2.2rem;
            color: white;
            margin-top: 2rem;
            opacity: 0;
            animation: fadeUp 1s ease-out 4s forwards;
            text-shadow: 0 6px 20px rgba(0,0,0,0.7);
            z-index: 2;
        }
        
        #game-over {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(200, 0, 0, 0.97),
                rgba(50, 0, 0, 0.99));
            backdrop-filter: blur(25px);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 999;
            pointer-events: auto;
            text-align: center;
            overflow: hidden;
        }
        
        .eliminated-particles {
            position: absolute;
            width: 100%; height: 100%;
        }
        
        .eliminated-particle {
            position: absolute;
            width: 8px; height: 8px;
            background: rgba(255, 50, 50, 0.7);
            border-radius: 50%;
            animation: eliminatedParticleFall 4s infinite linear;
        }
        
        @keyframes eliminatedParticleFall {
            0% { transform: translateY(-100px) rotate(0deg) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(0) rotate(0deg) scale(1); }
            90% { opacity: 1; transform: translateY(100vh) rotate(360deg) scale(1); }
            100% { transform: translateY(110vh) rotate(720deg) scale(0); opacity: 0; }
        }
        
        #go-title {
            font-size: 0;
            background: linear-gradient(135deg, #ff4d4d, #ff0000, #8b0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1.5rem;
            font-weight: 900;
            animation: eliminatedText 2.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 12px 40px rgba(255, 0, 0, 0.6);
            letter-spacing: -8px;
            opacity: 0;
        }
        
        @keyframes eliminatedText {
            0% { font-size: 0; transform: scale(0) rotate(-10deg); opacity: 0; letter-spacing: 40px; }
            40% { font-size: 6.5rem; transform: scale(1.3) rotate(5deg); opacity: 1; letter-spacing: -4px; }
            60% { font-size: 6.5rem; transform: scale(1.1) rotate(-2deg); opacity: 1; letter-spacing: -2px; }
            100% { font-size: 5rem; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0; }
        }
        
        #go-stats {
            font-size: 2.2rem;
            color: rgba(255,255,255,0.95);
            margin-bottom: 3rem;
            animation: slideIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) 2.5s backwards;
            text-shadow: 0 6px 20px rgba(0,0,0,0.7);
            z-index: 2;
        }

        /* Restart Button - Redesigned */
        .restart-btn {
            margin-top: 3rem;
            padding: 1.2rem 2.5rem;
            font-size: 1.4rem;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            box-shadow: 
                0 12px 35px rgba(0, 123, 255, 0.7),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 25px rgba(0, 123, 255, 0.5);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 2;
        }
        
        .restart-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.6s;
        }
        
        .restart-btn:hover::before {
            left: 100%;
        }
        
        .restart-btn:hover {
            background: linear-gradient(135deg, #0056b3, #003d82);
            transform: translateY(-4px);
            box-shadow: 
                0 15px 40px rgba(0, 123, 255, 0.9),
                inset 0 1px 0 rgba(255,255,255,0.5),
                0 0 30px rgba(0, 123, 255, 0.7);
        }
        
        #game-over .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 3s forwards;
        }
        
        #victory-overlay .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 4.5s forwards;
        }

        /* Animations */
        @keyframes fadeIn { 
            0% { opacity: 0; } 
            100% { opacity: 1; } 
        }
        
        @keyframes slideDown {
            0% { opacity: 0; transform: translateY(-40px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes scaleIn {
            0% { opacity: 0; transform: scale(0.7) rotate(-5deg); }
            70% { opacity: 1; transform: scale(1.05) rotate(2deg); }
            100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }
        
        @keyframes slideIn {
            0% { opacity: 0; transform: translateY(-40px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes fadeUp {
            0% { transform: translateY(40px) scale(0.8); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        /* Menu Enhancements */
        .menu-background {
            position: absolute;
            width: 100%; height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 210, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 128, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(255, 215, 0, 0.15) 0%, transparent 50%);
            animation: backgroundPulse 10s infinite alternate;
        }
        
        @keyframes backgroundPulse {
            0% { opacity: 0.4; }
            100% { opacity: 0.8; }
        }
        
        .version-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            padding: 0.6rem 1.2rem;
            border-radius: 20px;
            font-weight: 800;
            font-size: 0.9rem;
            animation: badgeGlow 2s infinite alternate;
            box-shadow: 
                0 6px 20px rgba(255, 215, 0, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        @keyframes badgeGlow {
            0% { box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4); }
            100% { box-shadow: 0 6px 25px rgba(255, 215, 0, 0.7), 0 0 25px rgba(255, 215, 0, 0.3); }
        }
        
        .menu-title {
            position: relative;
            margin-bottom: 1.5rem;
        }
        
        .title-glow {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 120%; height: 120%;
            background: radial-gradient(circle, rgba(0, 210, 255, 0.4) 0%, transparent 70%);
            filter: blur(40px);
            z-index: 1;
        }
        
        /* Day/Night Cycle Indicator */
        #day-night-indicator {
            position: absolute;
            top: 20px;
            right: 120px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            font-weight: 600;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        #day-night-icon {
            font-size: 1.2rem;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>

    <div id="start-screen">
        <div class="menu-background"></div>
        <div class="particles" id="particles-container"></div>
        <div class="version-badge">V19.8 â€¢ ULTIMATE EDITION</div>
        <div class="menu-title">
            <div class="title-glow"></div>
            <h1>WEB BATTLE ROYALE</h1>
        </div>
        <p class="subtitle">Experience the ultimate browser-based shooter</p>
        <div class="button-container">
            <button class="game-button mobile" onclick="startGame('mobile')">ðŸ“± Mobile Mode</button>
            <button class="game-button" onclick="startGame('desktop')">ðŸ–¥ï¸ Desktop Mode</button>
            <button class="game-button controller" onclick="startGame('controller')">ðŸŽ® Controller Mode</button>
        </div>
        <div class="stats-grid">
            <div class="stat-item">
                <h3>Active Players</h3>
                <p id="total-players">21</p>
            </div>
            <div class="stat-item">
                <h3>Map Size</h3>
                <p>600x600</p>
            </div>
            <div class="stat-item">
                <h3>Version</h3>
                <p>V19.8</p>
            </div>
        </div>
        <div id="victory-royales-stat">ðŸ† Victory Royales: 0</div>
    </div>
    
    <div id="game-container"></div>

    <div id="ui-layer">
        <!-- FPS Counter -->
        <div id="fps-counter">FPS: 60</div>
        
        <!-- Day/Night Indicator -->
        <div id="day-night-indicator">
            <span id="day-night-icon">ðŸŒž</span>
            <span id="day-night-text">Day</span>
        </div>
        
        <!-- Level Display -->
        <div id="level-display">
            <div class="level-info">
                <div class="level-text">Level 1</div>
                <div class="xp-progress">
                    <div class="progress-container">
                        <div class="progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="points-text">0 / 150 XP</div>
                </div>
                <div class="level-perks">
                    <div class="level-perk">+5% Damage</div>
                    <div class="level-perk">+10 Shield</div>
                    <div class="level-perk unlocked">Unlocked</div>
                </div>
            </div>
        </div>
        
        <!-- Crosshair -->
        <div id="crosshair">
            <div class="crosshair-dot"></div>
            <div class="crosshair-line ch-h"></div>
            <div class="crosshair-line ch-v"></div>
        </div>
        
        <!-- Scopes -->
        <div id="scope-overlay">
            <div id="scope-lines"></div>
        </div>
        
        <div id="red-dot-scope">
            <div class="red-line h"></div>
            <div class="red-line v"></div>
            <div class="red-dot"></div>
        </div>

        <!-- Storm Overlay -->
        <div id="storm-overlay"></div>

        <!-- HUD Container -->
        <div id="hud-container">
            <!-- Top Bar -->
            <div id="top-bar">
                <div class="hud-item">
                    <div class="hud-label">Players Alive</div>
                    <div class="hud-value" id="alive-count">21</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Phase</div>
                    <div class="hud-value" id="storm-status">WAIT</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Timer</div>
                    <div class="hud-value" id="storm-timer">04:00</div>
                </div>
            </div>

            <!-- Player Stats (Left) -->
            <div id="player-stats">
                <!-- Health -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">â¤ï¸</div>
                        <div class="stat-title">Health</div>
                        <div class="stat-value" id="health-value">100</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="health-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Shield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">ðŸ›¡ï¸</div>
                        <div class="stat-title">Shield</div>
                        <div class="stat-value" id="shield-value">100</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="shield-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Overshield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">ðŸ”¥</div>
                        <div class="stat-title">Overshield</div>
                        <div class="stat-value" id="overshield-value">50</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="overshield-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Resources -->
                <div id="resources-bar">
                    <div class="resource-item">
                        <div class="resource-icon">ðŸªµ</div>
                        <div class="resource-amount" id="wood-value">0</div>
                    </div>
                </div>
            </div>

            <!-- Inventory (Right) -->
            <div id="inventory-hud">
                <div class="inventory-slot" id="slot-0" onclick="selectSlot(0)" ontouchstart="selectSlotMobile(0)"></div>
                <div class="inventory-slot" id="slot-1" onclick="selectSlot(1)" ontouchstart="selectSlotMobile(1)"></div>
                <div class="inventory-slot" id="slot-2" onclick="selectSlot(2)" ontouchstart="selectSlotMobile(2)"></div>
                <div class="inventory-slot" id="slot-3" onclick="selectSlot(3)" ontouchstart="selectSlotMobile(3)"></div>
                <div class="inventory-slot" id="slot-4" onclick="selectSlot(4)" ontouchstart="selectSlotMobile(4)"></div>
            </div>

            <!-- Center HUD -->
            <div id="center-hud">
                <div id="interact-prompt">Interact (E)</div>
                <div id="reload-indicator">RELOADING...</div>
            </div>

            <!-- Healing Progress -->
            <div id="healing-progress">
                <div id="healing-bar"></div>
                <div id="healing-text">USING SHIELD...</div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div id="touch-left"></div>
            <div id="touch-right"></div>
            
            <div id="movement-zone">
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
            
            <div id="camera-zone"></div>
            
            <div id="btn-fire" class="mobile-button">FIRE</div>
            <div id="btn-jump" class="mobile-button">JUMP</div>
            <div id="btn-interact" class="mobile-button">INTERACT</div>
            <div id="btn-build" class="mobile-button">BUILD</div>
            <div id="btn-ads" class="mobile-button">AIM</div>
            <div id="btn-reload" class="mobile-button">RELOAD</div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-overlay">
        <div class="victory-particles" id="victory-particles"></div>
        <div id="victory-text">VICTORY ROYALE</div>
        <div id="victory-stats">Eliminations: 0</div>
        <button class="restart-btn" onclick="location.reload()">ðŸ† RETURN TO LOBBY</button>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <div class="eliminated-particles" id="eliminated-particles"></div>
        <h1 id="go-title">ELIMINATED</h1>
        <h3 id="go-stats">Eliminations: 0</h3>
        <button class="restart-btn" onclick="location.reload()">ðŸ”„ RETURN TO LOBBY</button>
    </div>

    <!-- End Game Stats -->
    <div id="endgame-stats">
        <div class="stats-header">MATCH RESULTS</div>
        <div class="stats-grid" id="match-stats-grid">
            <!-- Stats will be populated here -->
        </div>
        <div class="total-points" id="total-points">Total Points: 0</div>
        <button class="restart-btn" onclick="location.reload()">ðŸ† RETURN TO LOBBY</button>
    </div>

    <!-- Controller Notification -->
    <div class="controller-notification" id="controller-notification">ðŸŽ® Controller Connected</div>
    
    <!-- Controller Layout Display -->
    <div id="controller-layout"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ===============================================================
        // === CORE CONSTANTS AND CONFIGURATION (V19.8) ===================
        // ===============================================================
        
        const WORLD_SIZE = 600;
        let BOT_COUNT = 18; // Reduced for performance
        const GRAVITY = 40.0; 
        const WALK_SPEED = 10; 
        const SPRINT_SPEED = 20; 
        const JUMP_FORCE = 15;
        const PLAYER_HEIGHT = 1.8;
        const SHOTGUN_PELLETS = 4;
        
        // UPDATED: Player starts with 100 Health, 100 Shields, 50 Overshields
        const OVER_SHIELD_MAX = 50;
        const OVER_SHIELD_REGEN_RATE = 15;
        const OVER_SHIELD_REGEN_DELAY = 3000; // Fixed: Reduced from 7000 to 3000
        
        // ENHANCED Level System
        let playerLevel = 1;
        let playerXP = 0;
        const XP_PER_LEVEL = 150;
        let matchStats = {
            kills: 0,
            placement: 0,
            chestsOpened: 0,
            legendariesHeld: 0,
            totalPoints: 0
        };
        
        // Level perks system
        const LEVEL_PERKS = [
            { level: 1, name: "Starter", perks: ["+5% Damage", "+10 Shield"] },
            { level: 5, name: "Soldier", perks: ["+10% Damage", "+25 Shield", "+5% Movement Speed"] },
            { level: 10, name: "Veteran", perks: ["+15% Damage", "+50 Shield", "+10% Movement Speed", "Faster Reload"] },
            { level: 15, name: "Elite", perks: ["+20% Damage", "+75 Shield", "+15% Movement Speed", "Faster Healing"] },
            { level: 20, name: "Legend", perks: ["+25% Damage", "+100 Shield", "+20% Movement Speed", "Double XP Gain"] }
        ];
        
        // --- WEAPONS CONFIG ---
        const RARITY_MULTIPLIERS = {
            COMMON: { dmg: 1.0, reload: 1.0, color: '#b0b0b0' },
            UNCOMMON: { dmg: 1.15, reload: 0.9, color: '#28a745' },
            RARE: { dmg: 1.3, reload: 0.8, color: '#007bff' },
            EPIC: { dmg: 1.45, reload: 0.7, color: '#a335ee' },
            LEGENDARY: { dmg: 1.6, reload: 0.6, color: '#ffd700' },
            MYTHIC: { dmg: 1.8, reload: 0.5, color: '#ff4d4d' } 
        };
        const RARITY_KEYS = Object.keys(RARITY_MULTIPLIERS);

        // Weapons configuration - UPDATED: Sniper damage reduced by 33%
        const WEAPONS_BASE = {
            PUMP: { name: "Pump Shotgun", dmg: 30 * 1.5, head: 35 * 1.5, rate: 1.2, mag: 5, range: 30, spread: 0.25, pellets: SHOTGUN_PELLETS, auto: false, icon: 'ðŸ’¥', reload: 3000, recoil: 0.0, bulletType: 'hitscan' }, 
            AUTO_SHG: { name: "Auto Shotgun", dmg: 30, head: 50, rate: 0.4, mag: 8, range: 25, spread: 0.3, pellets: SHOTGUN_PELLETS, auto: true, icon: 'ðŸ”¥', reload: 3500, recoil: 0.0, bulletType: 'hitscan' },
            RFAR: { name: "Rapid Fire AR", dmg: 14, head: 21, rate: 0.1, mag: 30, range: 150, spread: 0.04, pellets: 1, auto: true, icon: 'ðŸ’¨', reload: 2500, recoil: 0.0, bulletType: 'hitscan' }, 
            DMR: { name: "DMR", dmg: 25, head: 40, rate: 0.35, mag: 15, range: 250, spread: 0.015, pellets: 1, auto: false, icon: 'ðŸŽ¯', reload: 2800, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            STINGER: { name: "Stinger SMG", dmg: 15, head: 22.5, rate: 0.07, mag: 20, range: 70, spread: 0.07, pellets: 1, auto: true, icon: 'âš¡', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            BURST_SMG: { name: "Burst SMG", dmg: 18, head: 30, rate: 0.15, mag: 30, burst: 2, burstDelay: 300, range: 80, spread: 0.05, pellets: 1, auto: false, icon: 'âœ¨', reload: 2000, recoil: 0.0, bulletType: 'hitscan' },
            // SNIPER DAMAGE REDUCED BY 33%
            BOLT_SNIPER: { name: "Bolt Sniper", dmg: 127.5 * 1.25 * 0.67, head: 157.5 * 1.25 * 0.67, rate: 2.5, mag: 2, range: 600, spread: 0.001, pellets: 1, auto: false, icon: 'ðŸ’€', reload: 4000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            SCOPED_SMG: { name: "Scoped SMG", dmg: 12, head: 18, rate: 0.1, mag: 40, range: 100, spread: 0.03, pellets: 1, auto: true, icon: 'ðŸ‘ï¸', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            DRUM_SMG: { name: "Drum SMG", dmg: 10, head: 15, rate: 0.08, mag: 50, range: 80, spread: 0.08, pellets: 1, auto: true, icon: 'ðŸ¥', reload: 1200, recoil: 0.0, bulletType: 'hitscan' },
            // SNIPER DAMAGE REDUCED BY 33%
            FALCON_SNIPER: { name: "Falcon Sniper", dmg: 97.5 * 1.25 * 0.67, head: 135 * 1.25 * 0.67, rate: 0.7, mag: 3, range: 500, spread: 0.005, pellets: 1, auto: false, icon: 'ðŸ¦…', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            STRANGLED_RIFLE: { name: "Strangled Rifle", dmg: 35, head: 55, rate: 0.45, mag: 30, range: 180, spread: 0.02, pellets: 1, auto: false, icon: 'â›“ï¸', reload: 2500, recoil: 0.0, bulletType: 'hitscan' },
            // SNIPER DAMAGE REDUCED BY 33%
            SNIPER: { name: "Sniper", dmg: 150 * 1.25 * 0.67, head: 195 * 1.25 * 0.67, rate: 1.5, mag: 1, range: 600, spread: 0.001, pellets: 1, auto: false, icon: 'ðŸ”­', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            PISTOL: { name: "Pistol", dmg: 12, head: 18, rate: 0.5, mag: 15, range: 100, spread: 0.05, pellets: 1, auto: false, icon: 'ðŸ’£', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            ROCKET_LAUNCHER: { name: "R. Launcher", dmg: 50, head: 0, rate: 4.0, mag: 1, range: 300, spread: 0.0, pellets: 1, auto: false, icon: 'ðŸš€', reload: 4500, recoil: 0.0, bulletType: 'projectile', explosionRadius: 5, explosionDamage: 200 },
            // FIXED: Dual Micro SMG damage decreased
            DUAL_SMG: { name: "Dual Micro SMGS", dmg: 9, head: 12, rate: 0.05, mag: 130, range: 70, spread: 0.1, pellets: 1, auto: true, icon: 'ðŸ”ª', reload: 2250, recoil: 0.0, bulletType: 'hitscan' },
            // FIXED: Heavy AR not automatic and decreased BPS
            HEAVY_AR: { name: "Heavy AR", dmg: 30, head: 55, rate: 0.25, mag: 30, range: 200, spread: 0.035, pellets: 1, auto: false, icon: 'ðŸŽ–ï¸', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'holo_twister' } // Rate increased from 0.12 to 0.25
        };
        const MYTHIC_WEAPON_KEY = 'STRANGLED_RIFLE'; 
        const BOT_WEAPON_KEY = 'RFAR'; 
        
        // --- CONSUMABLES CONFIG ---
        const CONSUMABLES = {
            MINI: { name: "Small Shield", val: 25, type: 'shield', max: 50, icon: 'ðŸ’§', time: 1, continuous: false, instant: true, maxStack: 6, rarity: 'COMMON' },
            BIG:  { name: "Big Shield", val: 50, type: 'shield', max: 100, icon: 'âš—ï¸', time: 5000, continuous: false, instant: false, maxStack: 3, rarity: 'UNCOMMON' },
            CHUG: { name: "Chug Jug", val: 3, shieldVal: 3, type: 'continuous', max: 100, icon: 'ðŸ¥¤', time: 20000, continuous: true, instant: false, maxStack: 1, rarity: 'LEGENDARY' },
            MEDKIT: { name: "Med Kit", val: 100, type: 'health', max: 100, icon: 'ðŸ©¹', time: 10000, continuous: false, instant: false, maxStack: 3, rarity: 'RARE' }
        };
        const CONSUMABLE_KEYS = Object.keys(CONSUMABLES);

        // --- IMPROVED STORM PHASES ---
        const STORM_PHASES = [
            { time: 90, radius: WORLD_SIZE * 0.6, damage: 1, status: "Wait" }, 
            { time: 60, radius: WORLD_SIZE * 0.4, damage: 2, status: "Shrink" }, 
            { time: 90, radius: WORLD_SIZE * 0.4, damage: 3, status: "Hold" }, 
            { time: 45, radius: WORLD_SIZE * 0.25, damage: 5, status: "Shrink" }, 
            { time: 30, radius: WORLD_SIZE * 0.15, damage: 8, status: "Shrink" },
            { time: 30, radius: 0, damage: 10, status: "Deathmatch" } 
        ];
        const BOT_STORM_DAMAGE = 5;

        // ===============================================================
        // === GLOBAL STATE VARIABLES ====================================
        // ===============================================================

        let scene, camera, renderer, controls;
        let weaponScene, weaponCamera, viewModel;
        let raycaster, downRay;
        
        // UPDATED: Player starts with 100 Health, 100 Shields, 50 Overshields
        let player = { 
            health: 100, shield: 100, overshield: 50, wood: 0, 
            inventory: [null, null, null, null, null], slot: 0, 
            dead: false, ads: false, vehicle: null, eliminations: 0,
            isReloading: false,
            isHealing: false,
            healingItem: null,
            healingStartTime: 0,
            lastStormDamage: 0,
            isBursting: false,
            burstCount: 0,
            burstTimer: null,
            lastOvershieldDamage: 0, 
            overshieldRegenTimer: null,
            lastOvershieldBreak: 0,
            levelDamageMultiplier: 1.0,
            levelShieldBonus: 0,
            levelSpeedMultiplier: 1.0
        };
        
        let inputs = { w: false, a: false, s: false, d: false, jump: false, sprint: false, fire: false, reload: false, use: false };
        let velocity = new THREE.Vector3();
        let isGrounded = false;
        let lastTime = performance.now();
        let lastShot = 0;
        
        // Game mode
        let gameMode = 'desktop'; // 'desktop', 'mobile', or 'controller'
        let gameStarted = false;
        let victoryRoyales = 0;
        
        // IMPROVED: Mobile control variables - Better responsiveness
        let mobileTouchActive = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let touchDeltaX = 0;
        let touchDeltaY = 0;
        const MOBILE_SENSITIVITY = 0.0025; // INCREASED sensitivity for better camera control
        const MOBILE_SMOOTHING = 0.15; // Reduced smoothing for more responsive control
        const MAX_CAMERA_ANGLE = Math.PI / 2 - 0.1;
        
        // IMPROVED: Mobile joystick tracking
        let joystickActive = false;
        let joystickOrigin = { x: 0, y: 0 };
        let joystickOffset = { x: 0, y: 0 };
        
        // Controller variables
        let gamepad = null;
        let controllerConnected = false;
        let controllerVibration = true;
        let controllerMapping = {
            leftStick: { x: 0, y: 0 },
            rightStick: { x: 0, y: 0 },
            buttons: {
                l1: false, r1: false,
                l2: 0, r2: 0,
                y: false, b: false, a: false, x: false,
                dpadLeft: false, dpadRight: false, dpadUp: false, dpadDown: false,
                l3: false, r3: false,
                start: false, select: false
            }
        };
        const CONTROLLER_SENSITIVITY = 0.02;
        
        // Dynamic Arrays for Entities
        let bots = [];
        let objects = []; 
        let chests = [];
        let cars = [];
        let loot = [];
        let buildings = []; 
        let projectiles = []; 
        let doors = [];
        
        // Visual effects arrays
        let visualEffects = [];
        let particleSystems = [];

        // Storm State
        let stormRadius = STORM_PHASES[0].radius;
        let stormCenter = new THREE.Vector2(0, 0);
        let stormDamageRate = STORM_PHASES[0].damage;
        let stormPhaseTime = STORM_PHASES[0].time; 
        let stormPhaseTimer = stormPhaseTime;
        let stormPhase = 0;
        let stormActive = false;
        let stormTimerInterval;

        // IMPROVED: Day/Night Cycle - 5 minutes each
        let dayNightCycle = {
            isDay: true,
            cycleTime: 0,
            cycleDuration: 300, // 5 minutes per cycle (300 seconds)
            sunLight: null,
            moonLight: null,
            sunMesh: null,
            moonMesh: null,
            ambientIntensity: 0.6,
            transitionDuration: 30 // 30 seconds transition time
        };

        // Performance optimization
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let currentFPS = 60;
        let renderDistance = 300;
        let botUpdateInterval = 100;
        let lastBotUpdate = 0;
        let targetFPS = 120; // NEW: Target 120 FPS for high-end devices
        let frameTime = 0;
        let lastFrameTime = performance.now();

        // ===============================================================
        // === ENHANCED LEVEL SYSTEM =====================================
        // ===============================================================

        function loadPlayerLevel() {
            const savedLevel = localStorage.getItem('playerLevel');
            const savedXP = localStorage.getItem('playerXP');
            const savedRoyales = localStorage.getItem('victoryRoyales');
            
            playerLevel = savedLevel ? parseInt(savedLevel) : 1;
            playerXP = savedXP ? parseInt(savedXP) : 0;
            victoryRoyales = savedRoyales ? parseInt(savedRoyales) : 0;
            
            applyLevelBonuses();
            updateLevelDisplay();
        }

        function savePlayerLevel() {
            localStorage.setItem('playerLevel', playerLevel);
            localStorage.setItem('playerXP', playerXP);
            localStorage.setItem('victoryRoyales', victoryRoyales);
        }

        function applyLevelBonuses() {
            // Reset bonuses
            player.levelDamageMultiplier = 1.0;
            player.levelShieldBonus = 0;
            player.levelSpeedMultiplier = 1.0;
            
            // Apply bonuses based on level
            if (playerLevel >= 5) {
                player.levelDamageMultiplier = 1.1;
                player.levelShieldBonus = 25;
            }
            if (playerLevel >= 10) {
                player.levelDamageMultiplier = 1.15;
                player.levelShieldBonus = 50;
                player.levelSpeedMultiplier = 1.1;
            }
            if (playerLevel >= 15) {
                player.levelDamageMultiplier = 1.2;
                player.levelShieldBonus = 75;
                player.levelSpeedMultiplier = 1.15;
            }
            if (playerLevel >= 20) {
                player.levelDamageMultiplier = 1.25;
                player.levelShieldBonus = 100;
                player.levelSpeedMultiplier = 1.2;
            }
            
            // Apply shield bonus
            player.shield = Math.min(100 + player.levelShieldBonus, player.shield);
        }

        function calculateMatchPoints() {
            matchStats.kills = player.eliminations;
            matchStats.placement = bots.length + 1;
            
            // Calculate points with level multiplier
            let points = 0;
            points += matchStats.kills * 5;
            points += matchStats.chestsOpened * 1;
            points += matchStats.legendariesHeld * 5;
            
            // Placement bonuses
            if (matchStats.placement <= 10) points += 10;
            if (matchStats.placement <= 2) points += 15;
            
            // Victory Royale bonus
            if (matchStats.placement === 1) {
                points += 50;
                victoryRoyales++;
                localStorage.setItem('victoryRoyales', victoryRoyales);
            }
            
            // Level multiplier for XP
            const levelMultiplier = 1 + (playerLevel * 0.05);
            points = Math.floor(points * levelMultiplier);
            
            matchStats.totalPoints = points;
            
            // Add to player XP
            playerXP += points;
            
            // Check for level up
            let leveledUp = false;
            while (playerXP >= XP_PER_LEVEL) {
                playerXP -= XP_PER_LEVEL;
                playerLevel++;
                leveledUp = true;
            }
            
            if (leveledUp) {
                applyLevelBonuses();
                showLevelUpNotification();
            }
            
            savePlayerLevel();
            updateLevelDisplay();
            
            return points;
        }

        function updateLevelDisplay() {
            const levelDisplay = document.getElementById('level-display');
            const progressBar = levelDisplay.querySelector('.progress-bar');
            const levelText = levelDisplay.querySelector('.level-text');
            const pointsText = levelDisplay.querySelector('.points-text');
            const perksContainer = levelDisplay.querySelector('.level-perks');
            
            levelText.textContent = `Level ${playerLevel}`;
            const progressPercent = (playerXP / XP_PER_LEVEL) * 100;
            progressBar.style.width = `${progressPercent}%`;
            pointsText.textContent = `${playerXP} / ${XP_PER_LEVEL} XP`;
            
            // Update perks display
            perksContainer.innerHTML = '';
            const currentPerkSet = LEVEL_PERKS.find(perk => playerLevel >= perk.level) || LEVEL_PERKS[0];
            
            currentPerkSet.perks.forEach((perk, index) => {
                const perkEl = document.createElement('div');
                perkEl.className = `level-perk ${index === 0 ? 'unlocked' : ''}`;
                perkEl.textContent = perk;
                perksContainer.appendChild(perkEl);
            });
        }

        function showLevelUpNotification() {
            // Create notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #ffd700, #ffaa00);
                color: #000;
                padding: 2rem 3rem;
                border-radius: 15px;
                font-size: 2rem;
                font-weight: 900;
                z-index: 10000;
                animation: levelUpAnim 2s ease-out forwards;
                text-align: center;
                box-shadow: 0 20px 50px rgba(255, 215, 0, 0.7);
                border: 4px solid rgba(255,255,255,0.5);
            `;
            
            notification.innerHTML = `
                <div style="font-size: 2.5rem; margin-bottom: 1rem;">ðŸŽ‰</div>
                <div>LEVEL UP!</div>
                <div style="font-size: 1.5rem; margin-top: 1rem;">Level ${playerLevel}</div>
            `;
            
            document.body.appendChild(notification);
            
            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes levelUpAnim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5) rotate(-20deg); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2) rotate(10deg); }
                    40% { transform: translate(-50%, -50%) scale(1) rotate(-5deg); }
                    60% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
                    80% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Play sound
            playSound('victory');
            
            // Remove notification
            setTimeout(() => {
                notification.remove();
                style.remove();
            }, 2000);
        }

        function showEndGameStats(win) {
            const totalPoints = calculateMatchPoints();
            const statsGrid = document.getElementById('match-stats-grid');
            
            statsGrid.innerHTML = `
                <div class="stat-item">
                    <span class="stat-label">Kills</span>
                    <span class="stat-value">${matchStats.kills} Ã— 5</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Chests Opened</span>
                    <span class="stat-value">${matchStats.chestsOpened} Ã— 1</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Legendaries Held</span>
                    <span class="stat-value">${matchStats.legendariesHeld} Ã— 5</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Placement</span>
                    <span class="stat-value">${matchStats.placement}${matchStats.placement === 1 ? 'st' : matchStats.placement === 2 ? 'nd' : matchStats.placement === 3 ? 'rd' : 'th'}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Level Bonus</span>
                    <span class="stat-value">+${Math.round((playerLevel * 0.05) * 100)}%</span>
                </div>
            `;
            
            if (matchStats.placement <= 10) {
                statsGrid.innerHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Top 10 Bonus</span>
                        <span class="stat-value">10</span>
                    </div>
                `;
            }
            
            if (matchStats.placement <= 2) {
                statsGrid.innerHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Top 2 Bonus</span>
                        <span class="stat-value">15</span>
                    </div>
                `;
            }
            
            if (matchStats.placement === 1) {
                statsGrid.innerHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Victory Royale!</span>
                        <span class="stat-value">50</span>
                    </div>
                `;
            }
            
            document.getElementById('total-points').textContent = `Total Points: ${totalPoints} XP`;
            document.getElementById('endgame-stats').style.display = 'flex';
        }

        // ===============================================================
        // === IMPROVED DAY/NIGHT CYCLE SYSTEM ===========================
        // ===============================================================

        function initDayNightCycle() {
            // Create sun light (directional)
            dayNightCycle.sunLight = new THREE.DirectionalLight(0xffffff, dayNightCycle.ambientIntensity);
            dayNightCycle.sunLight.position.set(100, 200, 100);
            dayNightCycle.sunLight.castShadow = true;
            dayNightCycle.sunLight.shadow.mapSize.width = 2048;
            dayNightCycle.sunLight.shadow.mapSize.height = 2048;
            dayNightCycle.sunLight.shadow.camera.near = 0.5;
            dayNightCycle.sunLight.shadow.camera.far = 500;
            scene.add(dayNightCycle.sunLight);
            
            // Create sun mesh
            const sunGeometry = new THREE.SphereGeometry(15, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            dayNightCycle.sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            dayNightCycle.sunMesh.position.set(300, 300, 300);
            scene.add(dayNightCycle.sunMesh);
            
            // Create moon light (weaker blue light) - no shadows at night
            dayNightCycle.moonLight = new THREE.DirectionalLight(0x88ccff, 0.3);
            dayNightCycle.moonLight.position.set(-100, 200, -100);
            dayNightCycle.moonLight.visible = false;
            dayNightCycle.moonLight.castShadow = false;
            scene.add(dayNightCycle.moonLight);
            
            // Create moon mesh
            const moonGeometry = new THREE.SphereGeometry(10, 32, 32);
            const moonMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xddddff,
                transparent: true,
                opacity: 0.6
            });
            dayNightCycle.moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            dayNightCycle.moonMesh.position.set(-300, 300, -300);
            dayNightCycle.moonMesh.visible = false;
            scene.add(dayNightCycle.moonMesh);
            
            // Update indicator
            updateDayNightIndicator();
        }

        function updateDayNightCycle(dt) {
            dayNightCycle.cycleTime += dt;
            
            // Check if cycle should change
            if (dayNightCycle.cycleTime >= dayNightCycle.cycleDuration) {
                dayNightCycle.cycleTime = 0;
                dayNightCycle.isDay = !dayNightCycle.isDay;
                
                // Smooth transition between day and night
                const transitionDuration = dayNightCycle.transitionDuration;
                const startTime = performance.now();
                
                const transitionInterval = setInterval(() => {
                    const elapsed = (performance.now() - startTime) / 1000;
                    const progress = Math.min(1, elapsed / transitionDuration);
                    
                    if (dayNightCycle.isDay) {
                        // Transition to day
                        const easeProgress = easeInOutCubic(progress);
                        dayNightCycle.sunLight.intensity = dayNightCycle.ambientIntensity * easeProgress;
                        dayNightCycle.moonLight.intensity = 0.3 * (1 - easeProgress);
                        
                        // Update meshes
                        dayNightCycle.sunMesh.visible = true;
                        dayNightCycle.sunMesh.opacity = 0.8 * easeProgress;
                        dayNightCycle.moonMesh.opacity = 0.6 * (1 - easeProgress);
                        
                        // Update scene fog
                        const dayFog = 0x87CEEB;
                        const nightFog = 0x0a0a2a;
                        const fogColor = interpolateColor(dayFog, nightFog, 1 - easeProgress);
                        scene.fog.color.setHex(fogColor);
                        scene.background.setHex(fogColor);
                        
                        // Update shadows
                        dayNightCycle.sunLight.castShadow = easeProgress > 0.5;
                        
                        if (progress >= 1) {
                            dayNightCycle.moonLight.visible = false;
                            dayNightCycle.moonMesh.visible = false;
                            clearInterval(transitionInterval);
                        }
                    } else {
                        // Transition to night
                        const easeProgress = easeInOutCubic(progress);
                        dayNightCycle.sunLight.intensity = dayNightCycle.ambientIntensity * (1 - easeProgress);
                        dayNightCycle.moonLight.visible = true;
                        dayNightCycle.moonLight.intensity = 0.3 * easeProgress;
                        
                        // Update meshes
                        dayNightCycle.moonMesh.visible = true;
                        dayNightCycle.moonMesh.opacity = 0.6 * easeProgress;
                        dayNightCycle.sunMesh.opacity = 0.8 * (1 - easeProgress);
                        
                        // Update scene fog
                        const dayFog = 0x87CEEB;
                        const nightFog = 0x0a0a2a;
                        const fogColor = interpolateColor(dayFog, nightFog, easeProgress);
                        scene.fog.color.setHex(fogColor);
                        scene.background.setHex(fogColor);
                        
                        // Update shadows
                        dayNightCycle.sunLight.castShadow = easeProgress < 0.5;
                        
                        if (progress >= 1) {
                            dayNightCycle.sunMesh.visible = false;
                            clearInterval(transitionInterval);
                        }
                    }
                    
                }, 16); // ~60fps
                
                updateDayNightIndicator();
            }
            
            // Update sun/moon position for day/night
            if (dayNightCycle.isDay) {
                const timeRatio = dayNightCycle.cycleTime / dayNightCycle.cycleDuration;
                const angle = timeRatio * Math.PI * 2;
                const sunHeight = 300 + Math.sin(angle) * 100;
                dayNightCycle.sunMesh.position.y = sunHeight;
                dayNightCycle.sunLight.position.y = sunHeight;
            } else {
                const timeRatio = dayNightCycle.cycleTime / dayNightCycle.cycleDuration;
                const angle = timeRatio * Math.PI * 2;
                const moonHeight = 300 + Math.sin(angle) * 100;
                dayNightCycle.moonMesh.position.y = moonHeight;
                dayNightCycle.moonLight.position.y = moonHeight;
            }
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function interpolateColor(color1, color2, factor) {
            const r1 = (color1 >> 16) & 255;
            const g1 = (color1 >> 8) & 255;
            const b1 = color1 & 255;
            
            const r2 = (color2 >> 16) & 255;
            const g2 = (color2 >> 8) & 255;
            const b2 = color2 & 255;
            
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            
            return (r << 16) | (g << 8) | b;
        }

        function updateDayNightIndicator() {
            const icon = document.getElementById('day-night-icon');
            const text = document.getElementById('day-night-text');
            
            if (dayNightCycle.isDay) {
                icon.textContent = 'ðŸŒž';
                text.textContent = 'Day';
            } else {
                icon.textContent = 'ðŸŒ™';
                text.textContent = 'Night';
            }
        }

        // ===============================================================
        // === VISUAL EFFECTS SYSTEM =====================================
        // ===============================================================

        function createMuzzleFlash(position, direction) {
            const flash = new THREE.PointLight(0xff9900, 2, 10);
            flash.position.copy(position);
            scene.add(flash);
            
            const particles = new THREE.Group();
            for(let i = 0; i < 5; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 4, 4),
                    new THREE.MeshBasicMaterial({ color: 0xff6600 })
                );
                particle.position.copy(position);
                const velocity = direction.clone()
                    .add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    ))
                    .normalize()
                    .multiplyScalar(Math.random() * 5 + 5);
                particles.add(particle);
                visualEffects.push({
                    mesh: particle,
                    velocity: velocity,
                    lifetime: 0.2,
                    age: 0
                });
            }
            scene.add(particles);
            
            setTimeout(() => {
                scene.remove(flash);
                scene.remove(particles);
            }, 100);
        }

        function createBulletTrail(start, end) {
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            visualEffects.push({
                mesh: line,
                lifetime: 0.5,
                age: 0
            });
        }

        function createImpactEffect(position, isHeadshot = false) {
            const particles = new THREE.Group();
            const particleCount = isHeadshot ? 10 : 5;
            
            for(let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 4, 4),
                    new THREE.MeshBasicMaterial({ 
                        color: isHeadshot ? 0xff0000 : 0xff6600,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                particle.position.copy(position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                particles.add(particle);
                visualEffects.push({
                    mesh: particle,
                    velocity: velocity,
                    lifetime: 1,
                    age: 0
                });
            }
            scene.add(particles);
            
            if (isHeadshot) {
                const blood = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xcc0000,
                        transparent: true,
                        opacity: 0.6
                    })
                );
                blood.position.copy(position);
                scene.add(blood);
                
                visualEffects.push({
                    mesh: blood,
                    lifetime: 2,
                    age: 0,
                    scaleDown: true
                });
            }
        }

        function updateVisualEffects(dt) {
            for(let i = visualEffects.length - 1; i >= 0; i--) {
                const effect = visualEffects[i];
                effect.age += dt;
                
                if (effect.age >= effect.lifetime) {
                    scene.remove(effect.mesh);
                    visualEffects.splice(i, 1);
                    continue;
                }
                
                if (effect.velocity) {
                    effect.mesh.position.add(effect.velocity.clone().multiplyScalar(dt));
                }
                
                const progress = effect.age / effect.lifetime;
                if (effect.mesh.material) {
                    effect.mesh.material.opacity = 1 - progress;
                }
                
                if (effect.scaleDown) {
                    effect.mesh.scale.setScalar(1 - progress * 0.5);
                }
            }
        }

        // ===============================================================
        // === PERFORMANCE OPTIMIZATIONS =================================
        // ===============================================================

        function optimizePerformance() {
            // FPS Limiter for high-end devices
            const now = performance.now();
            frameTime = now - lastFrameTime;
            const targetFrameTime = 1000 / targetFPS;
            
            if (frameTime < targetFrameTime) {
                return; // Wait for next frame
            }
            lastFrameTime = now;
            
            // Update FPS counter
            frameCount++;
            if (now - lastFpsUpdate >= 1000) {
                currentFPS = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = now;
                document.getElementById('fps-counter').textContent = `FPS: ${currentFPS}`;
                
                // Auto-adjust settings based on FPS
                if (currentFPS < 30) {
                    renderDistance = 200;
                    botUpdateInterval = 200;
                } else if (currentFPS > 90) {
                    renderDistance = 400;
                    botUpdateInterval = 50;
                } else {
                    renderDistance = 300;
                    botUpdateInterval = 100;
                }
            }
            
            // Cull distant objects
            objects.forEach(obj => {
                obj.visible = obj.position.distanceTo(camera.position) <= renderDistance;
            });
        }

        // ===============================================================
        // === ENHANCED TERRAIN GENERATION ===============================
        // ===============================================================

        function getEnhancedTerrainHeight(x, z) {
            const mountainScale = 0.01;
            const mountainHeight = 30;
            const riverWidth = 20;
            const riverDepth = 5;
            const hillScale1 = 0.02;
            const hillScale2 = 0.05;
            const hillScale3 = 0.1;
            
            let y = 0;
            
            // Base terrain with more variation
            y += Math.sin(x * hillScale1) * 8 + Math.cos(z * hillScale1) * 8;
            y += Math.sin(x * hillScale2 + z * hillScale2) * 4;
            y += Math.sin(x * hillScale3 * 0.7) * Math.cos(z * hillScale3 * 0.7) * 3;
            
            // Snowy mountains in corners
            const distFromCenter = Math.sqrt(x*x + z*z);
            if (distFromCenter > WORLD_SIZE * 0.4) {
                y += (distFromCenter - WORLD_SIZE * 0.4) * 0.3;
                
                if (distFromCenter > WORLD_SIZE * 0.45) {
                    y += Math.sin(distFromCenter * mountainScale) * mountainHeight * 0.5;
                }
            }
            
            // River through middle
            const riverDist = Math.abs(z);
            if (riverDist < riverWidth) {
                y -= riverDepth * (1 - riverDist / riverWidth);
            }
            
            // Additional small hills
            y += Math.sin(x * 0.03) * Math.cos(z * 0.04) * 2;
            
            return y;
        }

        function createEnhancedTerrainMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.1, '#2E8B57');
            gradient.addColorStop(0.3, '#8B7355');
            gradient.addColorStop(0.7, '#A9A9A9');
            gradient.addColorStop(1, '#FFFFFF');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for(let i = 0; i < 1000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 3 + 1;
                ctx.fillRect(x, y, size, size);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(20, 20);
            
            return new THREE.MeshStandardMaterial({ 
                map: texture,
                color: 0x4CAF50,
                roughness: 0.8,
                metalness: 0.2
            });
        }

        // ===============================================================
        // === FIXED BOT AI (IMPROVED MOVEMENT AND DAMAGE) ===============
        // ===============================================================

        function updateEnhancedBots(dt, now) {
            if (now - lastBotUpdate < botUpdateInterval) return;
            lastBotUpdate = now;
            
            for(let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];
                if (bot.health <= 0) continue;

                const h = getEnhancedTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                bot.mesh.position.y = h + 1;

                // Simple wandering behavior when no target
                if (!bot.target || bot.target.dead) {
                    const playerDist = bot.mesh.position.distanceTo(camera.position);
                    
                    if (playerDist < 50 && !player.dead) {
                        bot.target = player;
                    } else {
                        // Wander randomly with improved movement
                        if (now - bot.lastWander > 3000) {
                            bot.wanderDirection = new THREE.Vector3(
                                Math.random() - 0.5,
                                0,
                                Math.random() - 0.5
                            ).normalize();
                            bot.lastWander = now;
                        }
                        
                        bot.mesh.lookAt(
                            bot.mesh.position.x + bot.wanderDirection.x,
                            bot.mesh.position.y,
                            bot.mesh.position.z + bot.wanderDirection.z
                        );
                        
                        bot.mesh.translateZ(WALK_SPEED * 0.4 * dt);
                    }
                }
                
                // Chase player if target exists
                if (bot.target && !bot.target.dead) {
                    const targetPos = bot.target === player ? camera.position : bot.target.mesh.position;
                    const direction = new THREE.Vector3()
                        .subVectors(targetPos, bot.mesh.position)
                        .normalize();
                    
                    bot.mesh.lookAt(
                        bot.mesh.position.x + direction.x,
                        bot.mesh.position.y,
                        bot.mesh.position.z + direction.z
                    );
                    
                    const dist = bot.mesh.position.distanceTo(targetPos);
                    
                    if (dist > 25) {
                        // Move towards target
                        bot.mesh.translateZ(WALK_SPEED * 0.7 * dt);
                    } else if (dist < 8) {
                        // Move away if too close
                        bot.mesh.translateZ(-WALK_SPEED * 0.4 * dt);
                    }
                    
                    // Shoot at target with IMPROVED DAMAGE SYSTEM
                    if (dist < 60 && !bot.isReloading && now - bot.lastShot > bot.weapon.stats.rate * 1000) {
                        const fireOrigin = bot.mesh.position.clone().setY(bot.mesh.position.y + 2.4);
                        const fireDirection = new THREE.Vector3()
                            .subVectors(targetPos.clone().setY(targetPos.y - 0.5), fireOrigin)
                            .normalize();
                        
                        // Add some inaccuracy
                        fireDirection.x += (Math.random() - 0.5) * 0.15;
                        fireDirection.y += (Math.random() - 0.5) * 0.15;
                        fireDirection.z += (Math.random() - 0.5) * 0.15;
                        fireDirection.normalize();
                        
                        createMuzzleFlash(fireOrigin, fireDirection);
                        
                        const ray = new THREE.Raycaster(fireOrigin, fireDirection);
                        const targets = [camera];
                        const hits = ray.intersectObjects(targets, false);
                        
                        if (hits.length > 0) {
                            const hit = hits[0];
                            const damageAmount = bot.weapon.stats.dmg * 0.7; // Bots do 70% damage
                            takeDamage(damageAmount, hit.point); // FIXED: Now actually takes damage
                            createImpactEffect(hit.point, false);
                            playSound('player_hit');
                        }
                        
                        bot.lastShot = now;
                        bot.weapon.stats.currentMag--;
                        
                        if (bot.weapon.stats.currentMag <= 0) {
                            bot.isReloading = true;
                            setTimeout(() => {
                                if (bot.weapon) {
                                    bot.weapon.stats.currentMag = bot.weapon.stats.mag;
                                    bot.isReloading = false;
                                }
                            }, bot.weapon.stats.reload * 1.5); // Bots reload slower
                        }
                    }
                }
                
                // Update bot weapon ammo
                if (bot.weapon && bot.weapon.stats.currentMag <= 0 && !bot.isReloading) {
                    bot.isReloading = true;
                    setTimeout(() => {
                        if (bot.weapon) {
                            bot.weapon.stats.currentMag = bot.weapon.stats.mag;
                            bot.isReloading = false;
                        }
                    }, bot.weapon.stats.reload * 1.5);
                }
            }
        }

        // ===============================================================
        // === SOUND EFFECT SYSTEM =======================================
        // ===============================================================

        let audioContext;
        let soundCache = {};

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!audioContext) initAudio();
            
            const now = performance.now();
            const gainNode = audioContext.createGain();
            const oscillator = audioContext.createOscillator();
            
            switch(type) {
                case 'shoot':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'player_hit':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'elimination':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(659.25, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'reload':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    
                    setTimeout(() => {
                        if (!audioContext) return;
                        const clickOsc = audioContext.createOscillator();
                        const clickGain = audioContext.createGain();
                        clickOsc.type = 'square';
                        clickOsc.frequency.setValueAtTime(150, audioContext.currentTime);
                        clickGain.gain.setValueAtTime(0.15, audioContext.currentTime);
                        clickGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                        clickOsc.connect(clickGain);
                        clickGain.connect(audioContext.destination);
                        clickOsc.start();
                        clickOsc.stop(audioContext.currentTime + 0.05);
                    }, 150);
                    break;
                    
                case 'victory':
                    const notes = [523.25, 659.25, 783.99, 1046.50];
                    notes.forEach((freq, i) => {
                        setTimeout(() => {
                            if (!audioContext) return;
                            const noteOsc = audioContext.createOscillator();
                            const noteGain = audioContext.createGain();
                            noteOsc.type = 'sine';
                            noteOsc.frequency.setValueAtTime(freq, audioContext.currentTime);
                            noteGain.gain.setValueAtTime(0.3, audioContext.currentTime);
                            noteGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            noteOsc.connect(noteGain);
                            noteGain.connect(audioContext.destination);
                            noteOsc.start();
                            noteOsc.stop(audioContext.currentTime + 0.3);
                        }, i * 200);
                    });
                    break;
                    
                case 'defeat':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(130.81, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(87.31, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'jump':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'build':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'storm_damage':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'open_chest':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(523.25, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'pickup_item':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'explosion':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(50, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'impact_hit':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
            }
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
        }

        // ===============================================================
        // === CONTROLLER VIBRATION SYSTEM ==============================
        // ===============================================================

        function vibrateController(pattern = 'light') {
            if (!controllerConnected || !controllerVibration || !gamepad) return;
            
            let vibrationPattern;
            
            switch(pattern) {
                case 'light':
                    vibrationPattern = { duration: 100, weakMagnitude: 0.3, strongMagnitude: 0.1 };
                    break;
                case 'medium':
                    vibrationPattern = { duration: 150, weakMagnitude: 0.6, strongMagnitude: 0.3 };
                    break;
                case 'strong':
                    vibrationPattern = { duration: 200, weakMagnitude: 1.0, strongMagnitude: 0.7 };
                    break;
                case 'shoot':
                    vibrationPattern = { duration: 80, weakMagnitude: 0.4, strongMagnitude: 0.8 };
                    break;
                case 'hit':
                    vibrationPattern = { duration: 250, weakMagnitude: 0.8, strongMagnitude: 1.0 };
                    break;
                case 'reload':
                    vibrationPattern = { duration: 300, weakMagnitude: 0.2, strongMagnitude: 0.4 };
                    break;
                case 'jump':
                    vibrationPattern = { duration: 100, weakMagnitude: 0.5, strongMagnitude: 0.2 };
                    break;
                default:
                    vibrationPattern = { duration: 100, weakMagnitude: 0.3, strongMagnitude: 0.1 };
            }
            
            try {
                if (gamepad.vibrationActuator) {
                    gamepad.vibrationActuator.playEffect("dual-rumble", {
                        duration: vibrationPattern.duration,
                        weakMagnitude: vibrationPattern.weakMagnitude,
                        strongMagnitude: vibrationPattern.strongMagnitude
                    });
                }
            } catch (e) {
                console.log("Vibration not supported on this controller");
            }
        }

        function showControllerNotification() {
            const notification = document.getElementById('controller-notification');
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // ===============================================================
        // === UTILITY FUNCTIONS =========================================
        // ===============================================================

        function getTerrainHeight(x, z) {
            return getEnhancedTerrainHeight(x, z);
        }
        
        function createBox(x, y, z, w, h, d, col, type='solid') {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: col}));
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh); 
            buildings.push({ mesh: mesh, type: type, health: 100 });
            return mesh;
        }

        function createDoor(x, y, z, rotationY) {
            const doorGeo = new THREE.BoxGeometry(1.5, 3, 0.1);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, transparent: true, opacity: 0.8 });
            const doorMesh = new THREE.Mesh(doorGeo, doorMat);
            doorMesh.position.set(x, y + 1.5, z);
            doorMesh.rotation.y = rotationY;
            scene.add(doorMesh);
            
            objects.push(doorMesh); 
            doors.push({ mesh: doorMesh, open: false, initialRotation: rotationY });
            
            return doorMesh;
        }
        
        function checkWin() {
            if (bots.length === 0 && !player.dead) {
                handleGameOver(true);
            }
        }
        
        function handleGameOver(win) {
            player.dead = true;
            if (controls && controls.isLocked) controls.unlock(); 
            
            if (win) {
                victoryRoyales = (parseInt(localStorage.getItem('victoryRoyales')) || 0) + 1;
                localStorage.setItem('victoryRoyales', victoryRoyales);

                createVictoryParticles();
                document.getElementById('victory-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('victory-overlay').style.display = 'flex';
                playSound('victory');
                setTimeout(() => showEndGameStats(true), 2000);
            } else {
                createEliminatedParticles();
                document.getElementById('go-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('game-over').style.display = 'flex';
                playSound('defeat');
                setTimeout(() => showEndGameStats(false), 2000);
            }
        }
        
        function createVictoryParticles() {
            const container = document.getElementById('victory-particles');
            container.innerHTML = '';
            for(let i = 0; i < 80; i++) {
                const particle = document.createElement('div');
                particle.className = 'victory-particle';
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 5}s`;
                particle.style.animationDuration = `${Math.random() * 3 + 5}s`;
                particle.style.opacity = Math.random() * 0.5 + 0.5;
                container.appendChild(particle);
            }
        }
        
        function createEliminatedParticles() {
            const container = document.getElementById('eliminated-particles');
            container.innerHTML = '';
            for(let i = 0; i < 60; i++) {
                const particle = document.createElement('div');
                particle.className = 'eliminated-particle';
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 3}s`;
                particle.style.animationDuration = `${Math.random() * 2 + 3}s`;
                particle.style.opacity = Math.random() * 0.4 + 0.3;
                container.appendChild(particle);
            }
        }

        // FIXED: IMPROVED ADS SYSTEM - Better sniper zoom
        function toggleADS(bool) {
            player.ads = bool;
            const item = player.inventory[player.slot];
            const isClassicScope = item && item.category === 'weapon' && item.stats.scope === 'classic';
            const isRedDotScope = item && item.category === 'weapon' && item.stats.scope === 'red_dot';
            const isHoloScope = item && item.category === 'weapon' && item.stats.scope === 'holo_twister';
            
            const scopeOverlay = document.getElementById('scope-overlay');
            const redDotScope = document.getElementById('red-dot-scope');
            const crosshair = document.getElementById('crosshair');

            scopeOverlay.style.display = 'none';
            redDotScope.style.display = 'none';
            
            const isScoped = isClassicScope || isRedDotScope || isHoloScope;
            
            if (bool && isScoped) {
                crosshair.style.display = 'none';
                if (isClassicScope) {
                    scopeOverlay.style.display = 'block';
                    camera.fov = 5; // Much better zoom for snipers
                    scopeOverlay.style.background = 'radial-gradient(circle, transparent 15%, rgba(0, 0, 0, 0.98) 16%, black 100%)';
                } else if (isRedDotScope || isHoloScope) {
                    redDotScope.style.display = 'block';
                    camera.fov = 15; // Better zoom for red dot/holo
                }
            } else {
                const isSniperFamily = item && item.category === 'weapon' && (item.stats.scope === 'classic' || item.stats.scope === 'red_dot' || item.stats.scope === 'holo_twister');
                crosshair.style.display = (isSniperFamily && !bool) ? 'none' : 'block';
                camera.fov = 75;
            }

            camera.updateProjectionMatrix();
        }

        function showDamage(amount, position, type = 'body', isHeadshot = false) {
            const dmgNumber = document.createElement('div');
            dmgNumber.className = 'dmg-number' + (isHeadshot ? ' headshot' : '') + (type === 'storm' ? ' storm' : '');
            dmgNumber.innerText = Math.round(amount);
            
            const worldPoint = position.clone().project(camera);
            
            const x = (worldPoint.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-worldPoint.y * 0.5 + 0.5) * window.innerHeight;
            
            dmgNumber.style.left = `${x}px`;
            dmgNumber.style.top = `${y}px`;
            
            document.getElementById('ui-layer').appendChild(dmgNumber);
            
            setTimeout(() => {
                dmgNumber.remove();
            }, 1200);
        }

        function reload() {
            const item = player.inventory[player.slot];
            if (!item || item.category !== 'weapon' || item.stats.currentMag === item.stats.mag || player.isReloading) return;
            
            // Interrupt Healing
            if (player.isHealing) finishHealing();
            
            playSound('reload');
            if (controllerConnected) vibrateController('reload');

            player.isReloading = true;
            document.getElementById('reload-indicator').style.display = 'block';
            updateUI();

            const reloadTime = item.stats.reload * item.rarity.reload;

            setTimeout(() => {
                item.stats.currentMag = item.stats.mag;
                player.isReloading = false;
                document.getElementById('reload-indicator').style.display = 'none';
                updateUI();
            }, reloadTime);
        }

        function buildWall() {
            if (player.wood < 10) return;
            
            playSound('build');
            if (controllerConnected) vibrateController('light');

            const wallGeo = new THREE.BoxGeometry(4, 4, 0.1);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, transparent: true, opacity: 0.8 });
            const wall = new THREE.Mesh(wallGeo, wallMat);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0;
            dir.normalize();

            wall.position.copy(camera.position).add(dir.multiplyScalar(5)).setY(getTerrainHeight(camera.position.x, camera.position.z) + 2);
            wall.rotation.y = camera.rotation.y;
            scene.add(wall);
            
            objects.push(wall);
            buildings.push({ mesh: wall, type: 'indestructible_wood', health: Infinity }); 
            player.wood -= 10;
            updateUI();
        }

        // ===============================================================
        // === IMPROVED STORM LOGIC ======================================
        // ===============================================================

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function startStormTimer() {
            if (stormTimerInterval) clearInterval(stormTimerInterval);

            const nextPhase = STORM_PHASES[stormPhase];
            if (!nextPhase) {
                document.getElementById('storm-status').innerText = "FINAL";
                document.getElementById('storm-timer').innerText = "00:00";
                return;
            }
            
            stormPhaseTimer = nextPhase.time;
            document.getElementById('storm-status').innerText = nextPhase.status;
            stormDamageRate = nextPhase.damage; 
            
            const startRadius = stormRadius;
            const endRadius = nextPhase.radius;
            const startTime = performance.now();

            stormTimerInterval = setInterval(() => {
                if (player.dead) {
                    clearInterval(stormTimerInterval);
                    return;
                }
                
                stormPhaseTimer -= 1;
                document.getElementById('storm-timer').innerText = formatTime(stormPhaseTimer);
                
                if (nextPhase.status === "Shrink" || nextPhase.status === "Deathmatch") {
                    const elapsed = performance.now() - startTime;
                    const duration = nextPhase.time * 1000;
                    const t = Math.min(1, elapsed / duration);
                    // Smooth interpolation for storm shrinking
                    const easeT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    stormRadius = startRadius + (endRadius - startRadius) * easeT;
                    stormActive = true; 
                } else if (nextPhase.status === "Hold") {
                    stormActive = true;
                } else if (nextPhase.status === "Wait") {
                    stormActive = false;
                }

                if (stormPhaseTimer <= 0) {
                    clearInterval(stormTimerInterval);
                    stormPhase++;
                    startStormTimer();
                }
                
                // Update alive count
                updateAliveCount();
            }, 1000);
        }
        
        function updateStorm(now) {
            const playerPos2D = new THREE.Vector2(camera.position.x, camera.position.z);
            const distToStorm = playerPos2D.distanceTo(stormCenter);
            const inStorm = stormActive && distToStorm > stormRadius;

            document.getElementById('storm-overlay').classList.toggle('in-storm', inStorm);

            // Damage Application - Player
            if (inStorm && stormDamageRate > 0) {
                if (now - player.lastStormDamage > 1000) {
                    takeDamage(stormDamageRate, camera.position, 'storm'); 
                    player.lastStormDamage = now;
                    playSound('storm_damage');
                    
                    // Visual effect for storm damage
                    const stormEffect = document.createElement('div');
                    stormEffect.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(138, 43, 226, 0.3);
                        pointer-events: none;
                        z-index: 999;
                        animation: flashStorm 0.3s forwards;
                    `;
                    document.body.appendChild(stormEffect);
                    
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes flashStorm {
                            0% { opacity: 0.3; }
                            50% { opacity: 0.6; }
                            100% { opacity: 0; }
                        }
                    `;
                    document.head.appendChild(style);
                    
                    setTimeout(() => {
                        stormEffect.remove();
                        style.remove();
                    }, 300);
                }
            } 

            // Damage Application - Bots
            bots.forEach(bot => {
                const botPos2D = new THREE.Vector2(bot.mesh.position.x, bot.mesh.position.z);
                const botDistToStorm = botPos2D.distanceTo(stormCenter);
                const botInStorm = stormActive && botDistToStorm > stormRadius;
                
                if (botInStorm && BOT_STORM_DAMAGE > 0) {
                     if (now - (bot.lastStormDamage || 0) > 1000) {
                        bot.health = Math.max(0, bot.health - BOT_STORM_DAMAGE); 
                        bot.lastStormDamage = now;
                        showDamage(BOT_STORM_DAMAGE, bot.mesh.position.clone().setY(bot.mesh.position.y + 1), 'storm');
                        
                        if (bot.health <= 0) {
                            scene.remove(bot.mesh);
                            bots = bots.filter(b => b !== bot);
                            player.wood += 50;
                            updateAliveCount();
                            checkWin();
                        }
                    }
                }
            });
        }
        
        // FIXED: Update alive count function
        function updateAliveCount() {
            const aliveCount = bots.length + (player.dead ? 0 : 1);
            document.getElementById('alive-count').innerText = aliveCount;
            document.getElementById('total-players').innerText = aliveCount;
        }

        // ===============================================================
        // === NEW POIS FROM FORTNITE ====================================
        // ===============================================================

        // NEW POI 1: Lazy Lake inspired
        function createLazyLake() {
            const x = 150, z = -150;
            const h = getEnhancedTerrainHeight(x, z);
            
            // Create lake area
            const lakeGeometry = new THREE.CircleGeometry(40, 32);
            const lakeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1E90FF,
                transparent: true,
                opacity: 0.7
            });
            const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
            lake.rotation.x = -Math.PI / 2;
            lake.position.set(x, h + 0.1, z);
            scene.add(lake);
            objects.push(lake);
            
            // Buildings around the lake
            const buildingPositions = [
                { x: x + 50, z: z + 50 },
                { x: x - 50, z: z + 50 },
                { x: x + 50, z: z - 50 },
                { x: x - 50, z: z - 50 }
            ];
            
            buildingPositions.forEach(pos => {
                createBox(pos.x, h + 8, pos.z, 12, 16, 12, 0x708090);
                createBox(pos.x, h + 20, pos.z, 14, 4, 14, 0x808080);
                
                // Spawn chests
                if (Math.random() < 0.8) {
                    spawnChest(pos.x, h + 1, pos.z);
                }
            });
            
            // Central fountain
            createBox(x, h + 2, z, 5, 4, 5, 0x00BFFF);
            createBox(x, h + 6, z, 3, 6, 3, 0x87CEEB);
            
            // Bridges
            createBox(x + 40, h + 1, z, 4, 1, 15, 0x8B4513);
            createBox(x - 40, h + 1, z, 4, 1, 15, 0x8B4513);
            createBox(x, h + 1, z + 40, 15, 1, 4, 0x8B4513);
            createBox(x, h + 1, z - 40, 15, 1, 4, 0x8B4513);
            
            console.log("Created Lazy Lake POI");
        }

        // NEW POI 2: Salty Springs inspired
        function createSaltySprings() {
            const x = -150, z = 150;
            const h = getEnhancedTerrainHeight(x, z);
            
            // Create town area with houses
            const houseCount = 6;
            const radius = 40;
            
            for(let i = 0; i < houseCount; i++) {
                const angle = (i / houseCount) * Math.PI * 2;
                const houseX = x + Math.cos(angle) * radius;
                const houseZ = z + Math.sin(angle) * radius;
                
                // Main house
                createBox(houseX, h + 6, houseZ, 10, 12, 10, 0xD2B48C);
                createBox(houseX, h + 14, houseZ, 12, 4, 12, 0xA0522D);
                
                // Garage
                createBox(houseX + 8, h + 4, houseZ, 6, 8, 8, 0x696969);
                
                // Spawn chests (higher chance)
                spawnChest(houseX, h + 1, houseZ);
                if (Math.random() < 0.5) {
                    spawnChest(houseX + 4, h + 1, houseZ + 4);
                }
            }
            
            // Central gas station
            createBox(x, h + 5, z, 20, 10, 20, 0xFF6B6B);
            createBox(x, h + 15, z, 22, 5, 22, 0xFF4444);
            
            // Gas pumps
            for(let i = 0; i < 4; i++) {
                const pumpX = x - 15 + (i % 2) * 30;
                const pumpZ = z - 15 + Math.floor(i / 2) * 30;
                createBox(pumpX, h + 3, pumpZ, 2, 6, 2, 0x333333);
            }
            
            console.log("Created Salty Springs POI");
        }

        // NEW POI 3: Coral Castle inspired
        function createCoralCastle() {
            const x = 300, z = -300;
            const h = getEnhancedTerrainHeight(x, z);
            
            // Main castle structure
            createBox(x, h + 20, z, 30, 40, 30, 0x00CED1);
            createBox(x, h + 45, z, 35, 10, 35, 0x20B2AA);
            
            // Towers at corners
            const towerPositions = [
                { x: x + 25, z: z + 25 },
                { x: x - 25, z: z + 25 },
                { x: x + 25, z: z - 25 },
                { x: x - 25, z: z - 25 }
            ];
            
            towerPositions.forEach(pos => {
                createBox(pos.x, h + 30, pos.z, 8, 60, 8, 0x48D1CC);
                createBox(pos.x, h + 65, pos.z, 10, 10, 10, 0x40E0D0);
            });
            
            // Central platform
            createBox(x, h + 0.1, z, 60, 0.2, 60, 0xAFEEEE);
            
            // Coral decorations
            for(let i = 0; i < 20; i++) {
                const coralX = x + (Math.random() - 0.5) * 50;
                const coralZ = z + (Math.random() - 0.5) * 50;
                const coralHeight = Math.random() * 5 + 2;
                createBox(coralX, h + coralHeight/2, coralZ, 
                         Math.random() * 3 + 1, coralHeight, Math.random() * 3 + 1, 
                         [0xFF69B4, 0xFF1493, 0xFF00FF][Math.floor(Math.random() * 3)]);
            }
            
            // Spawn chests inside castle
            spawnChest(x, h + 5, z);
            spawnChest(x + 10, h + 5, z + 10);
            spawnChest(x - 10, h + 5, z - 10);
            
            console.log("Created Coral Castle POI");
        }

        function generateTerrain() {
            const size = WORLD_SIZE;
            const segments = 96;
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            geometry.rotateX(-Math.PI / 2);

            const position = geometry.attributes.position;
            for (let i = 0; i < position.count; i++) {
                const x = position.getX(i);
                const z = position.getZ(i);
                const y = getEnhancedTerrainHeight(x, z);
                position.setY(i, y);
            }
            position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            const terrainMat = createEnhancedTerrainMaterial();
            const terrain = new THREE.Mesh(geometry, terrainMat);
            terrain.receiveShadow = true;
            scene.add(terrain);
            objects.push(terrain); 
        }

        function createTower(x, z) {
            const h = getEnhancedTerrainHeight(x, z);
            createBox(x, h+10, z, 5, 20, 5, 0x999999);
            createBox(x, h+21, z, 7, 2, 7, 0xAAAAAA);
            spawnChest(x, h+23, z); 
        }
        
        function createBuilding(x, z, size, height, depth, color, rotation) {
            const h = getEnhancedTerrainHeight(x, z);
            const mesh = createBox(x, h + height/2, z, size, height, depth, color);
            mesh.rotation.y = rotation;
            spawnChest(x+size/4, h+1, z+depth/4); 
        }
        
        function createWoodHouse(x, z, size, height, depth) {
            const h = getEnhancedTerrainHeight(x, z);
            createBox(x, h+height/2, z, size, height, depth, 0x8B4513);
            createBox(x, h+height+1, z, size+2, 2, depth+2, 0x555555); 
            spawnChest(x, h+1, z); 
        }
        
        function createTree(x, z) {
            const h = getEnhancedTerrainHeight(x, z);
            createBox(x, h+2, z, 0.5, 4, 0.5, 0x8B4513, 'tree'); 
            createBox(x, h+5, z, 3, 3, 3, 0x228B22, 'tree'); 
        }

        // Fortnite POI 1 - Tilted Towers inspired
        function createTiltedTowers() {
            const x = -150, z = -150;
            const h = getEnhancedTerrainHeight(x, z);
            
            // Main towers
            for(let i = 0; i < 4; i++) {
                for(let j = 0; j < 4; j++) {
                    const towerX = x + (i * 25);
                    const towerZ = z + (j * 25);
                    createBox(towerX, h+15, towerZ, 8, 30, 8, 0x708090);
                    
                    // Add some destroyed towers
                    if (Math.random() < 0.3) {
                        createBox(towerX + 2, h+40, towerZ + 2, 6, 10, 6, 0x505050);
                    }
                }
            }
            
            // Central plaza
            createBox(x + 50, h+0.1, z + 50, 40, 0.2, 40, 0x444444);
            
            // Chest spawns
            for(let i = 0; i < 6; i++) {
                const chestX = x + 20 + (Math.random() * 60);
                const chestZ = z + 20 + (Math.random() * 60);
                spawnChest(chestX, h+1, chestZ);
            }
        }

        // Fortnite POI 2 - Pleasant Park inspired
        function createPleasantPark() {
            const x = 200, z = 200;
            const h = getEnhancedTerrainHeight(x, z);
            
            // Create houses in a circle
            const houseCount = 8;
            const radius = 60;
            
            for(let i = 0; i < houseCount; i++) {
                const angle = (i / houseCount) * Math.PI * 2;
                const houseX = x + Math.cos(angle) * radius;
                const houseZ = z + Math.sin(angle) * radius;
                
                createWoodHouse(houseX, houseZ, 12, 10, 12);
                
                // Add garage
                createBox(houseX + 8, h+4, houseZ, 6, 5, 8, 0x666666);
                
                // Spawn chests
                if (Math.random() < 0.7) {
                    spawnChest(houseX, h+1, houseZ);
                }
            }
            
            // Central park
            createBox(x, h+0.1, z, 40, 0.2, 40, 0x2E8B57);
            createBox(x, h+3, z, 3, 6, 3, 0x8B4513); // Central tree
        }

        function generatePOIs() {
            // Original POIs
            for(let i=0; i<3; i++) {
                const x = (Math.random()-0.5)*80;
                const z = (Math.random()-0.5)*80;
                createTower(x, z);
            }

            createBuilding(-200, -200, 20, 10, 30, 0x444444, Math.PI/2);
            createWoodHouse(-200, 200, 10, 12, 15); 
            createBuilding(250, 250, 15, 8, 15, 0xFF7F50, 0); 
            createBox(-250, getEnhancedTerrainHeight(-250, 250)+0.1, 250, 50, 0.2, 50, 0x00BFFF); 
            createBox(-250, getEnhancedTerrainHeight(-250, -250)-5, -250, 30, 10, 30, 0x696969); 
            createWoodHouse(-280, 0, 10, 8, 10); 
            createBox(280, getEnhancedTerrainHeight(280, 0)+5, 0, 10, 10, 10, 0xFF6347); 
            createBuilding(50, 200, 12, 6, 12, 0x808080, Math.PI/4); 
            createWoodHouse(150, -100, 20, 5, 20); 
            createBox(-150, getEnhancedTerrainHeight(-150, 100)+10, 100, 2, 20, 10, 0x000000); 
            createBox(100, getEnhancedTerrainHeight(100, -250)-10, -250, 40, 20, 40, 0x222222); 
            createBox(-100, getEnhancedTerrainHeight(-100, -300)+0.1, -300, 30, 0.2, 30, 0x00FF7F); 
            createBuilding(300, 150, 18, 10, 18, 0x9370DB, -Math.PI/4); 
            createBox(0, getEnhancedTerrainHeight(0, 300), 300, 40, 0.5, 40, 0xADD8E6); 
            createBox(300, getEnhancedTerrainHeight(300, -300)+15, -300, 8, 30, 8, 0xEEEEEE); 
            createBox(-300, getEnhancedTerrainHeight(-300, 150)+0.5, 150, 25, 1, 25, 0xF4A460); 
            createWoodHouse(200, 0, 20, 10, 10); 

            // Additional POIs
            for(let i=0; i<3; i++) {
                for(let j=0; j<3; j++) {
                    const x = -350 + (i*25);
                    const z = -250 + (j*25);
                    createBox(x, getEnhancedTerrainHeight(x, z)+0.5, z, 8, 6, 8, 0xD2B48C);
                }
            }
            createBox(-325, getEnhancedTerrainHeight(-325, -225)+10, -225, 5, 20, 5, 0x8B7355);
            
            createBox(350, getEnhancedTerrainHeight(350, -350)+0.1, -350, 60, 0.5, 60, 0xFF6B6B);
            for(let i=0; i<4; i++) {
                const angle = (i*Math.PI*2)/4;
                const x = 350 + Math.cos(angle)*30;
                const z = -350 + Math.sin(angle)*30;
                createBuilding(x, z, 10, 8, 10, 0xFFD166, angle);
            }
            createBox(350, getEnhancedTerrainHeight(350, -350)+15, -350, 5, 30, 5, 0x06D6A0);
            
            for(let i=0; i<8; i++) {
                const x = 400 + (Math.random()-0.5)*40;
                const z = 150 + (Math.random()-0.5)*40;
                createTree(x, z);
            }
            createBuilding(400, 150, 25, 12, 25, 0x8B4513, 0);
            createBox(380, getEnhancedTerrainHeight(380, 170)+6, 170, 20, 2, 20, 0xA0522D);
            
            createBox(-400, getEnhancedTerrainHeight(-400, 400)+0.1, 400, 80, 0.5, 60, 0x1E90FF);
            for(let i=0; i<5; i++) {
                const x = -430 + (i*20);
                createWoodHouse(x, 380, 8, 7, 8);
            }
            createBox(-420, getEnhancedTerrainHeight(-420, 420)+12, 420, 4, 24, 4, 0x708090);
            
            createBox(0, getEnhancedTerrainHeight(0, -400)-10, -400, 50, 20, 50, 0x696969);
            createBuilding(20, -380, 15, 8, 15, 0x333333, Math.PI/4);
            createBuilding(-20, -420, 15, 8, 15, 0x333333, -Math.PI/4);
            createBox(0, getEnhancedTerrainHeight(0, -400)+5, -400, 10, 10, 10, 0xFFD700);

            // Original Trees
            for(let i=0; i<40; i++) {
                const x = (Math.random()-0.5)*400;
                const z = (Math.random()-0.5)*400;
                createTree(x, z);
            }
            
            // Fortnite POIs
            createTiltedTowers();
            createPleasantPark();
            
            // NEW: Add the 3 new POIs for V19.8
            createLazyLake();
            createSaltySprings();
            createCoralCastle();
        }

        function spawnCars() {
            for(let i=0; i<3; i++) {
                const x = (Math.random()-0.5)*200;
                const z = (Math.random()-0.5)*200;
                const h = getEnhancedTerrainHeight(x, z);
                
                const carGroup = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 5), new THREE.MeshStandardMaterial({color: Math.random() * 0xffffff}));
                body.position.y = 1;
                carGroup.add(body);
                
                carGroup.position.set(x, h, z); 
                scene.add(carGroup);
                
                cars.push({ mesh: carGroup, speed: 0, rotationY: carGroup.rotation.y, driving: false, raycaster: new THREE.Raycaster() });
            }
        }

        function spawnChest(x, y, z) {
            const chest = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1), new THREE.MeshStandardMaterial({color: 0xFFD700}));
            chest.position.set(x, y, z);
            scene.add(chest);
            chests.push(chest);
        }
        
        function createBotMesh(x, y, z) {
            const group = new THREE.Group();
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({color: 0xFFA07A}));
            head.position.y = 2.4; 
            group.add(head);

            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.5), new THREE.MeshStandardMaterial({color: 0x007bff}));
            body.position.y = 1.6;
            group.add(body);

            const legGeo = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const legMat = new THREE.MeshStandardMaterial({color: 0x444444});
            const legL = new THREE.Mesh(legGeo, legMat);
            legL.position.set(-0.3, 0.6, 0);
            const legR = new THREE.Mesh(legGeo, legMat);
            legR.position.set(0.3, 0.6, 0);
            group.add(legL);
            group.add(legR);

            group.position.set(x, y, z);
            return group;
        }

        function spawnBots() {
            for(let i=0; i<BOT_COUNT; i++) { 
                let x, z;
                do {
                    x = (Math.random()-0.5)*WORLD_SIZE*0.8;
                    z = (Math.random()-0.5)*WORLD_SIZE*0.8;
                } while (Math.abs(x) < 100 && Math.abs(z) < 100); 

                const h = getEnhancedTerrainHeight(x, z);
                
                const mesh = createBotMesh(x, h + 1, z);
                scene.add(mesh);
                
                const randomWeaponKeys = ['RFAR', 'STINGER', 'DRUM_SMG', 'PISTOL'];
                const botWeaponKey = randomWeaponKeys[Math.floor(Math.random() * randomWeaponKeys.length)];
                const botWeapon = createWeaponItem(botWeaponKey, 'COMMON');
                botWeapon.stats.currentMag = botWeapon.stats.mag; 
                
                bots.push({ 
                    mesh: mesh, 
                    health: 200, 
                    shield: 100, 
                    target: null, 
                    lastShot: 0, 
                    weapon: botWeapon, 
                    lastMove: performance.now(),
                    velocity: new THREE.Vector3(0, 0, 0),
                    lastStormDamage: 0,
                    moveCooldown: 0, 
                    wanderDirection: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(),
                    lastWander: performance.now(),
                    isReloading: false
                });
            }
        }

        // ===============================================================
        // === ITEM & HEALING LOGIC ======================================
        // ===============================================================

        // FIXED: Can switch healing item with healing item
        function useHealingItem() {
            const item = player.inventory[player.slot];
            
            if (player.isHealing) {
                if (!player.healingItem.continuous) finishHealing();
                return;
            }

            if (!item || item.category !== 'consumable' || item.count <= 0) return;
            
            if (item.instant) {
                 if (item.type === 'shield' && (player.shield < item.max || player.overshield < OVER_SHIELD_MAX)) {
                    if(player.shield < 100) {
                        player.shield = Math.min(item.max, player.shield + item.val);
                    } else if (player.overshield < OVER_SHIELD_MAX) {
                        player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + item.val);
                    } else {
                        return; 
                    }
                    item.count -= 1; 
                    if (item.count <= 0) player.inventory[player.slot] = null;
                    updateUI();
                    playSound('pickup_item');
                    if (player.overshield < OVER_SHIELD_MAX) {
                        player.lastOvershieldDamage = performance.now();
                        player.lastOvershieldBreak = performance.now();
                    }
                    return;
                }
            }

            let canUse = false;
            if (item.type === 'shield' && (player.shield < item.max || player.overshield < OVER_SHIELD_MAX)) canUse = true;
            if (item.type === 'health' && player.health < item.max) canUse = true;
            if (item.type === 'continuous') canUse = (player.health < 100 || player.shield < 100 || player.overshield < OVER_SHIELD_MAX);

            if (canUse) {
                player.isHealing = true;
                player.healingItem = item;
                player.healingStartTime = performance.now();
                document.getElementById('healing-progress').style.display = 'block';
                document.getElementById('healing-text').innerText = `USING ${item.name.toUpperCase()}...`;
                updateUI();
                
                if (!item.continuous && !item.instant) {
                    playSound('open_chest');
                    setTimeout(() => {
                        if(player.isHealing && player.healingItem === item) {
                            applyHealing(item);
                            finishHealing();
                            playSound('pickup_item');
                        }
                    }, item.time);
                } else if (item.continuous) {
                    playSound('open_chest');
                }
            }
        }
        
        function applyHealing(item) {
            if (item.type === 'shield') {
                player.shield = Math.min(item.max, player.shield + item.val); 
            } else if (item.type === 'health') {
                player.health = Math.min(item.max, player.health + item.val);
            } 
            
            item.count -= 1;
            if (item.count <= 0) {
                const slotIndex = player.inventory.findIndex(i => i === item);
                if (slotIndex !== -1) player.inventory[slotIndex] = null;
            }
            updateUI();
        }
        
        function applyContinuousHealing(item, dt) {
            const timeElapsed = performance.now() - player.healingStartTime;
            const percentage = Math.min(1, timeElapsed / item.time);
            document.getElementById('healing-bar').style.width = `${percentage * 100}%`;
            
            const interval = 1000; 
            if (!player.lastHealTick || (performance.now() - player.lastHealTick) >= interval) {
                if(player.overshield < OVER_SHIELD_MAX) {
                    player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + item.shieldVal); 
                    player.lastOvershieldBreak = performance.now();
                } else if(player.shield < 100) {
                    player.shield = Math.min(100, player.shield + item.shieldVal); 
                } else if (player.health < 100) {
                    player.health = Math.min(100, player.health + item.val);
                }
                updateUI();
                player.lastHealTick = performance.now();
            }

            if (timeElapsed >= item.time || (player.health === 100 && player.shield === 100 && player.overshield === OVER_SHIELD_MAX)) {
                finishHealing();
                playSound('pickup_item');
            }
        }

        function finishHealing() {
            if (!player.isHealing) return; 

            player.isHealing = false;
            
            const item = player.healingItem;
            if (item && item.continuous) {
                 item.count -= 1;
                 if (item.count <= 0) {
                    const slotIndex = player.inventory.findIndex(i => i === item);
                    if (slotIndex !== -1) player.inventory[slotIndex] = null;
                 }
            }

            player.healingItem = null;
            player.lastHealTick = 0;
            document.getElementById('healing-progress').style.display = 'none';
            
            updateUI();
        }

        // FIXED: Improved interaction system
        function tryInteract() {
            const pos = camera.position;
            
            // Check Doors
            for(let door of doors) {
                if(pos.distanceTo(door.mesh.position) < 5) {
                    door.open = !door.open;
                    const rotation = door.open ? door.initialRotation + Math.PI / 2 : door.initialRotation;
                    door.mesh.rotation.y = rotation;
                    
                    const shiftDir = new THREE.Vector3();
                    shiftDir.setFromEuler(new THREE.Euler(0, door.initialRotation + Math.PI / 4, 0));
                    door.mesh.position.sub(shiftDir.multiplyScalar(0.75)); 
                    playSound('open_chest');
                    if (player.isHealing) finishHealing();
                    return;
                }
            }

            // Check Cars
            for(let c of cars) {
                if(pos.distanceTo(c.mesh.position) < 5) {
                    if(player.vehicle) {
                        player.vehicle.driving = false;
                        player.vehicle = null;
                        camera.position.y += 2; 
                        camera.position.x = c.mesh.position.x + 5; 
                        camera.position.z = c.mesh.position.z + 5; 
                        playSound('pickup_item');
                    } else {
                        if (player.isHealing) finishHealing();
                        player.vehicle = c;
                        c.driving = true;
                        playSound('pickup_item');
                    }
                    updateUI();
                    return;
                }
            }
            
            // Check Chests
            for(let i=chests.length-1; i>=0; i--) {
                if(pos.distanceTo(chests[i].position) < 4) {
                    const chestPos = chests[i].position.clone();
                    scene.remove(chests[i]);
                    chests.splice(i, 1);
                    
                    if (player.isHealing) finishHealing();

                    const randomWeaponKey = getRandomWeaponKey();
                    const randomRarity = getRandomRarity();
                    spawnLoot(chestPos.x + 0.5, chestPos.y, chestPos.z + 0.5, 'weapon', randomRarity, randomWeaponKey);
                    
                    if (Math.random() < 0.15) {
                        spawnLoot(chestPos.x - 0.5, chestPos.y, chestPos.z - 0.5, 'weapon', randomRarity, 'HEAVY_AR');
                    } else {
                        const randomConsumableKey = getRandomConsumableKey();
                        spawnLoot(chestPos.x - 0.5, chestPos.y, chestPos.z - 0.5, 'consumable', randomConsumableKey);
                    }
                    
                    if (Math.random() < 0.3) {
                        spawnLoot(chestPos.x, chestPos.y, chestPos.z, 'weapon', getRandomRarity(), getRandomWeaponKey());
                    }
                    
                    matchStats.chestsOpened++;
                    playSound('open_chest');
                    return;
                }
            }

            // FIXED: Better item swapping logic
            for(let i=loot.length-1; i>=0; i--) {
                const currentLoot = loot[i];
                if(pos.distanceTo(currentLoot.mesh.position) < 4) {
                    const currentItem = player.inventory[player.slot];
                    
                    if (player.isHealing) finishHealing();

                    // Try to stack consumables first
                    if (currentLoot.data.category === 'consumable') {
                        const stackSlot = player.inventory.find(item => item && item.name === currentLoot.data.name && item.count < item.maxStack);
                        if (stackSlot) {
                            stackSlot.count = Math.min(stackSlot.maxStack, stackSlot.count + currentLoot.data.count);
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            playSound('pickup_item');
                            return;
                        }
                    }

                    // Check if we can switch healing with healing
                    if (currentItem && currentItem.category === 'consumable' && 
                        currentLoot.data.category === 'consumable') {
                        // Direct swap
                        const temp = currentItem;
                        player.inventory[player.slot] = currentLoot.data;
                        spawnLoot(currentLoot.mesh.position.x, currentLoot.mesh.position.y, 
                                 currentLoot.mesh.position.z, temp);
                        scene.remove(currentLoot.mesh);
                        loot.splice(i, 1);
                        updateUI();
                        playSound('pickup_item');
                        return;
                    }

                    // Normal swap logic
                    if (currentItem) {
                        dropItem(player.slot, currentLoot.mesh.position.clone().add(new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2)));
                        giveItem(currentLoot.data, player.slot);
                        scene.remove(currentLoot.mesh);
                        loot.splice(i, 1);
                        updateUI();
                        playSound('pickup_item');
                        
                        if (currentLoot.data.rarity === RARITY_MULTIPLIERS.LEGENDARY || 
                            currentLoot.data.rarity === RARITY_MULTIPLIERS.MYTHIC) {
                            matchStats.legendariesHeld++;
                        }
                        return;
                    } else {
                        if(giveItem(currentLoot.data, player.slot)) {
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            playSound('pickup_item');
                            
                            if (currentLoot.data.rarity === RARITY_MULTIPLIERS.LEGENDARY || 
                                currentLoot.data.rarity === RARITY_MULTIPLIERS.MYTHIC) {
                                matchStats.legendariesHeld++;
                            }
                            return;
                        }
                    }
                }
            }
            
            // Check Resources
            for (let b of buildings) {
                if (b.type === 'tree' && pos.distanceTo(b.mesh.position) < 5) {
                    player.wood += 5;
                    updateUI();
                    
                    b.health -= 50; 
                    if (b.health <= 0) {
                        scene.remove(b.mesh);
                        objects = objects.filter(obj => obj !== b.mesh);
                        buildings = buildings.filter(bldg => bldg !== b);
                        playSound('explosion');
                    } else {
                        playSound('impact_hit');
                    }
                    return;
                }
            }
            
            // If no other interaction, try to use healing item
            useHealingItem();
        }
        
        function dropItem(slotIndex, position) {
            const itemToDrop = player.inventory[slotIndex];
            if (!itemToDrop) return;
            
            if (player.isHealing && player.healingItem === itemToDrop) {
                finishHealing();
            }

            spawnLoot(position.x, position.y + 1, position.z, itemToDrop);
            player.inventory[slotIndex] = null;
            playSound('pickup_item');
        }

        function createWeaponItem(typeKey, rarityKey) {
            const base = WEAPONS_BASE[typeKey];
            const rar = RARITY_MULTIPLIERS[rarityKey];
            
            let damageMultiplier = 1;
            if (typeKey === 'AUTO_SHG') damageMultiplier = 2.0;
            if (typeKey === 'STINGER') damageMultiplier = 1.25;
            if (typeKey === 'DUAL_SMG') damageMultiplier = 1.25;
            // Note: Sniper damage multiplier removed as per request to reduce damage by 33%
            
            // Apply level damage bonus
            damageMultiplier *= player.levelDamageMultiplier;
            
            return {
                category: 'weapon',
                name: base.name,
                rarity: rar,
                stats: { 
                    ...base, 
                    dmg: base.dmg * rar.dmg * damageMultiplier, 
                    head: base.head * rar.dmg * damageMultiplier, 
                    reload: base.reload * rar.reload, 
                    currentMag: base.mag 
                }, 
                maxAmmo: base.mag
            };
        }
        
        function getRandomRarity() {
            const rarityPool = ['COMMON', 'COMMON', 'UNCOMMON', 'UNCOMMON', 'RARE', 'EPIC', 'LEGENDARY'];
            return rarityPool[Math.floor(Math.random() * rarityPool.length)];
        }

        function getRandomWeaponKey() {
            const keys = Object.keys(WEAPONS_BASE).filter(k => k !== MYTHIC_WEAPON_KEY && k !== 'ROCKET_LAUNCHER');
            return keys[Math.floor(Math.random() * keys.length)];
        }

        function getRandomConsumableKey() {
            return CONSUMABLE_KEYS[Math.floor(Math.random() * CONSUMABLE_KEYS.length)];
        }

        function giveItem(itemData, slot) {
            if (itemData.category === 'weapon') {
                player.inventory[slot] = itemData;
            } else if (itemData.category === 'consumable') {
                const existing = player.inventory.find(i => i && i.name === itemData.name);
                if (existing) {
                    existing.count = Math.min(existing.maxStack, existing.count + itemData.count);
                } else if (player.inventory[slot] === null) {
                    player.inventory[slot] = itemData;
                } else {
                    return false; 
                }
            } else if (itemData === 'mythic') {
                const mythicWeapon = createWeaponItem(MYTHIC_WEAPON_KEY, 'MYTHIC');
                player.inventory[slot] = mythicWeapon;
            }
            return true;
        }

        function spawnLoot(x, y, z, type, rarity = null, weaponKey = null) {
            let item;
            if(type === 'weapon' || type === 'mythic') {
                const typeKey = type === 'mythic' ? MYTHIC_WEAPON_KEY : (weaponKey || getRandomWeaponKey());
                const rarityKey = type === 'mythic' ? 'MYTHIC' : (rarity || getRandomRarity());
                item = createWeaponItem(typeKey, rarityKey);
            } else if (type === 'consumable') {
                const consKey = rarity; 
                const base = CONSUMABLES[consKey];
                item = { category: 'consumable', ...base, count: 1 };
                item.rarity = RARITY_MULTIPLIERS[base.rarity]; 
            } else if (typeof type === 'object') {
                item = type; 
                if (item.category === 'consumable' && typeof item.rarity === 'string') {
                    item.rarity = RARITY_MULTIPLIERS[item.rarity];
                }
            } else {
                return;
            }

            let color = 0x808080;
            if (item.rarity && item.rarity.color) color = parseInt(item.rarity.color.substring(1), 16);
            else if (item.category === 'consumable') color = 0x00d2ff;

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({color: color}));
            mesh.position.set(x, y, z);
            scene.add(mesh);
            loot.push({ mesh: mesh, data: item });
        }

        // ===============================================================
        // === SHOOTING & DAMAGE SYSTEM ==================================
        // ===============================================================

        function shoot(item, isBurst = false) {
            if (item.stats.currentMag <= 0 || player.isReloading || player.isHealing) {
                if (!player.isReloading) reload();
                return;
            }
            
            if (player.isHealing) finishHealing();

            if (item.stats.burst && !isBurst) {
                if (player.isBursting) return;
                player.isBursting = true;
                player.burstCount = 0;
                
                const burstShot = () => {
                    if (player.burstCount < item.stats.burst && item.stats.currentMag > 0) {
                        doSingleShot(item);
                        player.burstCount++;
                        player.burstTimer = setTimeout(burstShot, 100); 
                    } else {
                        player.isBursting = false;
                        if (item.stats.currentMag > 0) {
                             player.burstTimer = setTimeout(() => {}, item.stats.burstDelay);
                        }
                    }
                };
                burstShot();
                return;
            } else if (item.stats.burst && isBurst) {
                doSingleShot(item);
                return;
            }
            
            doSingleShot(item);
        }
        
        function doSingleShot(item) {
            const fireOrigin = camera.position.clone();
            const fireDirection = new THREE.Vector3();
            camera.getWorldDirection(fireDirection);

            playSound('shoot');
            if (controllerConnected) vibrateController('shoot');
            
            createMuzzleFlash(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(1)), fireDirection);
            
            if (item.stats.bulletType === 'hitscan') {
                handleHitscan(item, fireOrigin, fireDirection, player);
            } else if (item.stats.bulletType === 'projectile') {
                handleProjectile(item, fireOrigin, fireDirection);
            }
            
            item.stats.currentMag -= 1;
            lastShot = performance.now();
            updateUI();
        }

        function handleHitscan(item, fireOrigin, fireDirection, shooter) {
            const spread = shooter === player ? (player.ads ? 0.005 : item.stats.spread) : item.stats.spread * 1.5;
            
            for(let p = 0; p < item.stats.pellets; p++) {
                
                const ray = new THREE.Raycaster(fireOrigin);
                const spreadDir = fireDirection.clone();
                
                const randomX = (Math.random() - 0.5) * spread;
                const randomY = (Math.random() - 0.5) * spread;
                spreadDir.x += randomX;
                spreadDir.y += randomY;
                spreadDir.normalize();

                if (shooter !== player && Math.random() < 0.5) {
                    spreadDir.x += (Math.random() - 0.5) * 0.3;
                    spreadDir.y += (Math.random() - 0.5) * 0.3;
                    spreadDir.normalize();
                }

                ray.ray.direction.copy(spreadDir);

                const targets = bots.map(b => b.mesh).concat(objects).concat(cars.map(c=>c.mesh));
                const hits = ray.intersectObjects(targets, true);
                
                if(hits.length > 0) {
                    const hit = hits[0];
                    let hitBot = null;
                    let hitPlayer = false;
                    let isHeadshot = false;

                    let obj = hit.object;
                    while(obj && obj.parent && obj.parent.type !== 'Scene') {
                        const b = bots.find(bot => bot.mesh === obj.parent);
                        if(b) { hitBot = b; break; }
                        obj = obj.parent;
                    }
                    if(!hitBot) hitBot = bots.find(bot => bot.mesh === hit.object);
                    
                    if (shooter !== player) {
                        const playerDist = hit.point.distanceTo(camera.position);
                        if (playerDist < 2 && hit.distance < item.stats.range) hitPlayer = true; 
                    }

                    createBulletTrail(fireOrigin, hit.point);
                    
                    if(hitBot && hitBot !== shooter) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > hitBot.mesh.position.y + 2.2) { 
                            dmg = item.stats.head; 
                            isHeadshot = true;
                        }
                        applyDamage(hitBot, dmg, hit.point, shooter, isHeadshot);
                        createImpactEffect(hit.point, isHeadshot);
                    } else if (hitPlayer) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > camera.position.y + 0.5) { 
                            dmg = item.stats.head; 
                        }
                        takeDamage(dmg, hit.point); 
                        createImpactEffect(hit.point, hit.point.y > camera.position.y + 0.5);
                        playSound('player_hit');
                        if (controllerConnected) vibrateController('hit');
                    } else {
                        const buildingHit = buildings.find(b => b.mesh === hit.object);
                        if (buildingHit) {
                            if (buildingHit.type !== 'indestructible_wood') {
                                buildingHit.health -= 50; 
                                if (buildingHit.health <= 0) {
                                    scene.remove(buildingHit.mesh);
                                    objects = objects.filter(obj => obj !== buildingHit.mesh);
                                    buildings = buildings.filter(bldg => bldg !== buildingHit);
                                }
                            }
                        }
                        createImpactEffect(hit.point, false);
                        playSound('impact_hit');
                    }
                } else {
                    const endPoint = fireOrigin.clone().add(spreadDir.clone().multiplyScalar(item.stats.range));
                    createBulletTrail(fireOrigin, endPoint);
                }
            }
        }
        
        function handleProjectile(item, fireOrigin, fireDirection) {
            const rocketGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const rocketMat = new THREE.MeshBasicMaterial({ color: 0xff4d4d });
            const rocketMesh = new THREE.Mesh(rocketGeo, rocketMat);
            rocketMesh.position.copy(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(1))); 
            scene.add(rocketMesh);
            
            projectiles.push({
                mesh: rocketMesh,
                velocity: fireDirection.clone().multiplyScalar(50), 
                damage: item.stats.explosionDamage,
                radius: item.stats.explosionRadius,
                shooter: player,
                isExpired: false
            });
        }
        
        function updateProjectiles(dt) {
            for(let i=projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (p.isExpired) continue;
                
                const oldPos = p.mesh.position.clone();
                p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                
                const collisionRay = new THREE.Raycaster(oldPos, p.velocity.clone().normalize(), 0, p.mesh.position.distanceTo(oldPos));
                const targets = bots.map(b => b.mesh).concat(objects).concat(cars.map(c=>c.mesh));
                const hits = collisionRay.intersectObjects(targets, true);

                if (hits.length > 0) {
                    const hit = hits[0];
                    explode(p, hit.point);
                    p.isExpired = true; 
                }

                if (Math.abs(p.mesh.position.x) > WORLD_SIZE / 2 || Math.abs(p.mesh.position.z) > WORLD_SIZE / 2) {
                    explode(p, p.mesh.position);
                    p.isExpired = true;
                }
            }
            
            projectiles = projectiles.filter(p => !p.isExpired);
        }

        function explode(projectile, hitPoint) {
            playSound('explosion');
            
            const explosionLight = new THREE.PointLight(0xff6600, 5, 20);
            explosionLight.position.copy(hitPoint);
            scene.add(explosionLight);
            
            const explosionParticles = new THREE.Group();
            for(let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 4, 4),
                    new THREE.MeshBasicMaterial({ color: 0xff6600 })
                );
                particle.position.copy(hitPoint);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 10
                );
                explosionParticles.add(particle);
                visualEffects.push({
                    mesh: particle,
                    velocity: velocity,
                    lifetime: 1,
                    age: 0
                });
            }
            scene.add(explosionParticles);
            
            setTimeout(() => {
                scene.remove(explosionLight);
                scene.remove(explosionParticles);
            }, 500);
            
            if (hitPoint.distanceTo(camera.position) < projectile.radius) {
                const dist = hitPoint.distanceTo(camera.position);
                const reduction = Math.max(0, dist / projectile.radius);
                const damage = projectile.damage * (1 - reduction);
                takeDamage(damage, hitPoint);
            }

            bots.forEach(bot => {
                if (hitPoint.distanceTo(bot.mesh.position) < projectile.radius) {
                    const dist = hitPoint.distanceTo(bot.mesh.position);
                    const reduction = Math.max(0, dist / projectile.radius);
                    const damage = projectile.damage * (1 - reduction);
                    applyDamage(bot, damage, bot.mesh.position, projectile.shooter, false);
                }
            });
            
            scene.remove(projectile.mesh);
        }
        
        function applyDamage(target, amount, hitPoint, source, isHeadshot = false, type = 'body') {
            amount = Math.round(amount);
            let remainingDmg = amount;

            if(target === player) {
                 takeDamage(amount, hitPoint, type); 
                 return;
            }

            if(target.shield > 0) {
                target.shield -= remainingDmg;
                if(target.shield < 0) { 
                    remainingDmg = -target.shield; 
                    target.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            } 
            
            if (remainingDmg > 0) {
                target.health -= remainingDmg;
            }
            
            showDamage(amount, hitPoint, type, isHeadshot);
            
            if(target.health <= 0) {
                if (bots.includes(target)) {
                    if (source === player) player.eliminations += 1;
                    scene.remove(target.mesh);
                    bots = bots.filter(b => b !== target);
                    
                    const randomWeaponKey = getRandomWeaponKey();
                    const randomRarity = getRandomRarity(); 
                    const botWeapon = createWeaponItem(randomWeaponKey, randomRarity);
                    
                    const dropConsumableKey = getRandomConsumableKey();
                    const consumableBase = CONSUMABLES[dropConsumableKey];
                    const healingItemDrop = { 
                        category: 'consumable', 
                        ...CONSUMABLES[dropConsumableKey], 
                        count: 1, 
                        rarity: consumableBase.rarity 
                    };
                    
                    spawnLoot(hitPoint.x + 1, hitPoint.y, hitPoint.z, botWeapon); 
                    spawnLoot(hitPoint.x - 1, hitPoint.y, hitPoint.z, healingItemDrop); 
                    player.wood += 50; 
                    
                    playSound('elimination');
                    updateAliveCount(); // FIXED: Update alive count when bot dies
                    checkWin();
                }
            }
        }
        
        function takeDamage(amount, sourcePoint, type = 'body') {
            amount = Math.floor(amount);
            if (amount <= 0 || player.dead) return;
            
            // Play hit sound
            playSound('player_hit');
            
            let remainingDmg = amount;
            
            const overshieldBefore = player.overshield;
            
            if(player.overshield > 0) {
                player.overshield -= remainingDmg;
                if(player.overshield < 0) { 
                    remainingDmg = -player.overshield; 
                    player.overshield = 0; 
                    
                    if (overshieldBefore > 0) {
                        player.lastOvershieldBreak = performance.now();
                    }
                } else {
                    remainingDmg = 0;
                }
                player.lastOvershieldDamage = performance.now();
            }

            if (remainingDmg > 0 && player.shield > 0) {
                player.shield -= remainingDmg;
                if(player.shield < 0) { 
                    remainingDmg = -player.shield; 
                    player.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            }
            
            if (remainingDmg > 0) {
                player.health -= remainingDmg;
            }
            
            showDamage(amount, camera.position.clone().setY(camera.position.y - 0.5), type); 
            updateUI();
            
            if(player.health <= 0) {
                player.dead = true;
                handleGameOver(false);
            }
        }

        // FIXED: Overshield regeneration system
        function overshieldRegen(dt) {
             if (player.dead || player.overshield === OVER_SHIELD_MAX) return;

             const timeSinceDamage = performance.now() - player.lastOvershieldDamage;
             const timeSinceBreak = performance.now() - player.lastOvershieldBreak;
             
             if (timeSinceDamage >= OVER_SHIELD_REGEN_DELAY && timeSinceBreak >= OVER_SHIELD_REGEN_DELAY) {
                 player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + (OVER_SHIELD_REGEN_RATE * dt));
                 updateUI();
             }
        }

        // ===============================================================
        // === VEHICLE LOGIC =============================================
        // ===============================================================

        function updateCars(dt) {
            for(const car of cars) {
                if(car.driving) {
                    const speed = inputs.w ? 15 : inputs.s ? -5 : 0;
                    car.speed = THREE.MathUtils.lerp(car.speed, speed, 0.1);

                    if (inputs.a || inputs.d) {
                        const rotationSpeed = dt * 1.5 * (inputs.d ? -1 : 1);
                        car.mesh.rotation.y += rotationSpeed * Math.sign(car.speed || 1);
                    }
                    
                    car.mesh.translateZ(car.speed * dt);
                    
                    if (Math.abs(car.speed) > 5) {
                        const currentPos = car.mesh.position;
                        
                        bots.forEach(bot => {
                            if (currentPos.distanceTo(bot.mesh.position) < 3) {
                                applyDamage(bot, 100, bot.mesh.position, player);
                            }
                        });
                    }

                    const h = getEnhancedTerrainHeight(car.mesh.position.x, car.mesh.position.z);
                    car.mesh.position.y = h;

                    if(player.vehicle === car) {
                        camera.position.copy(car.mesh.position).add(new THREE.Vector3(0, PLAYER_HEIGHT + 1, 0));
                    }
                }
            }
        }

        // ===============================================================
        // === REDESIGNED UI FUNCTIONS ===================================
        // ===============================================================
        
        function updateUI() {
            player.health = Math.max(0, Math.min(100, player.health));
            player.shield = Math.max(0, Math.min(100 + player.levelShieldBonus, player.shield));
            player.overshield = Math.max(0, Math.min(OVER_SHIELD_MAX, player.overshield));
            
            document.getElementById('health-value').innerText = Math.ceil(player.health);
            document.getElementById('shield-value').innerText = Math.ceil(player.shield);
            document.getElementById('overshield-value').innerText = Math.ceil(player.overshield);
            document.getElementById('wood-value').innerText = player.wood;
            
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('shield-bar').style.width = (player.shield / (100 + player.levelShieldBonus)) * 100 + '%';
            document.getElementById('overshield-bar').style.width = (player.overshield / OVER_SHIELD_MAX) * 100 + '%';
            
            player.inventory.forEach((item, i) => {
                const slot = document.getElementById(`slot-${i}`);
                slot.innerHTML = '';
                
                if(item) {
                    const icon = item.category === 'weapon' ? item.stats.icon : item.icon;
                    const name = item.name; 
                    const count = item.category === 'consumable' ? item.count : '';
                    
                    slot.innerHTML = `
                        <div class="slot-key">${i+1}</div>
                        <div class="slot-icon">${icon}</div>
                        <div class="slot-name">${name}</div>
                        ${count ? `<div class="slot-count">${count}</div>` : ''}
                    `;
                    
                    let rarityKey = '';
                    if (item.rarity && item.rarity.color) {
                        const rarityEntry = Object.entries(RARITY_MULTIPLIERS).find(([, value]) => value === item.rarity);
                        if (rarityEntry) {
                            rarityKey = rarityEntry[0].toLowerCase(); 
                        } else if (typeof item.rarity === 'string') {
                            rarityKey = item.rarity.toLowerCase();
                        }
                    }
                    
                    slot.className = `inventory-slot ${i===player.slot ? 'active' : ''} rarity-${rarityKey}`;
                } else {
                    slot.className = `inventory-slot ${i===player.slot ? 'active' : ''}`;
                    slot.innerHTML = `<div class="slot-key">${i+1}</div>`;
                }
            });
            
            let msg = "Interact (E)";
            const pos = camera.position;
            const nearestChest = chests.some(c => pos.distanceTo(c.position) < 6);
            const nearestLoot = loot.some(l => pos.distanceTo(l.mesh.position) < 4);
            const nearestDoor = doors.some(d => pos.distanceTo(d.mesh.position) < 5);
            const nearestCar = cars.some(c => pos.distanceTo(c.mesh.position) < 5);

            const showInteract = nearestChest || nearestLoot || nearestDoor || nearestCar || player.vehicle;
            
            if (!showInteract) {
                const currentItem = player.inventory[player.slot];
                if (currentItem && currentItem.category === 'consumable' && currentItem.count > 0 && 
                    ((currentItem.type === 'shield' && (player.shield < 100 || player.overshield < OVER_SHIELD_MAX)) || (currentItem.type === 'health' && player.health < 100) || currentItem.type === 'continuous')) {
                     msg = player.isHealing ? `Cancel Healing (E)` : `Use ${currentItem.name} (E)`;
                     document.getElementById('interact-prompt').style.display = 'block';
                } else {
                    document.getElementById('interact-prompt').style.display = 'none';
                }
            } else {
                 if (player.vehicle) msg = "Exit Vehicle (E)";
                 else if (nearestChest) msg = "Open Chest (E)";
                 else if (nearestLoot) msg = "Pickup/Swap (E)";
                 else if (nearestDoor) msg = "Open Door (E)";
                 else if (nearestCar) msg = "Enter Vehicle (E)";
                 document.getElementById('interact-prompt').style.display = 'block';
            }
            
            document.getElementById('interact-prompt').innerText = msg;
            
            const item = player.inventory[player.slot];
            const isWeapon = item && item.category === 'weapon';
            const showReload = isWeapon && item.stats.currentMag < item.stats.mag;
            document.getElementById('btn-reload').style.display = gameMode === 'mobile' && isWeapon && showReload && !player.isReloading ? 'flex' : 'none';
        }
        
        function switchSlot(idx) {
            if (player.isHealing) {
                const currentHealingSlot = player.inventory.findIndex(i => i === player.healingItem);
                if (currentHealingSlot === player.slot && !player.healingItem.continuous) {
                    finishHealing();
                } else if (currentHealingSlot !== player.slot) {
                    finishHealing();
                }
            }

            if(idx < 0 || idx > 4) return;
            player.slot = idx;
            
            document.querySelectorAll('.inventory-slot').forEach((el, i) => {
                el.classList.toggle('active', i === idx);
            });
            
            if(viewModel) weaponScene.remove(viewModel);
            const item = player.inventory[idx];
            
            if(item && item.category === 'weapon') {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
                const color = item.rarity && item.rarity.color ? item.rarity.color : '#FFFFFF'; 
                const mat = new THREE.MeshStandardMaterial({ color: color });
                viewModel = new THREE.Mesh(geo, mat);
                viewModel.position.set(0.2, -0.2, -0.5);
                weaponScene.add(viewModel);
                
                toggleADS(player.ads); 
            } else {
                document.getElementById('crosshair').style.display = 'block';
                toggleADS(false);
            }
            
            updateUI(); 
        }
        
        function selectSlotMobile(idx) {
            if (gameMode === 'mobile') {
                switchSlot(idx);
            }
        }

        // ===============================================================
        // === IMPROVED INPUT & CONTROL MANAGEMENT (V19.8) ===============
        // ===============================================================
        
        function setGameMode(mode) {
            gameMode = mode;
            const mobileControls = document.getElementById('mobile-controls');
            const gameContainer = document.getElementById('game-container');
            const controllerLayout = document.getElementById('controller-layout');

            if (mode === 'mobile') {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'block';
                controllerLayout.style.display = 'none';
                gameContainer.removeEventListener('mousedown', lockPointer);
                
                initMobileControls();
            } else if (mode === 'controller') {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'none';
                controllerLayout.style.display = 'none';
                gameContainer.removeEventListener('mousedown', lockPointer);
            } else {
                if (controls) controls.enabled = true;
                mobileControls.style.display = 'none';
                controllerLayout.style.display = 'none';
                gameContainer.addEventListener('mousedown', lockPointer);
            }
        }
        
        function lockPointer() {
            if (controls && gameMode === 'desktop') {
                controls.lock();
                inputs.fire = false; 
            }
        }

        function setupPCLock() {
            if (controls) controls.enabled = true;
            document.getElementById('game-container').addEventListener('mousedown', lockPointer);
        }

        // IMPROVED: Mobile controls with simultaneous movement and camera control
        function initMobileControls() {
            const touchLeft = document.getElementById('touch-left');
            const touchRight = document.getElementById('touch-right');
            const joystickThumb = document.getElementById('joystick-thumb');
            const movementZone = document.getElementById('movement-zone');
            
            // IMPROVED: Movement joystick (left 40% of screen)
            let isTouchingLeft = false;
            let leftTouchId = null;
            
            touchLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for(let touch of e.changedTouches) {
                    if(leftTouchId === null) {
                        leftTouchId = touch.identifier;
                        isTouchingLeft = true;
                        joystickActive = true;
                        
                        const rect = movementZone.getBoundingClientRect();
                        joystickOrigin.x = rect.left + rect.width / 2;
                        joystickOrigin.y = rect.top + rect.height / 2;
                        
                        // Position joystick at touch start
                        joystickOffset.x = touch.clientX - joystickOrigin.x;
                        joystickOffset.y = touch.clientY - joystickOrigin.y;
                        
                        const maxDist = 75;
                        const dist = Math.sqrt(joystickOffset.x*joystickOffset.x + joystickOffset.y*joystickOffset.y);
                        if(dist > maxDist) {
                            const ratio = maxDist / dist;
                            joystickOffset.x *= ratio;
                            joystickOffset.y *= ratio;
                        }
                        
                        joystickThumb.style.transform = `translate(${joystickOffset.x}px, ${joystickOffset.y}px)`;
                        
                        // Set movement inputs
                        const deadZone = 20;
                        inputs.w = joystickOffset.y < -deadZone;
                        inputs.s = joystickOffset.y > deadZone;
                        inputs.a = joystickOffset.x < -deadZone;
                        inputs.d = joystickOffset.x > deadZone;
                        inputs.sprint = dist > 50;
                        break;
                    }
                }
            });
            
            touchLeft.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let touch of e.changedTouches) {
                    if(touch.identifier === leftTouchId) {
                        joystickOffset.x = touch.clientX - joystickOrigin.x;
                        joystickOffset.y = touch.clientY - joystickOrigin.y;
                        
                        const maxDist = 75;
                        const dist = Math.sqrt(joystickOffset.x*joystickOffset.x + joystickOffset.y*joystickOffset.y);
                        if(dist > maxDist) {
                            const ratio = maxDist / dist;
                            joystickOffset.x *= ratio;
                            joystickOffset.y *= ratio;
                        }
                        
                        joystickThumb.style.transform = `translate(${joystickOffset.x}px, ${joystickOffset.y}px)`;
                        
                        const deadZone = 20;
                        inputs.w = joystickOffset.y < -deadZone;
                        inputs.s = joystickOffset.y > deadZone;
                        inputs.a = joystickOffset.x < -deadZone;
                        inputs.d = joystickOffset.x > deadZone;
                        inputs.sprint = dist > 50;
                        break;
                    }
                }
            });
            
            touchLeft.addEventListener('touchend', (e) => {
                for(let touch of e.changedTouches) {
                    if(touch.identifier === leftTouchId) {
                        leftTouchId = null;
                        isTouchingLeft = false;
                        joystickActive = false;
                        joystickThumb.style.transform = `translate(-50%, -50%)`;
                        inputs.w = inputs.s = inputs.a = inputs.d = inputs.sprint = false;
                        break;
                    }
                }
            });
            
            // IMPROVED: Camera control (right 60% of screen) - Better responsiveness
            let rightTouchId = null;
            let isTouchingRight = false;
            let lastRightTouch = { x: 0, y: 0 };
            
            touchRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for(let touch of e.changedTouches) {
                    if(rightTouchId === null) {
                        rightTouchId = touch.identifier;
                        isTouchingRight = true;
                        lastRightTouch.x = touch.clientX;
                        lastRightTouch.y = touch.clientY;
                        touchDeltaX = 0;
                        touchDeltaY = 0;
                        break;
                    }
                }
            });
            
            touchRight.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let touch of e.changedTouches) {
                    if(touch.identifier === rightTouchId) {
                        const deltaX = touch.clientX - lastRightTouch.x;
                        const deltaY = touch.clientY - lastRightTouch.y;
                        
                        // IMPROVED: Increased sensitivity with less smoothing for better control
                        touchDeltaX = deltaX * MOBILE_SENSITIVITY;
                        touchDeltaY = deltaY * MOBILE_SENSITIVITY;
                        
                        // Apply rotation immediately
                        camera.rotation.y -= touchDeltaX;
                        camera.rotation.x -= touchDeltaY;
                        
                        camera.rotation.x = Math.max(-MAX_CAMERA_ANGLE, Math.min(MAX_CAMERA_ANGLE, camera.rotation.x));
                        
                        lastRightTouch.x = touch.clientX;
                        lastRightTouch.y = touch.clientY;
                        break;
                    }
                }
            });
            
            touchRight.addEventListener('touchend', (e) => {
                for(let touch of e.changedTouches) {
                    if(touch.identifier === rightTouchId) {
                        rightTouchId = null;
                        isTouchingRight = false;
                        touchDeltaX = 0;
                        touchDeltaY = 0;
                        break;
                    }
                }
            });
            
            // Mobile button handlers
            const setupButton = (id, action) => {
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => { 
                    e.preventDefault(); 
                    action(true);
                });
                btn.addEventListener('touchend', (e) => { 
                    e.preventDefault(); 
                    action(false);
                });
                btn.addEventListener('touchcancel', (e) => { 
                    e.preventDefault(); 
                    action(false);
                });
            };
            
            setupButton('btn-fire', (state) => { inputs.fire = state; });
            setupButton('btn-jump', (state) => { inputs.jump = state; });
            setupButton('btn-ads', (state) => { toggleADS(state); });
            
            document.getElementById('btn-interact').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                tryInteract(); 
            });
            
            document.getElementById('btn-build').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                buildWall(); 
            });
            
            document.getElementById('btn-reload').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                reload(); 
            });
        }

        // Controller input handling
        function setupControllerInputs() {
            window.addEventListener("gamepadconnected", (e) => {
                console.log("Gamepad connected:", e.gamepad);
                gamepad = e.gamepad;
                controllerConnected = true;
                showControllerNotification();
                vibrateController('medium');
            });

            window.addEventListener("gamepaddisconnected", (e) => {
                console.log("Gamepad disconnected:", e.gamepad);
                gamepad = null;
                controllerConnected = false;
            });

            // Poll gamepad state
            function updateControllerState() {
                if (!controllerConnected || !gamepad) return;
                
                const gp = navigator.getGamepads()[gamepad.index];
                if (!gp) return;
                
                controllerMapping.leftStick.x = gp.axes[0];
                controllerMapping.leftStick.y = gp.axes[1];
                controllerMapping.rightStick.x = gp.axes[2];
                controllerMapping.rightStick.y = gp.axes[3];
                
                controllerMapping.buttons.l1 = gp.buttons[4].pressed;
                controllerMapping.buttons.r1 = gp.buttons[5].pressed;
                controllerMapping.buttons.l2 = gp.buttons[6].value;
                controllerMapping.buttons.r2 = gp.buttons[7].value;
                controllerMapping.buttons.y = gp.buttons[3].pressed;
                controllerMapping.buttons.b = gp.buttons[1].pressed;
                controllerMapping.buttons.a = gp.buttons[0].pressed;
                controllerMapping.buttons.x = gp.buttons[2].pressed;
                
                controllerMapping.buttons.dpadUp = gp.buttons[12].pressed;
                controllerMapping.buttons.dpadDown = gp.buttons[13].pressed;
                controllerMapping.buttons.dpadLeft = gp.buttons[14].pressed;
                controllerMapping.buttons.dpadRight = gp.buttons[15].pressed;
                
                if (gameMode === 'controller') {
                    inputs.w = controllerMapping.leftStick.y < -0.3;
                    inputs.s = controllerMapping.leftStick.y > 0.3;
                    inputs.a = controllerMapping.leftStick.x < -0.3;
                    inputs.d = controllerMapping.leftStick.x > 0.3;
                    
                    inputs.sprint = controllerMapping.buttons.a;
                    
                    if (Math.abs(controllerMapping.rightStick.x) > 0.1 || Math.abs(controllerMapping.rightStick.y) > 0.1) {
                        camera.rotation.y -= controllerMapping.rightStick.x * CONTROLLER_SENSITIVITY;
                        camera.rotation.x -= controllerMapping.rightStick.y * CONTROLLER_SENSITIVITY;
                        camera.rotation.x = Math.max(-MAX_CAMERA_ANGLE, Math.min(MAX_CAMERA_ANGLE, camera.rotation.x));
                    }
                    
                    if (controllerMapping.buttons.b && !inputs.jump) {
                        inputs.jump = true;
                        setTimeout(() => inputs.jump = false, 100);
                        vibrateController('jump');
                    }
                    
                    if (controllerMapping.buttons.y && !inputs.reload) {
                        inputs.reload = true;
                        setTimeout(() => inputs.reload = false, 100);
                    }
                    
                    if (controllerMapping.buttons.x && !inputs.use) {
                        inputs.use = true;
                        setTimeout(() => inputs.use = false, 100);
                        tryInteract();
                    }
                    
                    if (controllerMapping.buttons.l2 > 0.5) {
                        toggleADS(true);
                    } else if (player.ads) {
                        toggleADS(false);
                    }
                    
                    if (controllerMapping.buttons.r2 > 0.5) {
                        inputs.fire = true;
                    } else {
                        inputs.fire = false;
                    }
                    
                    if (controllerMapping.buttons.dpadLeft || controllerMapping.buttons.l1) {
                        const newSlot = (player.slot - 1 + 5) % 5;
                        switchSlot(newSlot);
                        vibrateController('light');
                    }
                    if (controllerMapping.buttons.dpadRight || controllerMapping.buttons.r1) {
                        const newSlot = (player.slot + 1) % 5;
                        switchSlot(newSlot);
                        vibrateController('light');
                    }
                }
            }
            
            setInterval(updateControllerState, 16);
        }

        function setupInputs() {
            const gameContainer = document.getElementById('game-container');
            
            // PC Keyboard Controls
            const onKey = (e, v) => {
                if (gameMode === 'desktop' && controls && controls.isLocked) {
                    if(e.code === 'KeyW') inputs.w = v;
                    if(e.code === 'KeyS') inputs.s = v;
                    if(e.code === 'KeyA') inputs.a = v;
                    if(e.code === 'KeyD') inputs.d = v;
                    if(e.code === 'ShiftLeft') inputs.sprint = v;
                    
                    if(e.code === 'Space' && v) inputs.jump = true; 
                    if(e.code === 'KeyR' && v) inputs.reload = true; 
                    if(e.code === 'KeyX' && v) useHealingItem();
                }
            };
            
            document.addEventListener('keydown', e => {
                onKey(e, true);
                if(gameMode === 'desktop' && controls && controls.isLocked) {
                    if(e.code === 'Digit1') switchSlot(0);
                    if(e.code === 'Digit2') switchSlot(1);
                    if(e.code === 'Digit3') switchSlot(2);
                    if(e.code === 'Digit4') switchSlot(3);
                    if(e.code === 'Digit5') switchSlot(4);
                    if(e.code === 'KeyE') tryInteract();
                    if(e.code === 'KeyB') buildWall(); 
                }
            });
            
            document.addEventListener('keyup', e => onKey(e, false));
            
            // PC Mouse Controls
            document.addEventListener('mousedown', e => {
                if(player.dead || gameMode !== 'desktop' || !controls || !controls.isLocked) return;
                if(e.button === 0) inputs.fire = true;
                if(e.button === 2) toggleADS(true);
            });
            
            document.addEventListener('mouseup', e => {
                if(player.dead || gameMode !== 'desktop') return;
                if(e.button === 0) inputs.fire = false;
                if(e.button === 2) toggleADS(false);
            });
            
            document.addEventListener('contextmenu', e => e.preventDefault());
        }

        // ===============================================================
        // === INITIALIZATION & START GAME ===============================
        // ===============================================================

        function init() {
            victoryRoyales = parseInt(localStorage.getItem('victoryRoyales')) || 0;
            document.getElementById('victory-royales-stat').innerText = `ðŸ† Victory Royales: ${victoryRoyales}`;
            
            loadPlayerLevel();
            createParticles();
            initAudio();
            setupControllerInputs();
            
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false; 
            const gameContainer = document.getElementById('game-container');
            gameContainer.appendChild(renderer.domElement);
            
            // Lighting & IMPROVED Day/Night Cycle
            initDayNightCycle();
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            
            weaponScene.add(ambient.clone());
            
            // Controls
            controls = new PointerLockControls(camera, document.body);
            setupInputs(); 

            // Raycasters
            raycaster = new THREE.Raycaster();
            downRay = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, PLAYER_HEIGHT + 0.1);
            
            animate();
        }
        
        function createParticles() {
            const container = document.getElementById('particles-container');
            for(let i = 0; i < 40; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = `${Math.random() * 15 + 5}px`;
                particle.style.height = particle.style.width;
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 20}s`;
                particle.style.animationDuration = `${Math.random() * 10 + 15}s`;
                container.appendChild(particle);
            }
        }

        window.startGame = (mode) => {
            document.getElementById('start-screen').style.display = 'none';
            gameStarted = true;
            
            setGameMode(mode);
            
            if (mode === 'desktop') {
                setupPCLock(); 
            }
            
            // Reset match stats
            matchStats = {
                kills: 0,
                placement: 0,
                chestsOpened: 0,
                legendariesHeld: 0,
                totalPoints: 0
            };
            
            // Player stats with level bonuses
            player.health = 100;
            player.shield = 100 + player.levelShieldBonus;
            player.overshield = 50;
            player.wood = 0;
            player.inventory = [null, null, null, null, null];
            player.slot = 0;
            player.eliminations = 0;
            player.dead = false;
            
            generateTerrain(); 
            generatePOIs(); 
            spawnBots();
            spawnCars();

            camera.position.set(0, getEnhancedTerrainHeight(0, 0) + PLAYER_HEIGHT + 2, 0);
            
            startStormTimer(); 
            switchSlot(0);
            
            updateUI();
            updateAliveCount(); // Initialize alive count
        };

        // ===============================================================
        // === CORE GAME LOOP ============================================
        // ===============================================================

        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            if(!gameStarted || player.dead) {
                renderer.clear();
                renderer.render(scene, camera);
                return;
            }

            if (player.isHealing && player.healingItem) {
                if (player.healingItem.continuous) {
                    applyContinuousHealing(player.healingItem, dt);
                } else if (!player.healingItem.instant) {
                    inputs.fire = false;
                    inputs.w = inputs.a = inputs.s = inputs.d = false;
                }
            }
            
            // FIXED: Overshield regeneration
            overshieldRegen(dt);
            
            // Update IMPROVED day/night cycle
            updateDayNightCycle(dt);

            if(player.vehicle) {
                updateCars(dt);
            } else {
                const canMove = gameMode === 'mobile' || gameMode === 'controller' || (controls && controls.isLocked); 
                if (canMove) {
                    const speedMultiplier = player.ads ? 0.5 : 1.0; 
                    const currentSpeed = (inputs.sprint ? SPRINT_SPEED : WALK_SPEED) * speedMultiplier * player.levelSpeedMultiplier;
                    
                    const direction = new THREE.Vector3();
                    direction.setFromMatrixColumn(camera.matrix, 0); 
                    direction.crossVectors(camera.up, direction);
                    direction.y = 0;
                    direction.normalize();
                    
                    const right = new THREE.Vector3(-direction.z, 0, direction.x);

                    const yVelocity = velocity.y; 
                    velocity.set(0, yVelocity, 0); 

                    if(inputs.w) velocity.add(direction.clone().multiplyScalar(currentSpeed));
                    if(inputs.s) velocity.add(direction.clone().multiplyScalar(-currentSpeed));
                    if(inputs.a) velocity.add(right.clone().multiplyScalar(-currentSpeed));
                    if(inputs.d) velocity.add(right.clone().multiplyScalar(currentSpeed));
                    
                    camera.position.x += velocity.x * dt;
                    camera.position.z += velocity.z * dt;
                    velocity.y -= GRAVITY * dt; 
                    
                    const groundY = getEnhancedTerrainHeight(camera.position.x, camera.position.z);
                    let floorY = groundY;
                    
                    downRay.ray.origin.copy(camera.position);
                    const hits = downRay.intersectObjects(objects.filter(obj => !doors.map(d=>d.mesh).includes(obj) && !buildings.some(b => b.mesh === obj && b.type === 'indestructible_wood')), false); 
                    
                    if(hits.length > 0) {
                        const closestHit = hits[0];
                        if (closestHit.point.y > groundY + 0.1) { 
                            floorY = closestHit.point.y;
                        }
                    }
                    
                    if (camera.position.y <= floorY + PLAYER_HEIGHT && velocity.y <= 0) {
                        camera.position.y = floorY + PLAYER_HEIGHT;
                        velocity.y = 0;
                        isGrounded = true;
                    } else {
                        isGrounded = false;
                    }
                    
                    if(inputs.jump && isGrounded) {
                        velocity.y = JUMP_FORCE;
                        isGrounded = false;
                        inputs.jump = false; 
                        playSound('jump');
                    }
                    
                    camera.position.y += velocity.y * dt;
                } else {
                    velocity.x = 0; 
                    velocity.z = 0;
                }
            }

            const canFire = gameMode === 'mobile' || gameMode === 'controller' || (controls && controls.isLocked); 
            if(inputs.fire && !player.vehicle && !player.isHealing && canFire) {
                const item = player.inventory[player.slot];
                if(item && item.category === 'weapon') {
                    if (item.stats.burst) {
                        if (now - lastShot > item.stats.burstDelay) {
                            shoot(item);
                        }
                    } else if(now - lastShot > item.stats.rate * 1000) {
                        shoot(item);
                    }
                }
            } else if (inputs.reload) {
                reload();
                inputs.reload = false;
            }
            
            updateProjectiles(dt);
            updateEnhancedBots(dt, now);
            updateStorm(now);
            updateVisualEffects(dt);
            optimizePerformance();

            renderer.clear();
            renderer.render(scene, camera);
            renderer.clearDepth();
            renderer.render(weaponScene, weaponCamera);
            
            updateUI();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            weaponCamera.aspect = window.innerWidth / window.innerHeight;
            weaponCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.selectSlot = switchSlot;
        window.selectSlotMobile = selectSlotMobile;
        
        init();
    </script>
</body>
</html>
