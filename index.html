<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Battle Royale: V19.8 - Solar Edition</title>
    <style>
        /* ======================================= */
        /* === V19.8 SOLAR UI REDESIGN === */
        /* ======================================= */
        
        * {
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Poppins', 'Verdana', sans-serif; 
            user-select: none; 
            background: #000;
            touch-action: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            color: white;
        }

        /* --- PRE-GAME START SCREEN (V19.8 Solar Design) --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #000428 0%, #004e92 50%, #000428 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 1000;
            text-align: center;
            animation: fadeIn 0.8s ease-out;
            overflow: hidden;
        }
        
        /* Solar flare background */
        .solar-flare {
            position: absolute;
            width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, 
                rgba(255, 200, 0, 0.3) 0%,
                rgba(255, 100, 0, 0.2) 20%,
                rgba(0, 78, 146, 0.1) 40%,
                transparent 70%);
            animation: solarPulse 4s infinite alternate;
        }
        
        @keyframes solarPulse {
            0% { opacity: 0.3; transform: scale(1); }
            100% { opacity: 0.7; transform: scale(1.1); }
        }

        #start-screen h1 { 
            font-size: 5.5rem; 
            margin-bottom: 1rem; 
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 50%, #ff4500 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            letter-spacing: 3px;
            animation: solarGlow 3s infinite alternate;
            position: relative;
            z-index: 2;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
        }
        
        @keyframes solarGlow {
            0% { text-shadow: 0 0 30px rgba(255, 215, 0, 0.5), 0 0 60px rgba(255, 140, 0, 0.3); }
            100% { text-shadow: 0 0 60px rgba(255, 215, 0, 0.8), 0 0 120px rgba(255, 69, 0, 0.5); }
        }
        
        #start-screen h1::after {
            content: 'V19.8 â€¢ SOLAR EDITION';
            display: block;
            font-size: 1.8rem;
            color: #00ffff;
            margin-top: 0.5rem;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            animation: cyanPulse 3s infinite alternate;
        }
        
        @keyframes cyanPulse {
            0% { opacity: 0.7; text-shadow: 0 0 20px rgba(0, 255, 255, 0.7); }
            100% { opacity: 1; text-shadow: 0 0 40px rgba(0, 255, 255, 1), 0 0 80px rgba(0, 255, 255, 0.6); }
        }

        #start-screen .subtitle { 
            font-size: 1.5rem; 
            margin-bottom: 3rem; 
            color: rgba(255,255,255,0.9);
            animation: fadeIn 1s ease-out 0.5s backwards;
            position: relative;
            z-index: 2;
            font-weight: 300;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
            z-index: 2;
            animation: scaleIn 0.8s ease-out 0.8s backwards;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        
        .game-button {
            padding: 1.3rem 2.8rem; 
            margin: 0; 
            font-size: 1.4rem;
            background: linear-gradient(135deg, #ff8c00, #ff4500);
            color: white; 
            border: none; 
            border-radius: 20px; 
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Poppins', sans-serif; 
            font-weight: 700;
            box-shadow: 
                0 15px 40px rgba(255, 69, 0, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.3);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            backdrop-filter: blur(15px);
            border: 3px solid rgba(255,255,255,0.2);
        }
        
        .game-button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.6s;
        }
        
        .game-button:hover::before {
            left: 100%;
        }
        
        .game-button:hover { 
            transform: translateY(-5px) scale(1.05);
            box-shadow: 
                0 20px 50px rgba(255, 69, 0, 0.8),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 40px rgba(255, 69, 0, 0.6);
        }
        
        .game-button:active { 
            transform: scale(0.95) translateY(0); 
            box-shadow: 0 10px 30px rgba(255, 69, 0, 0.4);
            transition: transform 0.1s;
        }
        
        .game-button.mobile { 
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            box-shadow: 0 15px 40px rgba(0, 212, 255, 0.6);
        }
        
        .game-button.mobile:hover { 
            background: linear-gradient(135deg, #00b8ff, #0077ff); 
        }
        
        .game-button.controller { 
            background: linear-gradient(135deg, #9d4edd, #560bad);
            box-shadow: 0 15px 40px rgba(157, 78, 221, 0.6);
        }
        
        .game-button.controller:hover { 
            background: linear-gradient(135deg, #7b2cbf, #3c096c); 
        }
        
        /* === NEW: REORGANIZED LEVEL STATS === */
        #level-stats {
            position: absolute; 
            bottom: 2rem; 
            left: 2rem;
            font-size: 1.1rem;
            color: #ffd700; 
            font-weight: 600;
            background: rgba(0,0,0,0.8);
            padding: 1rem 1.5rem;
            border-radius: 15px;
            border: 3px solid rgba(255, 215, 0, 0.4);
            z-index: 2;
            animation: fadeIn 1s ease-out 1.5s backwards;
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
            min-width: 250px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .level-display {
            font-size: 1.5rem;
            color: #ff8c00;
            text-shadow: 0 0 15px rgba(255, 140, 0, 0.7);
            font-weight: 800;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.15);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 0.3rem;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff8c00, #ff4500);
            transition: width 0.5s ease;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(255, 140, 0, 0.5);
        }
        
        .progress-text {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.9);
            margin-top: 0.3rem;
        }
        
        #points-to-next {
            font-size: 0.8rem;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }

        /* === ENHANCED CROSSHAIR === */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 36px; height: 36px; 
            transform: translate(-50%, -50%); 
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.95;
            z-index: 10;
            pointer-events: none;
            filter: drop-shadow(0 0 10px rgba(255, 77, 77, 0.9));
        }
        
        .crosshair-dot {
            position: absolute;
            width: 7px; height: 7px;
            background: #ff4d4d;
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 15px #ff4d4d,
                0 0 30px rgba(255, 77, 77, 0.8);
            animation: crosshairPulse 2s infinite alternate;
        }
        
        @keyframes crosshairPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            100% { transform: translate(-50%, -50%) scale(1.2); }
        }
        
        .crosshair-line {
            position: absolute;
            background: #ff4d4d;
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 77, 77, 1);
        }
        
        .ch-h { 
            width: 100%; height: 4px; 
            top: 50%; left: 0; 
            margin-top: -2px; 
        }
        
        .ch-v { 
            height: 100%; width: 4px; 
            left: 50%; top: 0; 
            margin-left: -2px; 
        }

        /* === ENHANCED SCOPES === */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 18%, rgba(0, 0, 0, 0.98) 19%, black 100%);
            display: none; pointer-events: none; z-index: 100; 
        }
        
        #scope-lines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(to right, rgba(255,255,255,0.15) 1px, transparent 1px) 0 0 / 20px 20px,
                linear-gradient(to bottom, rgba(255,255,255,0.15) 1px, transparent 1px) 0 0 / 20px 20px;
            opacity: 0.7;
        }
        
        #red-dot-scope {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none;
            pointer-events: none;
            background: radial-gradient(circle, transparent 45%, rgba(0,0,0,0.85) 46%, rgba(0,0,0,0.95) 100%);
        }
        
        .red-dot {
            width: 9px; height: 9px; border-radius: 50%;
            background: #ff0000; 
            box-shadow: 
                0 0 25px #ff0000,
                0 0 50px #ff0000,
                0 0 80px rgba(255, 0, 0, 0.6);
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            animation: pulseRed 0.8s infinite alternate;
        }
        
        @keyframes pulseRed {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.8; }
        }
        
        .red-line {
            position: absolute; background: rgba(255, 0, 0, 0.3);
        }
        .red-line.h { width: 100%; height: 2px; top: 50%; }
        .red-line.v { height: 100%; width: 2px; left: 50%; }

        /* === ENHANCED STORM VISUALS === */
        #storm-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, 
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.2) 40%,
                rgba(75, 0, 130, 0.3) 60%,
                rgba(75, 0, 130, 0.4) 80%,
                rgba(75, 0, 130, 0.5) 100%);
            mix-blend-mode: multiply; 
            pointer-events: none; 
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 50; 
        }
        
        #storm-overlay.in-storm {
            background: radial-gradient(circle at 50% 50%,
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.3) 30%,
                rgba(75, 0, 130, 0.5) 50%,
                rgba(75, 0, 130, 0.7) 70%,
                rgba(75, 0, 130, 0.9) 100%);
            animation: stormPulse 1.5s infinite alternate;
        }
        
        @keyframes stormPulse {
            0% { opacity: 0.9; filter: brightness(1); }
            100% { opacity: 1; filter: brightness(1.3); }
        }

        /* === ENHANCED HUD === */
        #hud-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        /* === ENHANCED TOP BAR === */
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2rem;
            background: rgba(0, 4, 40, 0.95);
            backdrop-filter: blur(30px);
            padding: 1rem 2rem;
            border-radius: 20px;
            border: 3px solid rgba(255, 140, 0, 0.5);
            box-shadow: 
                0 15px 50px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 0 30px rgba(255, 140, 0, 0.4);
            z-index: 20;
        }
        
        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 130px;
        }
        
        .hud-label {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.9);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 0.3rem;
            font-weight: 800;
            text-shadow: 0 2px 10px rgba(0,0,0,0.7);
        }
        
        .hud-value {
            font-size: 2rem;
            font-weight: 900;
            color: white;
            text-shadow: 
                0 2px 10px rgba(0,0,0,0.7),
                0 0 20px currentColor;
            letter-spacing: 1px;
        }
        
        #alive-count { 
            color: #4CAF50;
            text-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
        }
        #storm-timer { 
            color: #9d4edd;
            text-shadow: 0 0 20px rgba(157, 78, 221, 0.7);
        }
        #storm-status {
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
        }

        /* === ENHANCED PLAYER STATS === */
        #player-stats {
            position: absolute;
            bottom: 2rem;
            left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 280px;
            z-index: 20;
        }
        
        .stat-card {
            background: linear-gradient(135deg, 
                rgba(0, 4, 40, 0.95) 0%,
                rgba(0, 78, 146, 0.95) 100%);
            backdrop-filter: blur(25px);
            border-radius: 15px;
            padding: 1rem 1.5rem;
            border: 3px solid rgba(255,255,255,0.2);
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.7),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 25px rgba(255,255,255,0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.1) 0%,
                transparent 100%);
            z-index: 1;
        }
        
        .stat-card:hover {
            border-color: rgba(255, 140, 0, 0.5);
            transform: translateY(-8px) scale(1.03);
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.9),
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 0 40px rgba(255, 140, 0, 0.5);
        }
        
        .stat-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.8rem;
            position: relative;
            z-index: 2;
        }
        
        .stat-icon {
            font-size: 1.3rem;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.2) 0%,
                rgba(255,255,255,0.1) 100%);
            border-radius: 12px;
            border: 3px solid rgba(255,255,255,0.3);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 5px 15px rgba(0,0,0,0.4);
        }
        
        .stat-title {
            flex: 1;
            font-size: 1rem;
            font-weight: 800;
            color: rgba(255,255,255,0.98);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 0 3px 10px rgba(0,0,0,0.6);
        }
        
        .stat-value {
            font-size: 1.4rem;
            font-weight: 900;
            color: #ffd700;
            min-width: 60px;
            text-align: right;
            text-shadow: 
                0 3px 10px rgba(0,0,0,0.6),
                0 0 20px rgba(255, 215, 0, 0.7);
        }
        
        .stat-bar-container {
            height: 10px;
            background: rgba(255,255,255,0.15);
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            z-index: 2;
            box-shadow: 
                inset 0 2px 5px rgba(0,0,0,0.6),
                0 3px 8px rgba(0,0,0,0.4);
        }
        
        .stat-bar {
            height: 100%;
            border-radius: 5px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.6), 
                transparent);
            animation: barShine 2s infinite linear;
        }
        
        .stat-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.3) 0%,
                transparent 50%,
                rgba(255,255,255,0.2) 100%);
        }
        
        @keyframes barShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #health-bar { 
            background: linear-gradient(90deg, 
                #ff3333 0%, 
                #ff6666 50%, 
                #ff9999 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 20px rgba(255, 51, 51, 0.6);
        }
        
        #shield-bar { 
            background: linear-gradient(90deg, 
                #0099ff 0%, 
                #00ccff 50%, 
                #00ffff 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 20px rgba(0, 153, 255, 0.6);
        }
        
        #overshield-bar { 
            background: linear-gradient(90deg, 
                #ffaa00 0%, 
                #ffcc00 50%, 
                #ffff00 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 20px rgba(255, 170, 0, 0.6);
        }

        /* === ENHANCED RESOURCES BAR === */
        #resources-bar {
            display: flex;
            gap: 1.2rem;
            margin-top: 1rem;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            padding: 0.8rem 1.2rem;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.15) 0%,
                rgba(255,255,255,0.08) 100%);
            border-radius: 12px;
            border: 3px solid rgba(255,255,255,0.2);
            box-shadow: 
                0 8px 20px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.15);
            transition: all 0.3s ease;
        }
        
        .resource-item:hover {
            transform: translateY(-4px);
            border-color: rgba(222, 184, 135, 0.5);
            box-shadow: 
                0 12px 30px rgba(0,0,0,0.7),
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 0 20px rgba(222, 184, 135, 0.4);
        }
        
        .resource-icon {
            font-size: 1.4rem;
            color: #deb887;
            text-shadow: 0 0 12px rgba(222, 184, 135, 0.7);
        }
        
        .resource-amount {
            font-size: 1.3rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 3px 10px rgba(0,0,0,0.7);
        }

        /* === REORGANIZED INVENTORY === */
        #inventory-hud {
            position: absolute;
            bottom: 2rem;
            right: 1.5rem;
            display: flex;
            gap: 0.8rem;
            z-index: 20;
        }
        
        .inventory-slot {
            width: 80px;
            height: 95px;
            background: linear-gradient(135deg, 
                rgba(0, 4, 40, 0.98) 0%,
                rgba(0, 78, 146, 0.98) 100%);
            backdrop-filter: blur(25px);
            border-radius: 15px;
            border: 3px solid rgba(255,255,255,0.25);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.15);
        }
        
        .inventory-slot::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.08) 0%,
                transparent 100%);
        }
        
        .inventory-slot:hover {
            transform: translateY(-8px) scale(1.1);
            border-color: rgba(255,255,255,0.5);
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.8),
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 0 30px rgba(255,255,255,0.3);
        }
        
        .inventory-slot.active {
            border-color: #ff4d4d;
            transform: translateY(-12px) scale(1.15);
            background: linear-gradient(135deg, 
                rgba(40, 40, 60, 0.99) 0%,
                rgba(60, 60, 100, 0.99) 100%);
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.9),
                inset 0 1px 0 rgba(255,255,255,0.25),
                0 0 40px rgba(255, 77, 77, 0.6);
        }
        
        .slot-key {
            position: absolute;
            top: 8px;
            left: 8px;
            font-size: 0.85rem;
            color: rgba(255,255,255,0.9);
            font-weight: 800;
            background: rgba(0,0,0,0.7);
            padding: 0.3rem 0.6rem;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.3);
            text-shadow: 0 3px 6px rgba(0,0,0,0.6);
        }
        
        .slot-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 15px currentColor;
            filter: drop-shadow(0 0 6px currentColor);
        }
        
        .slot-name {
            font-size: 0.7rem;
            font-weight: 800;
            color: rgba(255,255,255,0.98);
            text-transform: uppercase;
            text-align: center;
            max-width: 70px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 0 0.3rem;
            text-shadow: 0 3px 6px rgba(0,0,0,0.6);
        }
        
        .slot-count {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 0.85rem;
            font-weight: 900;
            color: #ffd700;
            background: rgba(0,0,0,0.7);
            padding: 0.3rem 0.6rem;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.3);
            text-shadow: 
                0 3px 6px rgba(0,0,0,0.6),
                0 0 12px rgba(255, 215, 0, 0.7);
        }
        
        /* Enhanced Rarity Borders */
        .rarity-common { 
            border-bottom: 5px solid #b0b0b0;
            box-shadow: 0 0 20px rgba(176, 176, 176, 0.4);
        }
        .rarity-uncommon { 
            border-bottom: 5px solid #28a745;
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.4);
        }
        .rarity-rare { 
            border-bottom: 5px solid #007bff;
            box-shadow: 0 0 20px rgba(0, 123, 255, 0.4);
        }
        .rarity-epic { 
            border-bottom: 5px solid #a335ee;
            box-shadow: 0 0 20px rgba(163, 53, 238, 0.4);
        }
        .rarity-legendary { 
            border-bottom: 5px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }
        .rarity-mythic { 
            border-bottom: 5px solid #ff4d4d;
            box-shadow: 0 0 20px rgba(255, 77, 77, 0.4);
        }

        /* Center HUD Elements */
        #center-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            z-index: 15;
        }

        /* Enhanced Interaction Prompt */
        #interact-prompt {
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.99), 
                rgba(255, 140, 0, 0.99));
            color: #000;
            padding: 1.5rem 3rem;
            border-radius: 20px;
            font-size: 1.4rem;
            font-weight: 900;
            display: none;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 
                0 20px 50px rgba(255, 215, 0, 0.7),
                0 12px 30px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.7);
            border: 5px solid rgba(255,255,255,0.7);
            backdrop-filter: blur(20px);
            animation: pulsePrompt 1.5s infinite alternate;
            pointer-events: none;
            position: relative;
            overflow: hidden;
        }
        
        #interact-prompt::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                transparent 0%,
                rgba(255,255,255,0.4) 50%,
                transparent 100%);
            animation: promptShine 3s infinite linear;
        }
        
        @keyframes promptShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes pulsePrompt {
            0% { transform: translateY(-50%) scale(1); box-shadow: 0 20px 50px rgba(255, 215, 0, 0.7); }
            100% { transform: translateY(-50%) scale(1.1); box-shadow: 0 25px 60px rgba(255, 215, 0, 0.9), 0 0 120px rgba(255, 140, 0, 0.6); }
        }

        /* Enhanced Reload Indicator */
        #reload-indicator {
            background: linear-gradient(135deg, 
                rgba(255, 0, 0, 0.99), 
                rgba(255, 77, 77, 0.99));
            color: white;
            padding: 1.2rem 2.5rem;
            border-radius: 18px;
            font-size: 1.3rem;
            font-weight: 900;
            display: none;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 
                0 20px 50px rgba(255, 0, 0, 0.7),
                0 12px 30px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.4);
            border: 4px solid rgba(255,255,255,0.5);
            backdrop-filter: blur(20px);
            animation: reloadPulse 1s infinite alternate;
        }
        
        @keyframes reloadPulse {
            0% { opacity: 0.9; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.08); }
        }

        /* Enhanced Healing Progress */
        #healing-progress {
            position: absolute;
            bottom: 12rem;
            left: 50%;
            transform: translateX(-50%);
            width: 450px;
            height: 50px;
            background: linear-gradient(135deg, 
                rgba(0, 4, 40, 0.95) 0%,
                rgba(0, 78, 146, 0.95) 100%);
            border-radius: 30px;
            display: none;
            overflow: hidden;
            border: 4px solid rgba(0, 212, 255, 0.7);
            box-shadow: 
                0 20px 60px rgba(0, 212, 255, 0.5),
                inset 0 1px 0 rgba(255,255,255,0.25);
            backdrop-filter: blur(20px);
        }
        
        #healing-bar {
            height: 100%;
            background: linear-gradient(90deg, 
                #0099ff 0%, 
                #00d4ff 50%, 
                #00ffff 100%);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        #healing-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.6), 
                transparent);
            animation: healShine 1s infinite linear;
        }
        
        #healing-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.4) 0%,
                transparent 50%,
                rgba(255,255,255,0.2) 100%);
        }
        
        @keyframes healShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #healing-text {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 900;
            font-size: 1.4rem;
            text-shadow: 
                0 3px 12px rgba(0,0,0,0.9),
                0 0 25px rgba(0, 212, 255, 0.7);
            letter-spacing: 3px;
        }

        /* Enhanced Damage Numbers */
        .dmg-number {
            position: absolute;
            color: white;
            font-weight: 900;
            font-size: 2.8rem;
            text-shadow: 
                3px 3px 10px rgba(0,0,0,1),
                0 0 25px currentColor,
                0 0 50px currentColor;
            pointer-events: none;
            animation: damageFloat 1.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            z-index: 999;
            font-family: 'Poppins', sans-serif;
            letter-spacing: 2px;
        }
        
        .dmg-number.headshot {
            color: #ff0000;
            font-size: 3.5rem;
            text-shadow: 
                0 0 30px #ff0000,
                0 0 60px #ff0000,
                0 0 90px rgba(255, 0, 0, 0.8);
        }
        
        .dmg-number.storm {
            color: #9d4edd;
            font-size: 2.5rem;
            text-shadow: 
                0 0 30px #9d4edd,
                0 0 55px rgba(157, 78, 221, 0.8);
        }
        
        @keyframes damageFloat { 
            0% { opacity: 1; transform: translateY(0) scale(1) rotate(0deg); } 
            30% { opacity: 1; transform: translateY(-25px) scale(1.2) rotate(-8deg); }
            70% { opacity: 1; transform: translateY(-70px) scale(1.4) rotate(8deg); }
            100% { opacity: 0; transform: translateY(-100px) scale(1.5) rotate(0deg); } 
        }

        /* === ENHANCED VISUAL EFFECTS === */
        .muzzle-flash {
            position: absolute;
            width: 25px;
            height: 25px;
            background: radial-gradient(circle, #ffaa00, #ff6600, transparent 75%);
            border-radius: 50%;
            pointer-events: none;
            animation: muzzleFlash 0.15s forwards;
            z-index: 100;
        }
        
        @keyframes muzzleFlash {
            0% { opacity: 1; transform: scale(0.5); }
            100% { opacity: 0; transform: scale(2.5); }
        }
        
        .bullet-trail {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, #ffaa00, #ff6600, transparent);
            pointer-events: none;
            animation: bulletTrail 0.25s forwards;
            z-index: 99;
        }
        
        @keyframes bulletTrail {
            0% { width: 0; opacity: 1; }
            100% { width: 70px; opacity: 0; }
        }
        
        .impact-effect {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff8800, #ff4400, transparent 75%);
            border-radius: 50%;
            pointer-events: none;
            animation: impactEffect 0.4s forwards;
            z-index: 98;
        }
        
        @keyframes impactEffect {
            0% { opacity: 1; transform: scale(0.5); }
            100% { opacity: 0; transform: scale(2.5); }
        }
        
        .blood-effect {
            position: absolute;
            width: 25px;
            height: 25px;
            background: radial-gradient(circle, #ff0000, #990000, transparent 75%);
            border-radius: 50%;
            pointer-events: none;
            animation: bloodEffect 0.5s forwards;
            z-index: 97;
        }
        
        @keyframes bloodEffect {
            0% { opacity: 1; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(2); }
            100% { opacity: 0; transform: scale(2.5); }
        }

        /* === ENHANCED FPS COUNTER === */
        #fps-counter {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 0.6rem 1.2rem;
            border-radius: 10px;
            font-family: 'Poppins', monospace;
            font-size: 1.1rem;
            font-weight: 800;
            z-index: 1000;
            border: 2px solid rgba(0, 255, 0, 0.4);
            backdrop-filter: blur(15px);
            text-shadow: 0 0 15px #00ff00;
        }
        
        #fps-counter::before {
            content: 'FPS: ';
            color: rgba(255, 255, 255, 0.9);
        }

        /* === ENHANCED MOBILE CONTROLS (FIXED) === */
        #mobile-controls {
            display: none; 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none;
            z-index: 5;
        }
        
        /* FIXED: Left side - Movement joystick area (50%) */
        #touch-left {
            position: absolute;
            top: 0; left: 0;
            width: 50%; height: 100%;
            pointer-events: auto;
            touch-action: none;
            z-index: 6;
        }
        
        /* FIXED: Right side - Camera control area (50%) - HIGH SENSITIVITY */
        #touch-right {
            position: absolute;
            top: 0; right: 0;
            width: 50%; height: 100%;
            background: rgba(0, 212, 255, 0.05);
            pointer-events: auto;
            touch-action: none;
            z-index: 6;
        }
        
        /* Enhanced Movement Zone */
        #movement-zone {
            position: absolute;
            bottom: 140px;
            left: 100px;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.12) 0%,
                rgba(255,255,255,0.06) 70%,
                transparent 71%);
            border-radius: 50%;
            border: 5px solid rgba(255,255,255,0.3);
            pointer-events: none;
            box-shadow: 
                0 20px 50px rgba(0,0,0,0.7),
                inset 0 0 40px rgba(255,255,255,0.15);
            z-index: 7;
            opacity: 0.95;
            display: none;
        }
        
        .joystick-thumb {
            position: absolute;
            top: 50%; left: 50%;
            width: 80px; height: 80px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.5) 0%,
                rgba(255,255,255,0.3) 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 12px 35px rgba(0,0,0,0.8),
                inset 0 0 25px rgba(255,255,255,0.4);
            border: 4px solid rgba(255,255,255,0.5);
            pointer-events: none;
            transition: transform 0.05s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 8;
        }

        /* Enhanced Camera Zone - High Sensitivity Area */
        #camera-zone {
            position: absolute;
            top: 0; right: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle at 80% 50%, 
                rgba(0, 212, 255, 0.1) 0%,
                transparent 70%);
            pointer-events: none;
            z-index: 6;
        }

        /* Enhanced Mobile Action Buttons - AIM BUTTON MOVED */
        .mobile-button {
            position: absolute;
            width: 95px; height: 95px;
            border-radius: 50%;
            background: linear-gradient(135deg, 
                rgba(0, 4, 40, 0.98),
                rgba(0, 78, 146, 0.98));
            border: 5px solid rgba(255,255,255,0.4);
            color: white;
            font-weight: 900;
            font-size: 1.1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            text-align: center;
            text-transform: uppercase;
            z-index: 10;
            box-shadow: 
                0 15px 45px rgba(0,0,0,0.8),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 25px rgba(255,255,255,0.2);
            transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .mobile-button:active {
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.5),
                rgba(255,255,255,0.4));
            transform: scale(0.85);
            box-shadow: 
                0 8px 25px rgba(0,0,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.5),
                0 0 40px rgba(255,255,255,0.4);
        }
        
        #btn-fire { 
            bottom: 140px; right: 50px; 
            width: 110px; height: 110px;
            border-color: #ff4444;
            background: linear-gradient(135deg, 
                rgba(255,0,0,0.7),
                rgba(255,77,77,0.6));
            font-size: 1.4rem;
            box-shadow: 
                0 20px 50px rgba(255,0,0,0.7),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 35px rgba(255,0,0,0.4);
        }
        
        #btn-fire:active {
            box-shadow: 
                0 10px 35px rgba(255,0,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.5),
                0 0 50px rgba(255,0,0,0.6);
        }
        
        #btn-jump { 
            bottom: 270px; right: 60px;
            border-color: #00d4ff;
            background: linear-gradient(135deg,
                rgba(0,212,255,0.7),
                rgba(0,168,255,0.6));
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }
        
        #btn-interact { 
            bottom: 220px; right: 160px;
            border-color: #ffd700;
            color: #ffd700;
            background: linear-gradient(135deg,
                rgba(255,215,0,0.5),
                rgba(255,170,0,0.4));
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
        }
        
        #btn-build { 
            bottom: 300px; right: 160px;
            border-color: #8B4513;
            background: linear-gradient(135deg,
                rgba(139,69,19,0.7),
                rgba(160,82,45,0.6));
            box-shadow: 0 0 30px rgba(139, 69, 19, 0.4);
        }
        
        /* MOVED AIM BUTTON - Away from inventory */
        #btn-ads { 
            top: 50px; right: 160px;  /* MOVED TO TOP RIGHT */
            width: 85px; height: 85px;
            font-size: 1rem;
            border-color: #0099ff;
            background: linear-gradient(135deg,
                rgba(0,153,255,0.7),
                rgba(0,102,204,0.6));
            box-shadow: 0 0 25px rgba(0, 153, 255, 0.4);
        }
        
        #btn-reload { 
            top: 50px; right: 50px;
            width: 80px; height: 80px;
            font-size: 0.9rem;
            border-color: #00d4ff;
            background: linear-gradient(135deg,
                rgba(0,212,255,0.7),
                rgba(0,168,255,0.6));
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
            display: none;
        }

        /* === ENHANCED VICTORY & ELIMINATED SCREENS === */
        #victory-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(255, 215, 0, 0.95),
                rgba(255, 140, 0, 0.97));
            backdrop-filter: blur(40px);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            animation: fadeIn 0.5s ease-out forwards;
            overflow: hidden;
        }
        
        .victory-particles {
            position: absolute;
            width: 100%; height: 100%;
        }
        
        .victory-particle {
            position: absolute;
            width: 15px; height: 15px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 50%;
            animation: victoryParticleFloat 6s infinite linear;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.9);
        }
        
        @keyframes victoryParticleFloat {
            0% { transform: translateY(100vh) rotate(0deg) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(90vh) rotate(0deg) scale(1); }
            90% { opacity: 1; transform: translateY(10vh) rotate(360deg) scale(1); }
            100% { transform: translateY(0) rotate(720deg) scale(0); opacity: 0; }
        }
        
        #victory-text {
            font-size: 0;
            background: linear-gradient(135deg, #ffd700, #ffaa00, #ff6600, #ff0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            animation: victoryText 4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards,
                       victoryPulse 2.5s infinite alternate 4s;
            position: relative;
            text-shadow: 
                0 20px 60px rgba(255, 215, 0, 0.8),
                0 0 100px rgba(255, 170, 0, 0.6),
                0 0 150px rgba(255, 100, 0, 0.4);
            letter-spacing: -10px;
            opacity: 0;
            white-space: nowrap;
            z-index: 2;
        }
        
        #victory-text::after {
            content: 'V19.8';
            display: block;
            font-size: 3rem;
            margin-top: 2rem;
            color: #ffffff;
            text-shadow: 0 0 50px rgba(255, 255, 255, 1);
            animation: versionPulse 3s infinite alternate;
        }
        
        @keyframes versionPulse {
            0% { opacity: 0.8; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.2); }
        }
        
        @keyframes victoryText {
            0% { font-size: 0; transform: scale(0) rotate(-20deg); opacity: 0; letter-spacing: 100px; }
            30% { font-size: 10rem; transform: scale(1.6) rotate(20deg); opacity: 1; letter-spacing: -10px; }
            50% { font-size: 10rem; transform: scale(1.6) rotate(-8deg); opacity: 1; letter-spacing: -5px; }
            70% { font-size: 10rem; transform: scale(1.4) rotate(8deg); opacity: 1; letter-spacing: -2px; }
            100% { font-size: 8rem; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0; }
        }
        
        @keyframes victoryPulse {
            0% { transform: scale(1); text-shadow: 0 20px 60px rgba(255, 215, 0, 0.8); }
            100% { transform: scale(1.15); text-shadow: 0 25px 70px rgba(255, 215, 0, 1), 0 0 120px rgba(255, 170, 0, 0.6); }
        }
        
        #victory-stats {
            font-size: 3rem;
            color: white;
            margin-top: 3rem;
            opacity: 0;
            animation: fadeUp 1s ease-out 5s forwards;
            text-shadow: 0 10px 30px rgba(0,0,0,0.8);
            z-index: 2;
        }
        
        /* === ENHANCED LEVEL STATS SCREEN === */
        #level-stats-screen {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(0, 100, 255, 0.97),
                rgba(157, 78, 221, 0.99));
            backdrop-filter: blur(40px);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1001;
            pointer-events: auto;
            text-align: center;
            overflow: hidden;
            animation: fadeIn 0.5s ease-out;
        }
        
        #level-stats-title {
            font-size: 4.5rem;
            background: linear-gradient(135deg, #ff8c00, #ff4500, #9d4edd);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
            font-weight: 900;
            text-shadow: 0 20px 50px rgba(255, 140, 0, 0.6);
            animation: slideDown 1s ease-out;
        }
        
        .stats-breakdown {
            background: rgba(0, 0, 0, 0.8);
            padding: 2.5rem;
            border-radius: 25px;
            margin: 2rem 0;
            max-width: 650px;
            width: 90%;
            border: 4px solid rgba(255, 140, 0, 0.6);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.7);
            animation: scaleIn 0.8s ease-out 0.5s backwards;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 2px solid rgba(255,255,255,0.15);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            font-size: 1.3rem;
            color: rgba(255,255,255,0.95);
            text-align: left;
        }
        
        .stat-value {
            font-size: 1.6rem;
            font-weight: 900;
            color: #ffd700;
            text-align: right;
        }
        
        .total-points {
            font-size: 2.8rem;
            color: #00ff00;
            font-weight: 900;
            margin: 2rem 0;
            text-shadow: 0 0 40px #00ff00;
            animation: pulse 1s infinite alternate;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.08); }
        }
        
        .level-progress-container {
            margin-top: 2.5rem;
            width: 85%;
            max-width: 450px;
        }
        
        .level-progress-text {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.8rem;
            font-size: 1.1rem;
        }
        
        .level-progress-bar {
            height: 18px;
            background: rgba(255,255,255,0.15);
            border-radius: 9px;
            overflow: hidden;
        }
        
        .level-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff8c00, #ff4500, #9d4edd);
            transition: width 1s ease-out;
            border-radius: 9px;
        }
        
        /* === MOVED RETURN TO LOBBY BUTTON === */
        #game-over {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(200, 0, 0, 0.98),
                rgba(50, 0, 0, 0.99));
            backdrop-filter: blur(40px);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 999;
            pointer-events: auto;
            text-align: center;
            overflow: hidden;
        }
        
        .eliminated-particles {
            position: absolute;
            width: 100%; height: 100%;
        }
        
        .eliminated-particle {
            position: absolute;
            width: 12px; height: 12px;
            background: rgba(255, 50, 50, 0.8);
            border-radius: 50%;
            animation: eliminatedParticleFall 4s infinite linear;
        }
        
        @keyframes eliminatedParticleFall {
            0% { transform: translateY(-100px) rotate(0deg) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(0) rotate(0deg) scale(1); }
            90% { opacity: 1; transform: translateY(100vh) rotate(360deg) scale(1); }
            100% { transform: translateY(110vh) rotate(720deg) scale(0); opacity: 0; }
        }
        
        #go-title {
            font-size: 0;
            background: linear-gradient(135deg, #ff4d4d, #ff0000, #8b0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
            font-weight: 900;
            animation: eliminatedText 3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 20px 60px rgba(255, 0, 0, 0.7);
            letter-spacing: -10px;
            opacity: 0;
        }
        
        @keyframes eliminatedText {
            0% { font-size: 0; transform: scale(0) rotate(-10deg); opacity: 0; letter-spacing: 50px; }
            40% { font-size: 9rem; transform: scale(1.5) rotate(8deg); opacity: 1; letter-spacing: -5px; }
            60% { font-size: 9rem; transform: scale(1.3) rotate(-3deg); opacity: 1; letter-spacing: -2px; }
            100% { font-size: 7rem; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0; }
        }
        
        #go-stats {
            font-size: 3rem;
            color: rgba(255,255,255,0.98);
            margin-bottom: 4rem;
            animation: slideIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) 3s backwards;
            text-shadow: 0 10px 30px rgba(0,0,0,0.8);
            z-index: 2;
        }

        /* Enhanced Restart Button - MOVED POSITION */
        .restart-btn {
            margin-top: 3rem;
            padding: 1.8rem 4rem;
            font-size: 1.8rem;
            background: linear-gradient(135deg, #ff8c00, #ff4500);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 900;
            box-shadow: 
                0 20px 60px rgba(255, 140, 0, 0.8),
                inset 0 1px 0 rgba(255,255,255,0.5),
                0 0 40px rgba(255, 140, 0, 0.6);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            letter-spacing: 2px;
            backdrop-filter: blur(20px);
            border: 4px solid rgba(255,255,255,0.3);
            z-index: 2;
        }
        
        .restart-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            transition: left 0.6s;
        }
        
        .restart-btn:hover::before {
            left: 100%;
        }
        
        .restart-btn:hover {
            background: linear-gradient(135deg, #ff6600, #cc3700);
            transform: translateY(-8px);
            box-shadow: 
                0 25px 70px rgba(255, 140, 0, 1),
                inset 0 1px 0 rgba(255,255,255,0.6),
                0 0 50px rgba(255, 140, 0, 0.8);
        }
        
        #game-over .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 3.5s forwards;
            margin-top: 2rem; /* MOVED UP */
        }
        
        #victory-overlay .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 5.5s forwards;
            margin-top: 2rem; /* MOVED UP */
        }
        
        #level-stats-screen .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 2.5s forwards;
            margin-top: 2rem; /* MOVED UP */
        }

        /* Animations */
        @keyframes fadeIn { 
            0% { opacity: 0; } 
            100% { opacity: 1; } 
        }
        
        @keyframes slideDown {
            0% { opacity: 0; transform: translateY(-60px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes scaleIn {
            0% { opacity: 0; transform: scale(0.7) rotate(-8deg); }
            70% { opacity: 1; transform: scale(1.08) rotate(3deg); }
            100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }
        
        @keyframes slideIn {
            0% { opacity: 0; transform: translateY(-60px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes fadeUp {
            0% { transform: translateY(60px) scale(0.9); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        /* Enhanced Menu Elements */
        .menu-background {
            position: absolute;
            width: 100%; height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 140, 0, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 212, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(157, 78, 221, 0.3) 0%, transparent 50%);
            animation: backgroundPulse 8s infinite alternate;
        }
        
        @keyframes backgroundPulse {
            0% { opacity: 0.5; }
            100% { opacity: 0.9; }
        }
        
        .version-badge {
            position: absolute;
            top: 25px;
            right: 25px;
            background: linear-gradient(135deg, #ff8c00, #ff4500);
            color: #fff;
            padding: 1rem 2rem;
            border-radius: 30px;
            font-weight: 900;
            font-size: 1.1rem;
            animation: badgeGlow 2s infinite alternate;
            box-shadow: 
                0 10px 35px rgba(255, 140, 0, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.4);
            border: 3px solid rgba(255,255,255,0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        @keyframes badgeGlow {
            0% { box-shadow: 0 10px 35px rgba(255, 140, 0, 0.6); }
            100% { box-shadow: 0 15px 45px rgba(255, 140, 0, 0.9), 0 0 40px rgba(255, 140, 0, 0.4); }
        }
        
        .menu-title {
            position: relative;
            margin-bottom: 2.5rem;
        }
        
        .title-glow {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 130%; height: 130%;
            background: radial-gradient(circle, rgba(255, 140, 0, 0.5) 0%, transparent 70%);
            filter: blur(60px);
            z-index: 1;
        }

        /* === NEW: MINI-MAP === */
        #mini-map {
            position: absolute;
            top: 120px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 4, 40, 0.9);
            border-radius: 20px;
            border: 3px solid rgba(255, 140, 0, 0.6);
            backdrop-filter: blur(20px);
            z-index: 20;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(0,0,0,0.7);
        }
        
        #mini-map-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* === NEW: SETTINGS MENU === */
        #settings-menu {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 4, 40, 0.98);
            backdrop-filter: blur(40px);
            z-index: 1002;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        
        .settings-container {
            background: rgba(0, 78, 146, 0.8);
            padding: 2.5rem;
            border-radius: 25px;
            max-width: 500px;
            width: 90%;
            border: 4px solid rgba(255, 140, 0, 0.6);
            box-shadow: 0 25px 60px rgba(0,0,0,0.8);
        }
        
        .settings-title {
            font-size: 2.5rem;
            color: #ff8c00;
            margin-bottom: 2rem;
            text-align: center;
            text-shadow: 0 0 30px rgba(255, 140, 0, 0.7);
        }
        
        .setting-item {
            margin-bottom: 1.5rem;
        }
        
        .setting-label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
            color: rgba(255,255,255,0.95);
        }
        
        .setting-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff8c00;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 140, 0, 0.7);
        }
        
        /* === NEW: PAUSE MENU === */
        #pause-menu {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 4, 40, 0.95);
            backdrop-filter: blur(40px);
            z-index: 1002;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        
        .pause-title {
            font-size: 4rem;
            color: #ff8c00;
            margin-bottom: 2rem;
            text-shadow: 0 0 40px rgba(255, 140, 0, 0.8);
        }
        
        /* === NEW: GRAPHICS SETTINGS === */
        .graphics-option {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.8rem;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .graphics-option:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }
        
        .graphics-option input {
            margin-right: 1rem;
            transform: scale(1.3);
        }
        
        /* === NEW: HIT MARKER === */
        .hit-marker {
            position: absolute;
            top: 50%; left: 50%;
            width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 99;
            opacity: 0;
        }
        
        .hit-marker::before,
        .hit-marker::after {
            content: '';
            position: absolute;
            background: #ff4d4d;
            box-shadow: 0 0 20px #ff4d4d;
        }
        
        .hit-marker::before {
            width: 40px; height: 4px;
            top: 18px; left: 0;
        }
        
        .hit-marker::after {
            width: 4px; height: 40px;
            top: 0; left: 18px;
        }
        
        @keyframes hitMarker {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>

    <div id="start-screen">
        <div class="solar-flare"></div>
        <div class="menu-background"></div>
        <div class="version-badge">V19.8 â€¢ SOLAR EDITION</div>
        <div class="menu-title">
            <div class="title-glow"></div>
            <h1>WEB BATTLE ROYALE</h1>
        </div>
        <p class="subtitle">Experience the ultimate solar-powered shooter</p>
        <div class="button-container">
            <button class="game-button mobile" onclick="startGame('mobile')">ðŸ“± Mobile Mode</button>
            <button class="game-button" onclick="startGame('desktop')">ðŸ–¥ï¸ Desktop Mode</button>
            <button class="game-button controller" onclick="startGame('controller')">ðŸŽ® Controller Mode</button>
        </div>
        <div class="stats-grid">
            <div class="stat-item">
                <h3>Active Players</h3>
                <p id="total-players">25</p>
            </div>
            <div class="stat-item">
                <h3>Map Size</h3>
                <p>600x600</p>
            </div>
            <div class="stat-item">
                <h3>Version</h3>
                <p>V19.8</p>
            </div>
        </div>
        <!-- MOVED LEVEL STATS TO BOTTOM LEFT -->
        <div id="level-stats">
            <div class="level-display">Level <span id="current-level">1</span></div>
            <div class="progress-bar">
                <div class="progress-fill" id="level-progress" style="width: 0%"></div>
            </div>
            <div class="progress-text"><span id="current-points">0</span>/<span id="next-level-points">150</span> Points</div>
            <div id="points-to-next">150 Points to Next Level</div>
        </div>
    </div>
    
    <div id="game-container"></div>

    <div id="ui-layer">
        <!-- Crosshair -->
        <div id="crosshair">
            <div class="crosshair-dot"></div>
            <div class="crosshair-line ch-h"></div>
            <div class="crosshair-line ch-v"></div>
        </div>
        
        <!-- Scopes -->
        <div id="scope-overlay">
            <div id="scope-lines"></div>
        </div>
        
        <div id="red-dot-scope">
            <div class="red-line h"></div>
            <div class="red-line v"></div>
            <div class="red-dot"></div>
        </div>

        <!-- Storm Overlay -->
        <div id="storm-overlay"></div>

        <!-- Mini-Map -->
        <div id="mini-map">
            <canvas id="mini-map-canvas"></canvas>
        </div>

        <!-- HUD Container -->
        <div id="hud-container">
            <!-- FPS Counter -->
            <div id="fps-counter">60</div>
            
            <!-- Top Bar -->
            <div id="top-bar">
                <div class="hud-item">
                    <div class="hud-label">Players Alive</div>
                    <div class="hud-value" id="alive-count">25</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Phase</div>
                    <div class="hud-value" id="storm-status">WAIT</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Timer</div>
                    <div class="hud-value" id="storm-timer">04:00</div>
                </div>
            </div>

            <!-- Player Stats (Left) -->
            <div id="player-stats">
                <!-- Health -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">â¤ï¸</div>
                        <div class="stat-title">Health</div>
                        <div class="stat-value" id="health-value">100</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="health-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Shield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">ðŸ›¡ï¸</div>
                        <div class="stat-title">Shield</div>
                        <div class="stat-value" id="shield-value">100</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="shield-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Overshield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">ðŸ”¥</div>
                        <div class="stat-title">Overshield</div>
                        <div class="stat-value" id="overshield-value">50</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="overshield-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Resources -->
                <div id="resources-bar">
                    <div class="resource-item">
                        <div class="resource-icon">ðŸªµ</div>
                        <div class="resource-amount" id="wood-value">0</div>
                    </div>
                </div>
            </div>

            <!-- Inventory (Right) -->
            <div id="inventory-hud">
                <div class="inventory-slot" id="slot-0" onclick="selectSlot(0)" ontouchstart="selectSlotMobile(0)"></div>
                <div class="inventory-slot" id="slot-1" onclick="selectSlot(1)" ontouchstart="selectSlotMobile(1)"></div>
                <div class="inventory-slot" id="slot-2" onclick="selectSlot(2)" ontouchstart="selectSlotMobile(2)"></div>
                <div class="inventory-slot" id="slot-3" onclick="selectSlot(3)" ontouchstart="selectSlotMobile(3)"></div>
                <div class="inventory-slot" id="slot-4" onclick="selectSlot(4)" ontouchstart="selectSlotMobile(4)"></div>
            </div>

            <!-- Center HUD -->
            <div id="center-hud">
                <div id="interact-prompt">Interact (E)</div>
                <div id="reload-indicator">RELOADING...</div>
                <div class="hit-marker" id="hit-marker"></div>
            </div>

            <!-- Healing Progress -->
            <div id="healing-progress">
                <div id="healing-bar"></div>
                <div id="healing-text">USING SHIELD...</div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div id="touch-left"></div>
            <div id="touch-right"></div>
            
            <div id="movement-zone">
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
            
            <div id="camera-zone"></div>
            
            <div id="btn-fire" class="mobile-button">FIRE</div>
            <div id="btn-jump" class="mobile-button">JUMP</div>
            <div id="btn-interact" class="mobile-button">INTERACT</div>
            <div id="btn-build" class="mobile-button">BUILD</div>
            <div id="btn-ads" class="mobile-button">AIM</div>
            <div id="btn-reload" class="mobile-button">RELOAD</div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-overlay">
        <div class="victory-particles" id="victory-particles"></div>
        <div id="victory-text">VICTORY ROYALE</div>
        <div id="victory-stats">Eliminations: 0</div>
        <button class="restart-btn" onclick="location.reload()">ðŸ† RETURN TO LOBBY</button>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <div class="eliminated-particles" id="eliminated-particles"></div>
        <h1 id="go-title">ELIMINATED</h1>
        <h3 id="go-stats">Eliminations: 0</h3>
        <button class="restart-btn" onclick="location.reload()">ðŸ”„ RETURN TO LOBBY</button>
    </div>
    
    <!-- Level Stats Screen -->
    <div id="level-stats-screen">
        <h1 id="level-stats-title">MATCH RESULTS</h1>
        <div class="stats-breakdown">
            <div class="stat-row">
                <div class="stat-label">Eliminations:</div>
                <div class="stat-value" id="match-kills">0</div>
            </div>
            <div class="stat-row">
                <div class="stat-label">Chests Opened:</div>
                <div class="stat-value" id="match-chests">0</div>
            </div>
            <div class="stat-row">
                <div class="stat-label">Legendary Items Held:</div>
                <div class="stat-value" id="match-legendarys">0</div>
            </div>
            <div class="stat-row">
                <div class="stat-label">Final Placement:</div>
                <div class="stat-value" id="match-placement">25th</div>
            </div>
        </div>
        <div class="total-points">+ <span id="match-points">0</span> Points</div>
        <div class="level-progress-container">
            <div class="level-progress-text">
                <span>Level <span id="match-level">1</span></span>
                <span><span id="match-progress">0</span>/<span id="match-next-level">150</span></span>
            </div>
            <div class="level-progress-bar">
                <div class="level-progress-fill" id="match-progress-bar" style="width: 0%"></div>
            </div>
        </div>
        <button class="restart-btn" onclick="location.reload()">ðŸŽ® PLAY AGAIN</button>
    </div>

    <!-- Settings Menu -->
    <div id="settings-menu">
        <div class="settings-container">
            <h2 class="settings-title">Settings</h2>
            <div class="setting-item">
                <label class="setting-label">Mouse Sensitivity: <span id="sensitivity-value">1.0</span></label>
                <input type="range" class="setting-slider" id="sensitivity-slider" min="0.1" max="3" step="0.1" value="1.0">
            </div>
            <div class="setting-item">
                <label class="setting-label">Master Volume: <span id="volume-value">100</span>%</label>
                <input type="range" class="setting-slider" id="volume-slider" min="0" max="100" step="1" value="100">
            </div>
            <div class="setting-item">
                <label class="setting-label">Graphics Quality</label>
                <div class="graphics-option">
                    <input type="radio" id="graphics-low" name="graphics" value="low" checked>
                    <label for="graphics-low">Low Performance</label>
                </div>
                <div class="graphics-option">
                    <input type="radio" id="graphics-medium" name="graphics" value="medium">
                    <label for="graphics-medium">Medium (Recommended)</label>
                </div>
                <div class="graphics-option">
                    <input type="radio" id="graphics-high" name="graphics" value="high">
                    <label for="graphics-high">High Quality</label>
                </div>
                <div class="graphics-option">
                    <input type="radio" id="graphics-ultra" name="graphics" value="ultra">
                    <label for="graphics-ultra">Ultra (GPU Intensive)</label>
                </div>
            </div>
            <button class="restart-btn" onclick="closeSettings()" style="margin-top: 2rem;">BACK TO GAME</button>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pause-menu">
        <h2 class="pause-title">GAME PAUSED</h2>
        <button class="restart-btn" onclick="resumeGame()" style="margin-bottom: 1rem;">RESUME</button>
        <button class="restart-btn" onclick="openSettings()" style="margin-bottom: 1rem; background: linear-gradient(135deg, #0099ff, #0066cc);">SETTINGS</button>
        <button class="restart-btn" onclick="location.reload()">RETURN TO LOBBY</button>
    </div>

    <!-- Controller Notification -->
    <div class="controller-notification" id="controller-notification">ðŸŽ® Controller Connected</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ===============================================================
        // === V19.8 ENHANCED CONSTANTS AND CONFIGURATION ================
        // ===============================================================
        
        const WORLD_SIZE = 600;
        let BOT_COUNT = 24; // UPDATED: Increased to 24 bots
        const GRAVITY = 40.0; 
        const WALK_SPEED = 10; 
        const SPRINT_SPEED = 20; 
        const JUMP_FORCE = 15;
        const PLAYER_HEIGHT = 1.8;
        const SHOTGUN_PELLETS = 4;
        
        const OVER_SHIELD_MAX = 50;
        const OVER_SHIELD_REGEN_RATE = 15;
        const OVER_SHIELD_REGEN_DELAY = 7000;
        
        // === ENHANCED LEVELING SYSTEM ===
        const POINTS_PER_KILL = 5;
        const POINTS_TOP_10 = 10;
        const POINTS_TOP_2 = 15;
        const POINTS_PER_CHEST = 1;
        const POINTS_PER_LEGENDARY = 5;
        const BASE_POINTS_PER_LEVEL = 150;
        
        // === ENHANCED WEAPONS CONFIG - UPDATED SNIPER DAMAGE ===
        const RARITY_MULTIPLIERS = {
            COMMON: { dmg: 1.0, reload: 1.0, color: '#b0b0b0' },
            UNCOMMON: { dmg: 1.15, reload: 0.9, color: '#28a745' },
            RARE: { dmg: 1.3, reload: 0.8, color: '#007bff' },
            EPIC: { dmg: 1.45, reload: 0.7, color: '#a335ee' },
            LEGENDARY: { dmg: 1.6, reload: 0.6, color: '#ffd700' },
            MYTHIC: { dmg: 1.8, reload: 0.5, color: '#ff4d4d' } 
        };
        const RARITY_KEYS = Object.keys(RARITY_MULTIPLIERS);

        // Weapons configuration with UPDATED SNIPER DAMAGE
        const WEAPONS_BASE = {
            PUMP: { name: "Pump Shotgun", dmg: 30 * 1.5, head: 35 * 1.5, rate: 1.2, mag: 5, range: 30, spread: 0.25, pellets: SHOTGUN_PELLETS, auto: false, icon: 'ðŸ’¥', reload: 3000, recoil: 0.0, bulletType: 'hitscan' }, 
            AUTO_SHG: { name: "Auto Shotgun", dmg: 30, head: 50, rate: 0.4, mag: 8, range: 25, spread: 0.3, pellets: SHOTGUN_PELLETS, auto: true, icon: 'ðŸ”¥', reload: 3500, recoil: 0.0, bulletType: 'hitscan' },
            RFAR: { name: "Rapid Fire AR", dmg: 14, head: 21, rate: 0.1, mag: 30, range: 150, spread: 0.04, pellets: 1, auto: true, icon: 'ðŸ’¨', reload: 2500, recoil: 0.0, bulletType: 'hitscan' }, 
            DMR: { name: "DMR", dmg: 25, head: 40, rate: 0.35, mag: 15, range: 250, spread: 0.015, pellets: 1, auto: false, icon: 'ðŸŽ¯', reload: 2800, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            STINGER: { name: "Stinger SMG", dmg: 15, head: 22.5, rate: 0.07, mag: 20, range: 70, spread: 0.07, pellets: 1, auto: true, icon: 'âš¡', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            BURST_SMG: { name: "Burst SMG", dmg: 18, head: 30, rate: 0.15, mag: 30, burst: 2, burstDelay: 300, range: 80, spread: 0.05, pellets: 1, auto: false, icon: 'âœ¨', reload: 2000, recoil: 0.0, bulletType: 'hitscan' },
            // UPDATED: Bolt Sniper - 129 body, 219 head
            BOLT_SNIPER: { name: "Bolt Sniper", dmg: 129, head: 219, rate: 2.5, mag: 2, range: 600, spread: 0.001, pellets: 1, auto: false, icon: 'ðŸ’€', reload: 4000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            SCOPED_SMG: { name: "Scoped SMG", dmg: 12, head: 18, rate: 0.1, mag: 40, range: 100, spread: 0.03, pellets: 1, auto: true, icon: 'ðŸ‘ï¸', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            DRUM_SMG: { name: "Drum SMG", dmg: 10, head: 15, rate: 0.08, mag: 50, range: 80, spread: 0.08, pellets: 1, auto: true, icon: 'ðŸ¥', reload: 1200, recoil: 0.0, bulletType: 'hitscan' },
            // UPDATED: Falcon Sniper - 79 body, 119 head
            FALCON_SNIPER: { name: "Falcon Sniper", dmg: 79, head: 119, rate: 0.7, mag: 3, range: 500, spread: 0.005, pellets: 1, auto: false, icon: 'ðŸ¦…', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' }, 
            STRANGLED_RIFLE: { name: "Strangled Rifle", dmg: 35, head: 55, rate: 0.45, mag: 30, range: 180, spread: 0.02, pellets: 1, auto: false, icon: 'â›“ï¸', reload: 2500, recoil: 0.0, bulletType: 'hitscan' },
            // UPDATED: Normal Sniper - 131 body, 231 head
            SNIPER:{name: "Sniper", dmg: 131, head: 231, rate: 1.5, mag: 1,  range: 600,spread: 0.001,pellets:1, auto: false,icon:'ðŸ”­', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            PISTOL: { name: "Pistol", dmg: 12, head: 18, rate: 0.5, mag: 15, range: 100, spread: 0.05, pellets: 1, auto: false, icon: 'ðŸ’£', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            ROCKET_LAUNCHER: { name: "R. Launcher", dmg: 50, head: 0, rate: 4.0, mag: 1, range: 300, spread: 0.0, pellets: 1, auto: false, icon: 'ðŸš€', reload: 4500, recoil: 0.0, bulletType: 'projectile', explosionRadius: 5, explosionDamage: 200 },
            DUAL_SMG: { name: "Dual Micro SMGS", dmg: 11.25, head: 17.5, rate: 0.05, mag: 130, range: 70, spread: 0.1, pellets: 1, auto: true, icon: 'ðŸ”ª', reload: 2250, recoil: 0.0, bulletType: 'hitscan' },
            HEAVY_AR: { name: "Heavy AR", dmg: 30, head: 55, rate: 0.12, mag: 30, range: 200, spread: 0.035, pellets: 1, auto: false, icon: 'ðŸŽ–ï¸', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'holo_twister' }
        };
        const MYTHIC_WEAPON_KEY = 'STRANGLED_RIFLE'; 
        const BOT_WEAPON_KEY = 'RFAR'; 
        
        // === ENHANCED CONSUMABLES ===
        const CONSUMABLES = {
            MINI: { name: "Small Shield", val: 25, type: 'shield', max: 50, icon: 'ðŸ’§', time: 1, continuous: false, instant: true, maxStack: 6, rarity: 'COMMON' },
            BIG:  { name: "Big Shield", val: 50, type: 'shield', max: 100, icon: 'âš—ï¸', time: 5000, continuous: false, instant: false, maxStack: 3, rarity: 'UNCOMMON' },
            CHUG: { name: "Chug Jug", val: 3, shieldVal: 3, type: 'continuous', max: 100, icon: 'ðŸ¥¤', time: 20000, continuous: true, instant: false, maxStack: 1, rarity: 'LEGENDARY' },
            MEDKIT: { name: "Med Kit", val: 100, type: 'health', max: 100, icon: 'ðŸ©¹', time: 10000, continuous: false, instant: false, maxStack: 3, rarity: 'RARE' }
        };
        const CONSUMABLE_KEYS = Object.keys(CONSUMABLES);

        // === ENHANCED STORM PHASES ===
        const STORM_PHASES = [
            { time: 60, radius: WORLD_SIZE * 0.5, damage: 3, status: "Wait" }, 
            { time: 60, radius: WORLD_SIZE * 0.4, damage: 3, status: "Shrink" }, 
            { time: 120, radius: WORLD_SIZE * 0.4, damage: 3, status: "Hold" }, 
            { time: 60, radius: WORLD_SIZE * 0.3, damage: 5, status: "Shrink" }, 
            { time: 60, radius: 0, damage: 10, status: "Deathmatch" } 
        ];
        const BOT_STORM_DAMAGE = 5;

        // ===============================================================
        // === ENHANCED GLOBAL STATE =====================================
        // ===============================================================

        let scene, camera, renderer, controls;
        let weaponScene, weaponCamera, viewModel;
        let raycaster, downRay;
        let sunMesh; // NEW: Sun object
        
        // Enhanced player with new stats
        let player = { 
            health: 100, shield: 100, overshield: 50, wood: 0, 
            inventory: [null, null, null, null, null], slot: 0, 
            dead: false, ads: false, vehicle: null, eliminations: 0,
            isReloading: false,
            isHealing: false,
            healingItem: null,
            healingStartTime: 0,
            lastStormDamage: 0,
            isBursting: false,
            burstCount: 0,
            burstTimer: null,
            lastOvershieldDamage: 0, 
            overshieldRegenTimer: null,
            lastOvershieldBreak: 0,
            // Enhanced stats
            totalPoints: 0,
            level: 1,
            pointsToNextLevel: BASE_POINTS_PER_LEVEL,
            matchPoints: 0,
            chestsOpened: 0,
            legendaryItemsHeld: 0,
            accuracy: 0,
            shotsFired: 0,
            shotsHit: 0,
            damageDealt: 0,
            // Settings
            sensitivity: 1.0,
            volume: 1.0,
            graphicsQuality: 'medium'
        };
        
        let inputs = { w: false, a: false, s: false, d: false, jump: false, sprint: false, fire: false, reload: false, use: false };
        let velocity = new THREE.Vector3();
        let isGrounded = false;
        let lastTime = performance.now();
        let lastShot = 0;
        
        // Game mode
        let gameMode = 'desktop';
        let gameStarted = false;
        let gamePaused = false;
        
        // === ENHANCED MOBILE CONTROLS WITH HIGH SENSITIVITY ===
        let mobileTouchActive = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let touchDeltaX = 0;
        let touchDeltaY = 0;
        const MOBILE_SENSITIVITY = 0.008; // UPDATED: Much higher sensitivity
        const MOBILE_SMOOTHING = 0.1;
        const MAX_CAMERA_ANGLE = Math.PI / 2 - 0.1;
        
        // Controller variables
        let gamepad = null;
        let controllerConnected = false;
        let controllerVibration = true;
        let controllerMapping = {
            leftStick: { x: 0, y: 0 },
            rightStick: { x: 0, y: 0 },
            buttons: {
                l1: false, r1: false,
                l2: 0, r2: 0,
                y: false, b: false, a: false, x: false,
                dpadLeft: false, dpadRight: false, dpadUp: false, dpadDown: false,
                l3: false, r3: false,
                start: false, select: false
            }
        };
        const CONTROLLER_SENSITIVITY = 0.04;
        
        // Enhanced Arrays
        let bots = [];
        let objects = []; 
        let chests = [];
        let cars = [];
        let loot = [];
        let buildings = []; 
        let projectiles = []; 
        let doors = [];
        
        // Enhanced Visual Effects
        let visualEffects = [];
        let lastFpsUpdate = 0;
        let frameCount = 0;
        let fps = 60;
        let miniMapCanvas, miniMapCtx;

        // Storm State
        let stormRadius = STORM_PHASES[0].radius;
        let stormCenter = new THREE.Vector2(0, 0);
        let stormDamageRate = STORM_PHASES[0].damage;
        let stormPhaseTime = STORM_PHASES[0].time; 
        let stormPhaseTimer = stormPhaseTime;
        let stormPhase = 0;
        let stormActive = false;
        let stormTimerInterval;

        // ===============================================================
        // === ENHANCED AUDIO SYSTEM =====================================
        // ===============================================================

        let audioContext;
        let soundCache = {};
        let masterGainNode;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.value = player.volume;
                masterGainNode.connect(audioContext.destination);
            }
        }

        function setVolume(volume) {
            player.volume = volume;
            if (masterGainNode) {
                masterGainNode.gain.value = volume;
            }
            document.getElementById('volume-value').textContent = Math.round(volume * 100);
        }

        function playSound(type) {
            if (!audioContext) initAudio();
            if (player.volume === 0) return;
            
            const now = performance.now();
            const gainNode = audioContext.createGain();
            const oscillator = audioContext.createOscillator();
            
            gainNode.connect(masterGainNode);
            
            switch(type) {
                case 'shoot':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'player_hit':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'elimination':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(659.25, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.4 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'reload':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    
                    setTimeout(() => {
                        if (!audioContext) return;
                        const clickOsc = audioContext.createOscillator();
                        const clickGain = audioContext.createGain();
                        clickOsc.type = 'square';
                        clickOsc.frequency.setValueAtTime(150, audioContext.currentTime);
                        clickGain.gain.setValueAtTime(0.15 * player.volume, audioContext.currentTime);
                        clickGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                        clickOsc.connect(clickGain);
                        clickGain.connect(masterGainNode);
                        clickOsc.start();
                        clickOsc.stop(audioContext.currentTime + 0.05);
                    }, 150);
                    break;
                    
                case 'victory':
                    const notes = [523.25, 659.25, 783.99, 1046.50];
                    notes.forEach((freq, i) => {
                        setTimeout(() => {
                            if (!audioContext) return;
                            const noteOsc = audioContext.createOscillator();
                            const noteGain = audioContext.createGain();
                            noteOsc.type = 'sine';
                            noteOsc.frequency.setValueAtTime(freq, audioContext.currentTime);
                            noteGain.gain.setValueAtTime(0.3 * player.volume, audioContext.currentTime);
                            noteGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            noteOsc.connect(noteGain);
                            noteGain.connect(masterGainNode);
                            noteOsc.start();
                            noteOsc.stop(audioContext.currentTime + 0.3);
                        }, i * 200);
                    });
                    break;
                    
                case 'defeat':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(130.81, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(87.31, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.2 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'jump':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'build':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.15 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'storm_damage':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.15 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'open_chest':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(523.25, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.2 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'pickup_item':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'explosion':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(50, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.4 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'impact_hit':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1 * player.volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
            }
            
            oscillator.connect(gainNode);
        }

        // ===============================================================
        // === ENHANCED CONTROLLER VIBRATION =============================
        // ===============================================================

        function vibrateController(pattern = 'light') {
            if (!controllerConnected || !controllerVibration || !gamepad) return;
            
            let vibrationPattern;
            
            switch(pattern) {
                case 'light':
                    vibrationPattern = { duration: 100, weakMagnitude: 0.3, strongMagnitude: 0.1 };
                    break;
                case 'medium':
                    vibrationPattern = { duration: 150, weakMagnitude: 0.6, strongMagnitude: 0.3 };
                    break;
                case 'strong':
                    vibrationPattern = { duration: 200, weakMagnitude: 1.0, strongMagnitude: 0.7 };
                    break;
                case 'shoot':
                    vibrationPattern = { duration: 80, weakMagnitude: 0.4, strongMagnitude: 0.8 };
                    break;
                case 'hit':
                    vibrationPattern = { duration: 250, weakMagnitude: 0.8, strongMagnitude: 1.0 };
                    break;
                case 'reload':
                    vibrationPattern = { duration: 300, weakMagnitude: 0.2, strongMagnitude: 0.4 };
                    break;
                case 'jump':
                    vibrationPattern = { duration: 100, weakMagnitude: 0.5, strongMagnitude: 0.2 };
                    break;
                default:
                    vibrationPattern = { duration: 100, weakMagnitude: 0.3, strongMagnitude: 0.1 };
            }
            
            try {
                if (gamepad.vibrationActuator) {
                    gamepad.vibrationActuator.playEffect("dual-rumble", {
                        duration: vibrationPattern.duration,
                        weakMagnitude: vibrationPattern.weakMagnitude,
                        strongMagnitude: vibrationPattern.strongMagnitude
                    });
                }
            } catch (e) {
                console.log("Vibration not supported on this controller");
            }
        }

        function showControllerNotification() {
            const notification = document.getElementById('controller-notification');
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // ===============================================================
        // === ENHANCED VISUAL EFFECTS ===================================
        // ===============================================================

        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.animation = 'none';
            hitMarker.style.opacity = '0';
            void hitMarker.offsetWidth;
            hitMarker.style.animation = 'hitMarker 0.3s forwards';
        }

        function createMuzzleFlash(position, direction) {
            const flash = document.createElement('div');
            flash.className = 'muzzle-flash';
            
            const worldPoint = position.clone().project(camera);
            const x = (worldPoint.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-worldPoint.y * 0.5 + 0.5) * window.innerHeight;
            
            flash.style.left = `${x}px`;
            flash.style.top = `${y}px`;
            
            document.getElementById('ui-layer').appendChild(flash);
            
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 150);
        }

        function createBulletTrail(startPos, endPos) {
            const trail = document.createElement('div');
            trail.className = 'bullet-trail';
            
            const startWorld = startPos.clone().project(camera);
            const endWorld = endPos.clone().project(camera);
            
            const x1 = (startWorld.x * 0.5 + 0.5) * window.innerWidth;
            const y1 = (-startWorld.y * 0.5 + 0.5) * window.innerHeight;
            const x2 = (endWorld.x * 0.5 + 0.5) * window.innerWidth;
            const y2 = (-endWorld.y * 0.5 + 0.5) * window.innerHeight;
            
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            trail.style.left = `${x1}px`;
            trail.style.top = `${y1}px`;
            trail.style.width = `${length}px`;
            trail.style.transform = `rotate(${angle}deg)`;
            trail.style.transformOrigin = '0 0';
            
            document.getElementById('ui-layer').appendChild(trail);
            
            setTimeout(() => {
                if (trail.parentNode) {
                    trail.parentNode.removeChild(trail);
                }
            }, 250);
        }

        function createImpactEffect(position, isHeadshot = false) {
            const effect = document.createElement('div');
            effect.className = isHeadshot ? 'blood-effect' : 'impact-effect';
            
            const worldPoint = position.clone().project(camera);
            const x = (worldPoint.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-worldPoint.y * 0.5 + 0.5) * window.innerHeight;
            
            effect.style.left = `${x}px`;
            effect.style.top = `${y}px`;
            
            document.getElementById('ui-layer').appendChild(effect);
            
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, isHeadshot ? 500 : 400);
        }

        // ===============================================================
        // === ENHANCED LEVELING SYSTEM ==================================
        // ===============================================================

        function loadLevelData() {
            const savedLevel = localStorage.getItem('playerLevel');
            const savedPoints = localStorage.getItem('playerPoints');
            
            if (savedLevel && savedPoints) {
                player.level = parseInt(savedLevel);
                player.totalPoints = parseInt(savedPoints);
                player.pointsToNextLevel = BASE_POINTS_PER_LEVEL * player.level;
                
                updateLevelDisplay();
            }
        }

        function saveLevelData() {
            localStorage.setItem('playerLevel', player.level);
            localStorage.setItem('playerPoints', player.totalPoints);
        }

        function updateLevelDisplay() {
            const pointsInCurrentLevel = player.totalPoints % (BASE_POINTS_PER_LEVEL * player.level);
            const progress = (pointsInCurrentLevel / (BASE_POINTS_PER_LEVEL * player.level)) * 100;
            
            document.getElementById('current-level').textContent = player.level;
            document.getElementById('current-points').textContent = pointsInCurrentLevel;
            document.getElementById('next-level-points').textContent = BASE_POINTS_PER_LEVEL * player.level;
            document.getElementById('level-progress').style.width = `${progress}%`;
            
            const pointsToNext = (BASE_POINTS_PER_LEVEL * player.level) - pointsInCurrentLevel;
            document.getElementById('points-to-next').textContent = `${pointsToNext} Points to Next Level`;
        }

        function calculateMatchPoints(placement) {
            let points = 0;
            
            points += player.eliminations * POINTS_PER_KILL;
            points += player.chestsOpened * POINTS_PER_CHEST;
            points += player.legendaryItemsHeld * POINTS_PER_LEGENDARY;
            
            if (placement <= 2) {
                points += POINTS_TOP_2;
            } else if (placement <= 10) {
                points += POINTS_TOP_10;
            }
            
            player.matchPoints = points;
            player.totalPoints += points;
            
            if (player.shotsFired > 0) {
                player.accuracy = Math.round((player.shotsHit / player.shotsFired) * 100);
            }
            
            const requiredForNextLevel = BASE_POINTS_PER_LEVEL * player.level;
            if (player.totalPoints >= requiredForNextLevel) {
                player.level++;
            }
            
            saveLevelData();
            return points;
        }

        function showLevelStatsScreen(placement) {
            const points = calculateMatchPoints(placement);
            const pointsInCurrentLevel = player.totalPoints % (BASE_POINTS_PER_LEVEL * player.level);
            const progress = (pointsInCurrentLevel / (BASE_POINTS_PER_LEVEL * player.level)) * 100;
            const totalBots = BOT_COUNT + 1;
            const placementText = placement === 1 ? '1st (Victory Royale!)' : 
                                 placement === 2 ? '2nd' : 
                                 placement === 3 ? '3rd' : 
                                 `${placement}th`;
            
            document.getElementById('match-kills').textContent = player.eliminations;
            document.getElementById('match-chests').textContent = player.chestsOpened;
            document.getElementById('match-legendarys').textContent = player.legendaryItemsHeld;
            document.getElementById('match-placement').textContent = placementText;
            document.getElementById('match-points').textContent = points;
            document.getElementById('match-level').textContent = player.level;
            document.getElementById('match-progress').textContent = pointsInCurrentLevel;
            document.getElementById('match-next-level').textContent = BASE_POINTS_PER_LEVEL * player.level;
            document.getElementById('match-progress-bar').style.width = `${progress}%`;
            
            document.getElementById('level-stats-screen').style.display = 'flex';
        }

        // ===============================================================
        // === ENHANCED UTILITY FUNCTIONS ================================
        // ===============================================================

        function getTerrainHeight(x, z) {
            // ENHANCED: More realistic terrain with varied grass patterns
            const scale1 = 0.012;
            const scale2 = 0.035;
            const scale3 = 0.0015;
            
            // Base terrain with mountains
            let y = (Math.sin(x * scale1) * 28 + Math.cos(z * scale1) * 28) + 
                    (Math.sin(x * scale2 + z * scale2) * 12);
            
            // Realistic mountain ranges
            const mountain1 = Math.exp(-((x + 200)*(x + 200) + (z + 200)*(z + 200)) / 28000) * 55;
            const mountain2 = Math.exp(-((x - 200)*(x - 200) + (z - 200)*(z - 200)) / 38000) * 65;
            const mountain3 = Math.exp(-((x + 300)*(x + 300) + (z - 300)*(z - 300)) / 45000) * 45;
            
            y += mountain1 + mountain2 + mountain3;
            
            // River valleys
            const river1 = Math.sin(x * scale3) * 18;
            const river2 = Math.cos(z * scale3) * 18;
            y -= Math.abs(river1) * 0.35 + Math.abs(river2) * 0.35;
            
            // Rolling hills
            const hillScale = 0.025;
            y += Math.sin(x * hillScale) * Math.cos(z * hillScale) * 8;
            
            // Smooth edges for storm
            const dist = Math.sqrt(x*x + z*z);
            if (dist > WORLD_SIZE * 0.45) y += (dist - WORLD_SIZE * 0.45) * 0.35;
            
            return y;
        }
        
        function createBox(x, y, z, w, h, d, col, type='solid') {
            const geometry = new THREE.BoxGeometry(w, h, d);
            let material;
            
            // ENHANCED: Better materials based on graphics quality
            if (player.graphicsQuality === 'ultra') {
                material = new THREE.MeshStandardMaterial({
                    color: col,
                    roughness: 0.7,
                    metalness: 0.1
                });
            } else {
                material = new THREE.MeshLambertMaterial({ color: col });
            }
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            
            if (player.graphicsQuality !== 'low') {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
            }
            
            scene.add(mesh);
            objects.push(mesh); 
            buildings.push({ mesh: mesh, type: type, health: 100 });
            return mesh;
        }

        function createDoor(x, y, z, rotationY) {
            const doorGeo = new THREE.BoxGeometry(1.5, 3, 0.1);
            const doorMat = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513, 
                transparent: true, 
                opacity: 0.8,
                roughness: 0.8
            });
            const doorMesh = new THREE.Mesh(doorGeo, doorMat);
            doorMesh.position.set(x, y + 1.5, z);
            doorMesh.rotation.y = rotationY;
            
            if (player.graphicsQuality !== 'low') {
                doorMesh.castShadow = true;
                doorMesh.receiveShadow = true;
            }
            
            scene.add(doorMesh);
            
            objects.push(doorMesh); 
            doors.push({ mesh: doorMesh, open: false, initialRotation: rotationY });
            
            return doorMesh;
        }
        
        function checkWin() {
            if (bots.length === 0 && !player.dead) {
                handleGameOver(true);
            }
        }
        
        function handleGameOver(win) {
            player.dead = true;
            if (controls && controls.isLocked) controls.unlock(); 
            
            const placement = win ? 1 : bots.length + 1;
            
            if (win) {
                createVictoryParticles();
                document.getElementById('victory-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('victory-overlay').style.display = 'flex';
                playSound('victory');
                
                setTimeout(() => {
                    document.getElementById('victory-overlay').style.display = 'none';
                    showLevelStatsScreen(placement);
                }, 5000);
            } else {
                createEliminatedParticles();
                document.getElementById('go-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('game-over').style.display = 'flex';
                playSound('defeat');
                
                setTimeout(() => {
                    document.getElementById('game-over').style.display = 'none';
                    showLevelStatsScreen(placement);
                }, 3000);
            }
        }
        
        function createVictoryParticles() {
            const container = document.getElementById('victory-particles');
            container.innerHTML = '';
            for(let i = 0; i < 120; i++) {
                const particle = document.createElement('div');
                particle.className = 'victory-particle';
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 5}s`;
                particle.style.animationDuration = `${Math.random() * 3 + 5}s`;
                particle.style.opacity = Math.random() * 0.6 + 0.4;
                container.appendChild(particle);
            }
        }
        
        function createEliminatedParticles() {
            const container = document.getElementById('eliminated-particles');
            container.innerHTML = '';
            for(let i = 0; i < 100; i++) {
                const particle = document.createElement('div');
                particle.className = 'eliminated-particle';
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 3}s`;
                particle.style.animationDuration = `${Math.random() * 2 + 3}s`;
                particle.style.opacity = Math.random() * 0.5 + 0.3;
                container.appendChild(particle);
            }
        }

        function toggleADS(bool) {
            player.ads = bool;
            const item = player.inventory[player.slot];
            const isClassicScope = item && item.category === 'weapon' && item.stats.scope === 'classic';
            const isRedDotScope = item && item.category === 'weapon' && item.stats.scope === 'red_dot';
            const isHoloScope = item && item.category === 'weapon' && item.stats.scope === 'holo_twister';
            
            const scopeOverlay = document.getElementById('scope-overlay');
            const redDotScope = document.getElementById('red-dot-scope');
            const crosshair = document.getElementById('crosshair');

            scopeOverlay.style.display = 'none';
            redDotScope.style.display = 'none';
            
            const isScoped = isClassicScope || isRedDotScope || isHoloScope;
            
            if (bool && isScoped) {
                crosshair.style.display = 'none';
                if (isClassicScope) {
                    scopeOverlay.style.display = 'block';
                    camera.fov = 8;
                } else if (isRedDotScope || isHoloScope) {
                    redDotScope.style.display = 'block';
                    camera.fov = (item.stats.name === WEAPONS_BASE.FALCON_SNIPER.name) ? 18 : 30;
                }
            } else {
                const isSniperFamily = item && item.category === 'weapon' && (item.stats.scope === 'classic' || item.stats.scope === 'red_dot' || item.stats.scope === 'holo_twister');
                crosshair.style.display = (isSniperFamily && !bool) ? 'none' : 'block';
                camera.fov = 75;
            }

            camera.updateProjectionMatrix();
        }

        function showDamage(amount, position, type = 'body', isHeadshot = false) {
            const dmgNumber = document.createElement('div');
            dmgNumber.className = 'dmg-number' + (isHeadshot ? ' headshot' : '') + (type === 'storm' ? ' storm' : '');
            dmgNumber.innerText = Math.round(amount);
            
            const worldPoint = position.clone().project(camera);
            
            const x = (worldPoint.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-worldPoint.y * 0.5 + 0.5) * window.innerHeight;
            
            dmgNumber.style.left = `${x}px`;
            dmgNumber.style.top = `${y}px`;
            
            document.getElementById('ui-layer').appendChild(dmgNumber);
            
            setTimeout(() => {
                dmgNumber.remove();
            }, 1500);
        }

        function reload() {
            const item = player.inventory[player.slot];
            if (!item || item.category !== 'weapon' || item.stats.currentMag === item.stats.mag || player.isReloading) return;
            
            if (player.isHealing) finishHealing();
            
            playSound('reload');
            if (controllerConnected) vibrateController('reload');

            player.isReloading = true;
            document.getElementById('reload-indicator').style.display = 'block';
            updateUI();

            const reloadTime = item.stats.reload * item.rarity.reload;

            setTimeout(() => {
                item.stats.currentMag = item.stats.mag;
                player.isReloading = false;
                document.getElementById('reload-indicator').style.display = 'none';
                updateUI();
            }, reloadTime);
        }

        function buildWall() {
            if (player.wood < 10) return;
            
            playSound('build');
            if (controllerConnected) vibrateController('light');

            const wallGeo = new THREE.BoxGeometry(4, 4, 0.1);
            let wallMat;
            if (player.graphicsQuality === 'ultra') {
                wallMat = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513, 
                    transparent: true, 
                    opacity: 0.8,
                    roughness: 0.9
                });
            } else {
                wallMat = new THREE.MeshLambertMaterial({ color: 0x8B4513, transparent: true, opacity: 0.8 });
            }
            const wall = new THREE.Mesh(wallGeo, wallMat);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0;
            dir.normalize();

            wall.position.copy(camera.position).add(dir.multiplyScalar(5)).setY(getTerrainHeight(camera.position.x, camera.position.z) + 2);
            wall.rotation.y = camera.rotation.y;
            
            if (player.graphicsQuality !== 'low') {
                wall.castShadow = true;
                wall.receiveShadow = true;
            }
            
            scene.add(wall);
            
            objects.push(wall);
            buildings.push({ mesh: wall, type: 'indestructible_wood', health: Infinity }); 
            player.wood -= 10;
            updateUI();
        }

        // ===============================================================
        // === ENHANCED STORM LOGIC ======================================
        // ===============================================================

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function startStormTimer() {
            if (stormTimerInterval) clearInterval(stormTimerInterval);

            const nextPhase = STORM_PHASES[stormPhase];
            if (!nextPhase) {
                document.getElementById('storm-status').innerText = "FINAL";
                document.getElementById('storm-timer').innerText = "00:00";
                return;
            }
            
            stormPhaseTimer = nextPhase.time;
            document.getElementById('storm-status').innerText = nextPhase.status;
            stormDamageRate = nextPhase.damage; 
            
            const startRadius = stormRadius;
            const endRadius = nextPhase.radius;
            const startTime = performance.now();

            stormTimerInterval = setInterval(() => {
                if (player.dead) {
                    clearInterval(stormTimerInterval);
                    return;
                }
                
                stormPhaseTimer -= 1;
                document.getElementById('storm-timer').innerText = formatTime(stormPhaseTimer);
                
                if (nextPhase.status === "Shrink" || nextPhase.status === "Deathmatch") {
                    const elapsed = performance.now() - startTime;
                    const duration = nextPhase.time * 1000;
                    const t = Math.min(1, elapsed / duration);
                    stormRadius = startRadius + (endRadius - startRadius) * t;
                    stormActive = true; 
                } else if (nextPhase.status === "Hold") {
                    stormActive = true;
                } else if (nextPhase.status === "Wait") {
                    stormActive = false;
                }

                if (stormPhaseTimer <= 0) {
                    clearInterval(stormTimerInterval);
                    stormPhase++;
                    startStormTimer();
                }
            }, 1000);
        }
        
        function updateStorm(now) {
            const playerPos2D = new THREE.Vector2(camera.position.x, camera.position.z);
            const distToStorm = playerPos2D.distanceTo(stormCenter);
            const inStorm = stormActive && distToStorm > stormRadius;

            document.getElementById('storm-overlay').classList.toggle('in-storm', inStorm);

            if (inStorm && stormDamageRate > 0) {
                if (now - player.lastStormDamage > 1000) {
                    takeDamage(stormDamageRate, camera.position, 'storm'); 
                    player.lastStormDamage = now;
                    playSound('storm_damage');
                }
            } 

            bots.forEach(bot => {
                const botPos2D = new THREE.Vector2(bot.mesh.position.x, bot.mesh.position.z);
                const botDistToStorm = botPos2D.distanceTo(stormCenter);
                const botInStorm = stormActive && botDistToStorm > stormRadius;
                
                if (botInStorm && BOT_STORM_DAMAGE > 0) {
                     if (now - (bot.lastStormDamage || 0) > 1000) {
                        bot.health = Math.max(0, bot.health - BOT_STORM_DAMAGE); 
                        bot.lastStormDamage = now;
                        showDamage(BOT_STORM_DAMAGE, bot.mesh.position.clone().setY(bot.mesh.position.y + 1), 'storm');
                        
                        if (bot.health <= 0) {
                            scene.remove(bot.mesh);
                            bots = bots.filter(b => b !== bot);
                            player.wood += 50;
                            checkWin();
                        }
                    }
                }
            });
        }

        // ===============================================================
        // === ENHANCED WORLD GENERATION WITH SUN ========================
        // ===============================================================

        function createSun() {
            // ENHANCED: Create a realistic sun far away in the sky
            const sunGeometry = new THREE.SphereGeometry(50, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                emissive: 0xff8c00,
                emissiveIntensity: 2.0
            });
            
            sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.set(0, 500, -1000); // Far away in the sky
            scene.add(sunMesh);
            
            // Add sun glow with lens flare effect
            const sunLight = new THREE.PointLight(0xffd700, 2, 2000);
            sunLight.position.copy(sunMesh.position);
            scene.add(sunLight);
            
            // Add ambient light from sun
            const ambientSunLight = new THREE.AmbientLight(0xffd700, 0.3);
            scene.add(ambientSunLight);
        }

        function generateTerrain() {
            const size = WORLD_SIZE;
            const segments = player.graphicsQuality === 'ultra' ? 256 : 
                           player.graphicsQuality === 'high' ? 192 : 
                           player.graphicsQuality === 'medium' ? 128 : 64;
            
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            geometry.rotateX(-Math.PI / 2);

            const position = geometry.attributes.position;
            for (let i = 0; i < position.count; i++) {
                const x = position.getX(i);
                const z = position.getZ(i);
                const y = getTerrainHeight(x, z);
                position.setY(i, y);
            }
            position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            // ENHANCED: Realistic grass with texture-like appearance
            let grassMat;
            if (player.graphicsQuality === 'ultra') {
                grassMat = new THREE.MeshStandardMaterial({ 
                    color: 0x3a8b3a,
                    roughness: 0.9,
                    metalness: 0.0
                });
            } else if (player.graphicsQuality === 'high') {
                grassMat = new THREE.MeshLambertMaterial({ 
                    color: 0x3a8b3a
                });
            } else {
                grassMat = new THREE.MeshBasicMaterial({ color: 0x3a8b3a });
            }
            
            const terrain = new THREE.Mesh(geometry, grassMat);
            
            if (player.graphicsQuality !== 'low') {
                terrain.receiveShadow = true;
                terrain.castShadow = true;
            }
            
            scene.add(terrain);
            objects.push(terrain); 
            
            // Add realistic snow on mountains
            for(let i = 0; i < 6; i++) {
                const snowX = (Math.random() - 0.5) * 400;
                const snowZ = (Math.random() - 0.5) * 400;
                const snowH = getTerrainHeight(snowX, snowZ);
                if (snowH > 35) {
                    const snowGeo = new THREE.SphereGeometry(18 + Math.random() * 25, 20, 20);
                    const snowMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        roughness: 0.8,
                        metalness: 0.0
                    });
                    const snow = new THREE.Mesh(snowGeo, snowMat);
                    snow.position.set(snowX, snowH + 12, snowZ);
                    
                    if (player.graphicsQuality !== 'low') {
                        snow.castShadow = true;
                        snow.receiveShadow = true;
                    }
                    
                    scene.add(snow);
                    objects.push(snow);
                }
            }
            
            // Realistic water areas
            for(let i = 0; i < 4; i++) {
                const waterX = (Math.random() - 0.5) * 300;
                const waterZ = (Math.random() - 0.5) * 300;
                const waterH = getTerrainHeight(waterX, waterZ) - 6;
                const waterGeo = new THREE.PlaneGeometry(90, 25);
                waterGeo.rotateX(-Math.PI / 2);
                
                let waterMat;
                if (player.graphicsQuality === 'ultra') {
                    waterMat = new THREE.MeshStandardMaterial({ 
                        color: 0x1e90ff,
                        transparent: true,
                        opacity: 0.7,
                        roughness: 0.1,
                        metalness: 0.9
                    });
                } else {
                    waterMat = new THREE.MeshBasicMaterial({ 
                        color: 0x1e90ff,
                        transparent: true,
                        opacity: 0.6
                    });
                }
                
                const water = new THREE.Mesh(waterGeo, waterMat);
                water.position.set(waterX, waterH, waterZ);
                scene.add(water);
                objects.push(water);
            }
        }

        function createTower(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+10, z, 5, 20, 5, 0x999999);
            createBox(x, h+21, z, 7, 2, 7, 0xAAAAAA);
            spawnChest(x, h+23, z); 
        }
        
        function createBuilding(x, z, size, height, depth, color, rotation) {
            const h = getTerrainHeight(x, z);
            const mesh = createBox(x, h + height/2, z, size, height, depth, color);
            mesh.rotation.y = rotation;
            spawnChest(x+size/4, h+1, z+depth/4); 
        }
        
        function createWoodHouse(x, z, size, height, depth) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+height/2, z, size, height, depth, 0x8B4513);
            createBox(x, h+height+1, z, size+2, 2, depth+2, 0x555555); 
            spawnChest(x, h+1, z); 
        }
        
        function createTree(x, z) {
            const h = getTerrainHeight(x, z);
            createBox(x, h+2, z, 0.5, 4, 0.5, 0x8B4513, 'tree'); 
            
            // ENHANCED: Better tree foliage
            const foliageGeo = new THREE.SphereGeometry(3, 16, 16);
            const foliageMat = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.8
            });
            const foliage = new THREE.Mesh(foliageGeo, foliageMat);
            foliage.position.set(x, h+5, z);
            
            if (player.graphicsQuality !== 'low') {
                foliage.castShadow = true;
                foliage.receiveShadow = true;
            }
            
            scene.add(foliage);
            objects.push(foliage);
            buildings.push({ mesh: foliage, type: 'tree', health: 100 });
        }

        function generatePOIs() {
            // Create sun in the sky
            createSun();
            
            // Generate various POIs
            for(let i=0; i<4; i++) {
                const x = (Math.random()-0.5)*80;
                const z = (Math.random()-0.5)*80;
                createTower(x, z);
            }

            // Mountain bases
            createBuilding(-200, -200, 20, 10, 30, 0x444444, Math.PI/2);
            createWoodHouse(-200, 200, 10, 12, 15); 
            createBuilding(250, 250, 15, 8, 15, 0xFF7F50, 0); 
            
            // River area structures
            createBox(-250, getTerrainHeight(-250, 250)+0.1, 250, 50, 0.2, 50, 0x00BFFF); 
            createBox(-250, getTerrainHeight(-250, -250)-5, -250, 30, 10, 30, 0x696969); 
            createWoodHouse(-280, 0, 10, 8, 10); 
            
            // Snowy mountain structures
            createBox(280, getTerrainHeight(280, 0)+5, 0, 10, 10, 10, 0xFF6347); 
            createBuilding(50, 200, 12, 6, 12, 0x808080, Math.PI/4); 
            createWoodHouse(150, -100, 20, 5, 20); 
            
            // Cliff structures
            createBox(-150, getTerrainHeight(-150, 100)+10, 100, 2, 20, 10, 0x000000); 
            createBox(100, getTerrainHeight(100, -250)-10, -250, 40, 20, 40, 0x222222); 
            createBox(-100, getTerrainHeight(-100, -300)+0.1, -300, 30, 0.2, 30, 0x00FF7F); 
            
            // High altitude structures
            createBuilding(300, 150, 18, 10, 18, 0x9370DB, -Math.PI/4); 
            createBox(0, getTerrainHeight(0, 300), 300, 40, 0.5, 40, 0xADD8E6); 
            createBox(300, getTerrainHeight(300, -300)+15, -300, 8, 30, 8, 0xEEEEEE); 
            createBox(-300, getTerrainHeight(-300, 150)+0.5, 150, 25, 1, 25, 0xF4A460); 
            createWoodHouse(200, 0, 20, 10, 10); 

            // Additional POIs
            for(let i=0; i<3; i++) {
                for(let j=0; j<3; j++) {
                    const x = -350 + (i*25);
                    const z = -250 + (j*25);
                    createBox(x, getTerrainHeight(x, z)+0.5, z, 8, 6, 8, 0xD2B48C);
                }
            }
            createBox(-325, getTerrainHeight(-325, -225)+10, -225, 5, 20, 5, 0x8B7355);
            
            // Desert-like area
            createBox(350, getTerrainHeight(350, -350)+0.1, -350, 60, 0.5, 60, 0xFF6B6B);
            for(let i=0; i<4; i++) {
                const angle = (i*Math.PI*2)/4;
                const x = 350 + Math.cos(angle)*30;
                const z = -350 + Math.sin(angle)*30;
                createBuilding(x, z, 10, 8, 10, 0xFFD166, angle);
            }
            createBox(350, getTerrainHeight(350, -350)+15, -350, 5, 30, 5, 0x06D6A0);
            
            // Forest area with many trees
            for(let i=0; i<15; i++) {
                const x = 400 + (Math.random()-0.5)*60;
                const z = 150 + (Math.random()-0.5)*60;
                createTree(x, z);
            }
            createBuilding(400, 150, 25, 12, 25, 0x8B4513, 0);
            createBox(380, getTerrainHeight(380, 170)+6, 170, 20, 2, 20, 0xA0522D);
            
            // Lake area with houses
            createBox(-400, getTerrainHeight(-400, 400)+0.1, 400, 80, 0.5, 60, 0x1E90FF);
            for(let i=0; i<6; i++) {
                const x = -430 + (i*20);
                createWoodHouse(x, 380, 8, 7, 8);
            }
            createBox(-420, getTerrainHeight(-420, 420)+12, 420, 4, 24, 4, 0x708090);
            
            // Underground bunker area
            createBox(0, getTerrainHeight(0, -400)-10, -400, 50, 20, 50, 0x696969);
            createBuilding(20, -380, 15, 8, 15, 0x333333, Math.PI/4);
            createBuilding(-20, -420, 15, 8, 15, 0x333333, -Math.PI/4);
            createBox(0, getTerrainHeight(0, -400)+5, -400, 10, 10, 10, 0xFFD700);

            // More trees throughout map
            for(let i=0; i<60; i++) {
                const x = (Math.random()-0.5)*400;
                const z = (Math.random()-0.5)*400;
                createTree(x, z);
            }
        }

        function spawnCars() {
            for(let i=0; i<4; i++) {
                const x = (Math.random()-0.5)*200;
                const z = (Math.random()-0.5)*200;
                const h = getTerrainHeight(x, z);
                
                const carGroup = new THREE.Group();
                
                let bodyMat;
                if (player.graphicsQuality === 'ultra') {
                    bodyMat = new THREE.MeshStandardMaterial({
                        color: Math.random() * 0xffffff,
                        roughness: 0.5,
                        metalness: 0.5
                    });
                } else {
                    bodyMat = new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff});
                }
                
                const body = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 5), bodyMat);
                body.position.y = 1;
                carGroup.add(body);
                
                carGroup.position.set(x, h, z); 
                
                if (player.graphicsQuality !== 'low') {
                    body.castShadow = true;
                    body.receiveShadow = true;
                }
                
                scene.add(carGroup);
                
                cars.push({ mesh: carGroup, speed: 0, rotationY: carGroup.rotation.y, driving: false, raycaster: new THREE.Raycaster() });
            }
        }

        function spawnChest(x, y, z) {
            let chestMat;
            if (player.graphicsQuality === 'ultra') {
                chestMat = new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    roughness: 0.4,
                    metalness: 0.6
                });
            } else {
                chestMat = new THREE.MeshLambertMaterial({color: 0xFFD700});
            }
            
            const chest = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1), chestMat);
            chest.position.set(x, y, z);
            
            if (player.graphicsQuality !== 'low') {
                chest.castShadow = true;
                chest.receiveShadow = true;
            }
            
            scene.add(chest);
            chests.push(chest);
        }
        
        function createBotMesh(x, y, z) {
            const group = new THREE.Group();
            
            // ENHANCED: More detailed bot mesh
            let headMat, bodyMat, legMat;
            
            if (player.graphicsQuality === 'ultra') {
                headMat = new THREE.MeshStandardMaterial({color: 0xFFA07A, roughness: 0.8});
                bodyMat = new THREE.MeshStandardMaterial({color: 0x007bff, roughness: 0.7});
                legMat = new THREE.MeshStandardMaterial({color: 0x444444, roughness: 0.9});
            } else {
                headMat = new THREE.MeshLambertMaterial({color: 0xFFA07A});
                bodyMat = new THREE.MeshLambertMaterial({color: 0x007bff});
                legMat = new THREE.MeshLambertMaterial({color: 0x444444});
            }
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), headMat);
            head.position.y = 2.4; 
            group.add(head);

            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.5), bodyMat);
            body.position.y = 1.6;
            group.add(body);

            const legGeo = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const legL = new THREE.Mesh(legGeo, legMat);
            legL.position.set(-0.3, 0.6, 0);
            const legR = new THREE.Mesh(legGeo, legMat);
            legR.position.set(0.3, 0.6, 0);
            group.add(legL);
            group.add(legR);

            group.position.set(x, y, z);
            
            if (player.graphicsQuality !== 'low') {
                head.castShadow = true;
                head.receiveShadow = true;
                body.castShadow = true;
                body.receiveShadow = true;
                legL.castShadow = true;
                legL.receiveShadow = true;
                legR.castShadow = true;
                legR.receiveShadow = true;
            }
            
            return group;
        }

        function spawnBots() {
            // ENHANCED: More varied bot AI with realistic behaviors
            const botTypes = [
                { aggression: 0.85, accuracy: 0.65, range: 70, speed: 1.3, name: "Aggressor" },
                { aggression: 0.55, accuracy: 0.85, range: 100, speed: 1.0, name: "Sniper" },
                { aggression: 0.95, accuracy: 0.45, range: 45, speed: 1.6, name: "Rusher" },
                { aggression: 0.35, accuracy: 0.75, range: 120, speed: 0.9, name: "Defender" },
                { aggression: 0.70, accuracy: 0.70, range: 80, speed: 1.2, name: "Soldier" },
                { aggression: 0.60, accuracy: 0.80, range: 90, speed: 1.1, name: "Marksman" }
            ];
            
            for(let i=0; i<BOT_COUNT; i++) { 
                let x, z;
                do {
                    x = (Math.random()-0.5)*WORLD_SIZE*0.8;
                    z = (Math.random()-0.5)*WORLD_SIZE*0.8;
                } while (Math.abs(x) < 100 && Math.abs(z) < 100); 

                const h = getTerrainHeight(x, z);
                
                const mesh = createBotMesh(x, h + 1, z);
                scene.add(mesh);
                
                const randomWeaponKeys = ['RFAR', 'STINGER', 'DRUM_SMG', 'PISTOL', 'BURST_SMG', 'SCOPED_SMG'];
                const botWeaponKey = randomWeaponKeys[Math.floor(Math.random() * randomWeaponKeys.length)];
                const botWeapon = createWeaponItem(botWeaponKey, 'COMMON');
                botWeapon.stats.currentMag = botWeapon.stats.mag; 
                
                const botType = botTypes[Math.floor(Math.random() * botTypes.length)];
                
                bots.push({ 
                    mesh: mesh, 
                    health: 200, 
                    shield: 100, 
                    target: null, 
                    lastShot: 0, 
                    weapon: botWeapon, 
                    lastMove: performance.now(),
                    velocity: new THREE.Vector3(0, 0, 0),
                    lastStormDamage: 0,
                    moveCooldown: 0, 
                    currentDirection: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(),
                    attackRange: botType.range,
                    isAggressive: Math.random() < botType.aggression,
                    accuracy: botType.accuracy,
                    moveSpeed: botType.speed,
                    patrolPoints: [],
                    currentPatrolIndex: 0,
                    lastTargetUpdate: 0,
                    isTakingCover: false,
                    coverTimer: 0,
                    canJump: Math.random() < 0.4,
                    canStrafe: Math.random() < 0.6,
                    strafeDirection: Math.random() < 0.5 ? 1 : -1,
                    strafeTimer: 0,
                    type: botType.name,
                    // ENHANCED: Bot now can damage player within 50 meters
                    canDamagePlayer: true,
                    lastPlayerDamageCheck: 0,
                    damageCooldown: 1000 // 1 second between damage checks
                });
                
                // Generate patrol points
                for(let j=0; j<4; j++) {
                    bots[i].patrolPoints.push(new THREE.Vector3(
                        x + (Math.random()-0.5)*60,
                        h,
                        z + (Math.random()-0.5)*60
                    ));
                }
            }
        }

        // ===============================================================
        // === ENHANCED ITEM & HEALING LOGIC =============================
        // ===============================================================

        function useHealingItem() {
            const item = player.inventory[player.slot];
            
            if (player.isHealing) {
                if (!player.healingItem.continuous) finishHealing();
                return;
            }

            if (!item || item.category !== 'consumable' || item.count <= 0) return;
            
            if (item.instant) {
                 if (item.type === 'shield' && (player.shield < item.max || player.overshield < OVER_SHIELD_MAX)) {
                    if(player.shield < 100) {
                        player.shield = Math.min(item.max, player.shield + item.val);
                    } else if (player.overshield < OVER_SHIELD_MAX) {
                        player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + item.val);
                    } else {
                        return; 
                    }
                    item.count -= 1; 
                    if (item.count <= 0) player.inventory[player.slot] = null;
                    updateUI();
                    playSound('pickup_item');
                    if (player.overshield < OVER_SHIELD_MAX) {
                        player.lastOvershieldDamage = performance.now();
                        player.lastOvershieldBreak = performance.now();
                    }
                    return;
                }
            }

            let canUse = false;
            if (item.type === 'shield' && (player.shield < item.max || player.overshield < OVER_SHIELD_MAX)) canUse = true;
            if (item.type === 'health' && player.health < item.max) canUse = true;
            if (item.type === 'continuous') canUse = (player.health < 100 || player.shield < 100 || player.overshield < OVER_SHIELD_MAX);

            if (canUse) {
                player.isHealing = true;
                player.healingItem = item;
                player.healingStartTime = performance.now();
                document.getElementById('healing-progress').style.display = 'block';
                document.getElementById('healing-text').innerText = `USING ${item.name.toUpperCase()}...`;
                updateUI();
                
                if (!item.continuous && !item.instant) {
                    playSound('use_timed_start');
                    setTimeout(() => {
                        if(player.isHealing && player.healingItem === item) {
                            applyHealing(item);
                            finishHealing();
                            playSound('use_timed_finish');
                        }
                    }, item.time);
                } else if (item.continuous) {
                    playSound('use_chug_start');
                }
            }
        }
        
        function applyHealing(item) {
            if (item.type === 'shield') {
                player.shield = Math.min(item.max, player.shield + item.val); 
            } else if (item.type === 'health') {
                player.health = Math.min(item.max, player.health + item.val);
            } 
            
            item.count -= 1;
            if (item.count <= 0) {
                const slotIndex = player.inventory.findIndex(i => i === item);
                if (slotIndex !== -1) player.inventory[slotIndex] = null;
            }
            updateUI();
        }
        
        function applyContinuousHealing(item, dt) {
            const timeElapsed = performance.now() - player.healingStartTime;
            const percentage = Math.min(1, timeElapsed / item.time);
            document.getElementById('healing-bar').style.width = `${percentage * 100}%`;
            
            const interval = 1000; 
            if (!player.lastHealTick || (performance.now() - player.lastHealTick) >= interval) {
                if(player.overshield < OVER_SHIELD_MAX) {
                    player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + item.shieldVal); 
                    player.lastOvershieldBreak = performance.now();
                } else if(player.shield < 100) {
                    player.shield = Math.min(100, player.shield + item.shieldVal); 
                } else if (player.health < 100) {
                    player.health = Math.min(100, player.health + item.val);
                }
                updateUI();
                player.lastHealTick = performance.now();
            }

            if (timeElapsed >= item.time || (player.health === 100 && player.shield === 100 && player.overshield === OVER_SHIELD_MAX)) {
                finishHealing();
                playSound('use_chug_finish');
            }
        }

        function finishHealing() {
            if (!player.isHealing) return; 

            player.isHealing = false;
            
            const item = player.healingItem;
            if (item && item.continuous) {
                 item.count -= 1;
                 if (item.count <= 0) {
                    const slotIndex = player.inventory.findIndex(i => i === item);
                    if (slotIndex !== -1) player.inventory[slotIndex] = null;
                 }
            }

            player.healingItem = null;
            player.lastHealTick = 0;
            document.getElementById('healing-progress').style.display = 'none';
            
            updateUI();
        }

        function tryInteract() {
            const pos = camera.position;
            
            // Check Doors
            for(let door of doors) {
                if(pos.distanceTo(door.mesh.position) < 5) {
                    door.open = !door.open;
                    const rotation = door.open ? door.initialRotation + Math.PI / 2 : door.initialRotation;
                    door.mesh.rotation.y = rotation;
                    
                    const shiftDir = new THREE.Vector3();
                    shiftDir.setFromEuler(new THREE.Euler(0, door.initialRotation + Math.PI / 4, 0));
                    door.mesh.position.sub(shiftDir.multiplyScalar(0.75)); 
                    playSound('open_chest');
                    if (player.isHealing) finishHealing();
                    return;
                }
            }

            // Check Cars
            for(let c of cars) {
                if(pos.distanceTo(c.mesh.position) < 5) {
                    if(player.vehicle) {
                        player.vehicle.driving = false;
                        player.vehicle = null;
                        camera.position.y += 2; 
                        camera.position.x = c.mesh.position.x + 5; 
                        camera.position.z = c.mesh.position.z + 5; 
                        playSound('pickup_item');
                    } else {
                        if (player.isHealing) finishHealing();
                        player.vehicle = c;
                        c.driving = true;
                        playSound('pickup_item');
                    }
                    updateUI();
                    return;
                }
            }
            
            // Check Chests
            for(let i=chests.length-1; i>=0; i--) {
                if(pos.distanceTo(chests[i].position) < 4) {
                    const chestPos = chests[i].position.clone();
                    scene.remove(chests[i]);
                    chests.splice(i, 1);
                    
                    if (player.isHealing) finishHealing();

                    player.chestsOpened++;
                    
                    const randomWeaponKey = getRandomWeaponKey();
                    const randomRarity = getRandomRarity();
                    spawnLoot(chestPos.x + 0.5, chestPos.y, chestPos.z + 0.5, 'weapon', randomRarity, randomWeaponKey);
                    
                    if (Math.random() < 0.15) {
                        spawnLoot(chestPos.x - 0.5, chestPos.y, chestPos.z - 0.5, 'weapon', randomRarity, 'HEAVY_AR');
                    } else {
                        const randomConsumableKey = getRandomConsumableKey();
                        spawnLoot(chestPos.x - 0.5, chestPos.y, chestPos.z - 0.5, 'consumable', randomConsumableKey);
                    }
                    
                    if (Math.random() < 0.3) {
                        spawnLoot(chestPos.x, chestPos.y, chestPos.z, 'weapon', getRandomRarity(), getRandomWeaponKey());
                    }
                    
                    playSound('open_chest');
                    return;
                }
            }

            // Auto-swap without prompts
            for(let i=loot.length-1; i>=0; i--) {
                const currentLoot = loot[i];
                if(pos.distanceTo(currentLoot.mesh.position) < 4) {
                    const currentItem = player.inventory[player.slot];
                    
                    if (player.isHealing) finishHealing();

                    if (currentLoot.data.category === 'consumable') {
                        const stackSlot = player.inventory.find(item => item && item.name === currentLoot.data.name && item.count < item.maxStack);
                        if (stackSlot) {
                            stackSlot.count = Math.min(stackSlot.maxStack, stackSlot.count + currentLoot.data.count);
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            return;
                        }
                    }

                    if (currentLoot.data.rarity && currentLoot.data.rarity.color === '#ffd700') {
                        player.legendaryItemsHeld++;
                    }

                    if (currentItem) {
                        if (currentItem.category !== currentLoot.data.category || 
                            (currentLoot.data.category === 'weapon')) {
                            
                            dropItem(player.slot, currentLoot.mesh.position.clone().add(new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2)));
                            giveItem(currentLoot.data, player.slot);
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            playSound('pickup_item');
                            return;
                        }
                    } else {
                        if(giveItem(currentLoot.data, player.slot)) {
                            scene.remove(currentLoot.mesh);
                            loot.splice(i, 1);
                            updateUI();
                            playSound('pickup_item');
                            return;
                        }
                    }
                }
            }
            
            // Check Resources
            for (let b of buildings) {
                if (b.type === 'tree' && pos.distanceTo(b.mesh.position) < 5) {
                    player.wood += 5;
                    updateUI();
                    
                    b.health -= 50; 
                    if (b.health <= 0) {
                        scene.remove(b.mesh);
                        objects = objects.filter(obj => obj !== b.mesh);
                        buildings = buildings.filter(bldg => bldg !== b);
                        playSound('explosion');
                    } else {
                        playSound('impact_hit');
                    }
                    return;
                }
            }
            
            // If no other interaction, try to use healing item
            useHealingItem();
        }
        
        function dropItem(slotIndex, position) {
            const itemToDrop = player.inventory[slotIndex];
            if (!itemToDrop) return;
            
            if (player.isHealing && player.healingItem === itemToDrop) {
                finishHealing();
            }

            spawnLoot(position.x, position.y + 1, position.z, itemToDrop);
            player.inventory[slotIndex] = null;
            playSound('pickup_item');
        }

        function createWeaponItem(typeKey, rarityKey) {
            const base = WEAPONS_BASE[typeKey];
            const rar = RARITY_MULTIPLIERS[rarityKey];
            
            let damageMultiplier = 1;
            if (typeKey === 'AUTO_SHG') damageMultiplier = 2.0;
            if (typeKey === 'STINGER') damageMultiplier = 1.25;
            if (typeKey === 'DUAL_SMG') damageMultiplier = 1.25;
            
            return {
                category: 'weapon',
                name: base.name,
                rarity: rar,
                stats: { 
                    ...base, 
                    dmg: base.dmg * rar.dmg * damageMultiplier, 
                    head: base.head * rar.dmg * damageMultiplier, 
                    reload: base.reload * rar.reload, 
                    currentMag: base.mag 
                }, 
                maxAmmo: base.mag
            };
        }
        
        function getRandomRarity() {
            const rarityPool = ['COMMON', 'COMMON', 'UNCOMMON', 'UNCOMMON', 'RARE', 'EPIC', 'LEGENDARY'];
            return rarityPool[Math.floor(Math.random() * rarityPool.length)];
        }

        function getRandomWeaponKey() {
            const keys = Object.keys(WEAPONS_BASE).filter(k => k !== MYTHIC_WEAPON_KEY && k !== 'ROCKET_LAUNCHER');
            return keys[Math.floor(Math.random() * keys.length)];
        }

        function getRandomConsumableKey() {
            return CONSUMABLE_KEYS[Math.floor(Math.random() * CONSUMABLE_KEYS.length)];
        }

        function giveItem(itemData, slot) {
            if (itemData.category === 'weapon') {
                player.inventory[slot] = itemData;
            } else if (itemData.category === 'consumable') {
                const existing = player.inventory.find(i => i && i.name === itemData.name);
                if (existing) {
                    existing.count = Math.min(existing.maxStack, existing.count + itemData.count);
                } else if (player.inventory[slot] === null) {
                    player.inventory[slot] = itemData;
                } else {
                    return false; 
                }
            } else if (itemData === 'mythic') {
                const mythicWeapon = createWeaponItem(MYTHIC_WEAPON_KEY, 'MYTHIC');
                player.inventory[slot] = mythicWeapon;
            }
            return true;
        }

        function spawnLoot(x, y, z, type, rarity = null, weaponKey = null) {
            let item;
            if(type === 'weapon' || type === 'mythic') {
                const typeKey = type === 'mythic' ? MYTHIC_WEAPON_KEY : (weaponKey || getRandomWeaponKey());
                const rarityKey = type === 'mythic' ? 'MYTHIC' : (rarity || getRandomRarity());
                item = createWeaponItem(typeKey, rarityKey);
            } else if (type === 'consumable') {
                const consKey = rarity; 
                const base = CONSUMABLES[consKey];
                item = { category: 'consumable', ...base, count: 1 };
                item.rarity = RARITY_MULTIPLIERS[base.rarity]; 
            } else if (typeof type === 'object') {
                item = type; 
                if (item.category === 'consumable' && typeof item.rarity === 'string') {
                    item.rarity = RARITY_MULTIPLIERS[item.rarity];
                }
            } else {
                return;
            }

            let color = 0x808080;
            if (item.rarity && item.rarity.color) color = parseInt(item.rarity.color.substring(1), 16);
            else if (item.category === 'consumable') color = 0x00d2ff;

            let material;
            if (player.graphicsQuality === 'ultra') {
                material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.5,
                    metalness: 0.5
                });
            } else {
                material = new THREE.MeshLambertMaterial({color: color});
            }
            
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), material);
            mesh.position.set(x, y, z);
            
            if (player.graphicsQuality !== 'low') {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
            }
            
            scene.add(mesh);
            loot.push({ mesh: mesh, data: item });
        }

        // ===============================================================
        // === ENHANCED SHOOTING & DAMAGE SYSTEM =========================
        // ===============================================================

        function shoot(item, isBurst = false) {
            if (item.stats.currentMag <= 0 || player.isReloading || player.isHealing) {
                if (!player.isReloading) reload();
                return;
            }
            
            if (player.isHealing) finishHealing();

            if (item.stats.burst && !isBurst) {
                if (player.isBursting) return;
                player.isBursting = true;
                player.burstCount = 0;
                
                const burstShot = () => {
                    if (player.burstCount < item.stats.burst && item.stats.currentMag > 0) {
                        doSingleShot(item);
                        player.burstCount++;
                        player.burstTimer = setTimeout(burstShot, 100); 
                    } else {
                        player.isBursting = false;
                        if (item.stats.currentMag > 0) {
                             player.burstTimer = setTimeout(() => {}, item.stats.burstDelay);
                        }
                    }
                };
                burstShot();
                return;
            } else if (item.stats.burst && isBurst) {
                doSingleShot(item);
                return;
            }
            
            doSingleShot(item);
        }
        
        function doSingleShot(item) {
            const fireOrigin = camera.position.clone();
            const fireDirection = new THREE.Vector3();
            camera.getWorldDirection(fireDirection);

            createMuzzleFlash(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(0.5)), fireDirection);
            
            playSound('shoot');
            if (controllerConnected) vibrateController('shoot');
            
            player.shotsFired++;
            
            if (item.stats.bulletType === 'hitscan') {
                handleHitscan(item, fireOrigin, fireDirection, player);
            } else if (item.stats.bulletType === 'projectile') {
                handleProjectile(item, fireOrigin, fireDirection);
            }
            
            item.stats.currentMag -= 1;
            lastShot = performance.now();
            updateUI();
        }

        function handleHitscan(item, fireOrigin, fireDirection, shooter) {
            const spread = shooter === player ? (player.ads ? 0.005 : item.stats.spread) : item.stats.spread * 1.5;
            
            for(let p = 0; p < item.stats.pellets; p++) {
                
                const ray = new THREE.Raycaster(fireOrigin);
                const spreadDir = fireDirection.clone();
                
                const randomX = (Math.random() - 0.5) * spread;
                const randomY = (Math.random() - 0.5) * spread;
                spreadDir.x += randomX;
                spreadDir.y += randomY;
                spreadDir.normalize();

                if (shooter !== player && Math.random() < 0.5) {
                    spreadDir.x += (Math.random() - 0.5) * 0.3;
                    spreadDir.y += (Math.random() - 0.5) * 0.3;
                    spreadDir.normalize();
                }

                ray.ray.direction.copy(spreadDir);

                const targets = bots.map(b => b.mesh).concat(objects).concat(cars.map(c=>c.mesh));
                const hits = ray.intersectObjects(targets, true);
                
                if(hits.length > 0) {
                    const hit = hits[0];
                    let hitBot = null;
                    let hitPlayer = false;
                    let isHeadshot = false;

                    let obj = hit.object;
                    while(obj && obj.parent && obj.parent.type !== 'Scene') {
                        const b = bots.find(bot => bot.mesh === obj.parent);
                        if(b) { hitBot = b; break; }
                        obj = obj.parent;
                    }
                    if(!hitBot) hitBot = bots.find(bot => bot.mesh === hit.object);
                    
                    // ENHANCED: Bot can damage player within 50 meters
                    if (shooter !== player) {
                        const playerDist = hit.point.distanceTo(camera.position);
                        if (playerDist < 2 && hit.distance < item.stats.range) hitPlayer = true; 
                    }

                    if(hitBot && hitBot !== shooter) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > hitBot.mesh.position.y + 2.2) { 
                            dmg = item.stats.head; 
                            isHeadshot = true;
                        }
                        
                        createBulletTrail(fireOrigin, hit.point);
                        createImpactEffect(hit.point, isHeadshot);
                        
                        if (shooter === player) {
                            player.shotsHit++;
                            player.damageDealt += dmg;
                            showHitMarker();
                        }
                        
                        applyDamage(hitBot, dmg, hit.point, shooter, isHeadshot);
                    } else if (hitPlayer) {
                        let dmg = item.stats.dmg;
                        if (hit.point.y > camera.position.y + 0.5) { 
                            dmg = item.stats.head; 
                        }
                        
                        createBulletTrail(fireOrigin, hit.point);
                        createImpactEffect(hit.point, hit.point.y > camera.position.y + 0.5);
                        
                        takeDamage(dmg, hit.point); 
                        playSound('player_hit');
                        if (controllerConnected) vibrateController('hit');
                    } else {
                        const buildingHit = buildings.find(b => b.mesh === hit.object);
                        if (buildingHit) {
                            if (buildingHit.type !== 'indestructible_wood') {
                                buildingHit.health -= 50; 
                                if (buildingHit.health <= 0) {
                                    scene.remove(buildingHit.mesh);
                                    objects = objects.filter(obj => obj !== buildingHit.mesh);
                                    buildings = buildings.filter(bldg => bldg !== buildingHit);
                                }
                            }
                        }
                        
                        createBulletTrail(fireOrigin, hit.point);
                        createImpactEffect(hit.point, false);
                        
                        playSound('impact_hit');
                    }
                } else {
                    const endPoint = fireOrigin.clone().add(spreadDir.clone().multiplyScalar(item.stats.range));
                    createBulletTrail(fireOrigin, endPoint);
                }
            }
        }
        
        function handleProjectile(item, fireOrigin, fireDirection) {
            const rocketGeo = new THREE.SphereGeometry(0.3, 12, 12);
            const rocketMat = new THREE.MeshBasicMaterial({ color: 0xff4d4d });
            const rocketMesh = new THREE.Mesh(rocketGeo, rocketMat);
            rocketMesh.position.copy(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(1))); 
            scene.add(rocketMesh);
            
            createMuzzleFlash(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(0.5)), fireDirection);
            
            projectiles.push({
                mesh: rocketMesh,
                velocity: fireDirection.clone().multiplyScalar(50), 
                damage: item.stats.explosionDamage,
                radius: item.stats.explosionRadius,
                shooter: player,
                isExpired: false
            });
        }
        
        function updateProjectiles(dt) {
            for(let i=projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (p.isExpired) continue;
                
                const oldPos = p.mesh.position.clone();
                p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                
                const collisionRay = new THREE.Raycaster(oldPos, p.velocity.clone().normalize(), 0, p.mesh.position.distanceTo(oldPos));
                const targets = bots.map(b => b.mesh).concat(objects).concat(cars.map(c=>c.mesh));
                const hits = collisionRay.intersectObjects(targets, true);

                if (hits.length > 0) {
                    const hit = hits[0];
                    explode(p, hit.point);
                    p.isExpired = true; 
                }

                if (Math.abs(p.mesh.position.x) > WORLD_SIZE / 2 || Math.abs(p.mesh.position.z) > WORLD_SIZE / 2) {
                    explode(p, p.mesh.position);
                    p.isExpired = true;
                }
            }
            
            projectiles = projectiles.filter(p => !p.isExpired);
        }

        function explode(projectile, hitPoint) {
            playSound('explosion');
            
            createImpactEffect(hitPoint, false);
            
            if (hitPoint.distanceTo(camera.position) < projectile.radius) {
                const dist = hitPoint.distanceTo(camera.position);
                const reduction = Math.max(0, dist / projectile.radius);
                const damage = projectile.damage * (1 - reduction);
                takeDamage(damage, hitPoint);
            }

            bots.forEach(bot => {
                if (hitPoint.distanceTo(bot.mesh.position) < projectile.radius) {
                    const dist = hitPoint.distanceTo(bot.mesh.position);
                    const reduction = Math.max(0, dist / projectile.radius);
                    const damage = projectile.damage * (1 - reduction);
                    applyDamage(bot, damage, bot.mesh.position, projectile.shooter, false);
                }
            });
            
            scene.remove(projectile.mesh);
        }
        
        function applyDamage(target, amount, hitPoint, source, isHeadshot = false, type = 'body') {
            amount = Math.round(amount);
            let remainingDmg = amount;

            if(target === player) {
                 takeDamage(amount, hitPoint, type); 
                 return;
            }

            if(target.shield > 0) {
                target.shield -= remainingDmg;
                if(target.shield < 0) { 
                    remainingDmg = -target.shield; 
                    target.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            } 
            
            if (remainingDmg > 0) {
                target.health -= remainingDmg;
            }
            
            showDamage(amount, hitPoint, type, isHeadshot);
            
            if(target.health <= 0) {
                if (bots.includes(target)) {
                    if (source === player) player.eliminations += 1;
                    scene.remove(target.mesh);
                    bots = bots.filter(b => b !== target);
                    
                    const randomWeaponKey = getRandomWeaponKey();
                    const randomRarity = getRandomRarity(); 
                    const botWeapon = createWeaponItem(randomWeaponKey, randomRarity);
                    
                    const dropConsumableKey = getRandomConsumableKey();
                    const consumableBase = CONSUMABLES[dropConsumableKey];
                    const healingItemDrop = { 
                        category: 'consumable', 
                        ...CONSUMABLES[dropConsumableKey], 
                        count: 1, 
                        rarity: consumableBase.rarity 
                    };
                    
                    spawnLoot(hitPoint.x + 1, hitPoint.y, hitPoint.z, botWeapon); 
                    spawnLoot(hitPoint.x - 1, hitPoint.y, hitPoint.z, healingItemDrop); 
                    player.wood += 50; 
                    
                    playSound('elimination');
                    checkWin();
                }
            }
        }
        
        function takeDamage(amount, sourcePoint, type = 'body') {
            amount = Math.floor(amount);
            if (amount <= 0 || player.dead) return;
            
            let remainingDmg = amount;
            
            const overshieldBefore = player.overshield;
            
            if(player.overshield > 0) {
                player.overshield -= remainingDmg;
                if(player.overshield < 0) { 
                    remainingDmg = -player.overshield; 
                    player.overshield = 0; 
                    
                    if (overshieldBefore > 0) {
                        player.lastOvershieldBreak = performance.now();
                    }
                } else {
                    remainingDmg = 0;
                }
                player.lastOvershieldDamage = performance.now();
            }

            if (remainingDmg > 0 && player.shield > 0) {
                player.shield -= remainingDmg;
                if(player.shield < 0) { 
                    remainingDmg = -player.shield; 
                    player.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            }
            
            if (remainingDmg > 0) {
                player.health -= remainingDmg;
            }
            
            showDamage(amount, camera.position.clone().setY(camera.position.y - 0.5), type); 
            updateUI();
            
            if(player.health <= 0) {
                player.dead = true;
                handleGameOver(false);
            }
        }

        function overshieldRegen(dt) {
             if (player.dead || player.overshield === OVER_SHIELD_MAX) return;

             const timeSinceDamage = performance.now() - player.lastOvershieldDamage;
             const timeSinceBreak = performance.now() - player.lastOvershieldBreak;
             
             if (timeSinceDamage >= OVER_SHIELD_REGEN_DELAY && timeSinceBreak >= OVER_SHIELD_REGEN_DELAY) {
                 player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + (OVER_SHIELD_REGEN_RATE * dt));
                 updateUI();
             }
        }

        // ===============================================================
        // === ENHANCED BOT AI WITH PLAYER DAMAGE ========================
        // ===============================================================

        function findClosestTarget(bot) {
            if (player.health > 0 && !player.dead) {
                const dist = bot.mesh.position.distanceTo(camera.position);
                // ENHANCED: Bot can target player within 50 meters
                if (dist <= 50) {
                    return player;
                }
            }
            
            for(let otherBot of bots) {
                if(otherBot !== bot && otherBot.health > 0) {
                    const dist = bot.mesh.position.distanceTo(otherBot.mesh.position);
                    if(dist < 30 && Math.random() < 0.3) {
                        return otherBot;
                    }
                }
            }
            
            return null;
        }

        function updateBots(dt, now) {
            document.getElementById('alive-count').innerText = bots.length + 1;
            const BOT_MOVE_SPEED = WALK_SPEED * 0.4;

            for(let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];
                if (bot.health <= 0) continue;

                const h = getTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                bot.mesh.position.y = h + 1; 

                if (now - bot.lastTargetUpdate > 2000) {
                    bot.target = findClosestTarget(bot);
                    bot.lastTargetUpdate = now;
                }
                
                const target = bot.target;
                
                if(target && bot.isAggressive) {
                    const targetPos = target === player ? camera.position : target.mesh.position;
                    const dist = bot.mesh.position.distanceTo(targetPos);
                    
                    if (dist <= bot.attackRange) {
                        bot.mesh.lookAt(targetPos.x, targetPos.y, targetPos.z);
                        
                        if(dist > 25) {
                            const moveDir = new THREE.Vector3().subVectors(targetPos, bot.mesh.position).normalize();
                            bot.mesh.translateZ(BOT_MOVE_SPEED * dt * bot.moveSpeed * 2);
                            bot.moveCooldown = 1000;
                            
                            if(bot.canStrafe && bot.strafeTimer <= 0) {
                                bot.strafeDirection *= -1;
                                bot.strafeTimer = 1000 + Math.random() * 1000;
                            }
                            if(bot.strafeTimer > 0) {
                                bot.mesh.translateX(bot.strafeDirection * BOT_MOVE_SPEED * dt * 0.5);
                                bot.strafeTimer -= dt * 1000;
                            }
                            
                        } else if (dist < 8) {
                            bot.mesh.rotation.y += Math.PI/3 * (Math.random() > 0.5 ? 1 : -1) * dt;
                            bot.mesh.translateZ(-BOT_MOVE_SPEED * dt * bot.moveSpeed * 0.8);
                            bot.moveCooldown = 500;
                            bot.isTakingCover = true;
                            bot.coverTimer = 2000;
                        } else {
                            if(bot.canStrafe) {
                                bot.mesh.translateX(bot.strafeDirection * BOT_MOVE_SPEED * dt * 0.3);
                            }
                            bot.mesh.translateZ(BOT_MOVE_SPEED * dt * bot.moveSpeed * 0.5);
                            bot.moveCooldown = 800;
                        }
                        
                        const weaponStats = bot.weapon.stats; 
                        if(dist < weaponStats.range && now - bot.lastShot > weaponStats.rate * 1000) { 
                            if(Math.random() < bot.accuracy) {
                                bot.lastShot = now;
                                
                                const fireOrigin = bot.mesh.position.clone().setY(bot.mesh.position.y + 2.4);
                                const fireDirection = new THREE.Vector3();
                                fireDirection.subVectors(targetPos.clone().setY(targetPos.y - 0.5), fireOrigin).normalize();
                                
                                const inaccuracy = (1 - bot.accuracy) * 0.1;
                                fireDirection.x += (Math.random() - 0.5) * inaccuracy;
                                fireDirection.y += (Math.random() - 0.5) * inaccuracy;
                                fireDirection.normalize();
                                
                                // ENHANCED: Bot can damage player
                                if (target === player && bot.canDamagePlayer && now - bot.lastPlayerDamageCheck > bot.damageCooldown) {
                                    const ray = new THREE.Raycaster(fireOrigin, fireDirection);
                                    const playerDist = fireOrigin.distanceTo(camera.position);
                                    
                                    if (playerDist < 50) { // Within 50 meters
                                        const hits = ray.intersectObjects([camera], false);
                                        if (hits.length > 0 && hits[0].distance < 50) {
                                            let dmg = weaponStats.dmg;
                                            if (hits[0].point.y > camera.position.y + 0.5) {
                                                dmg = weaponStats.head;
                                            }
                                            
                                            createMuzzleFlash(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(0.5)), fireDirection);
                                            createBulletTrail(fireOrigin, hits[0].point);
                                            createImpactEffect(hits[0].point, hits[0].point.y > camera.position.y + 0.5);
                                            
                                            takeDamage(dmg, hits[0].point);
                                            playSound('player_hit');
                                            showHitMarker();
                                            
                                            bot.lastPlayerDamageCheck = now;
                                        }
                                    }
                                } else {
                                    createMuzzleFlash(fireOrigin.clone().add(fireDirection.clone().multiplyScalar(0.5)), fireDirection);
                                    handleHitscan(bot.weapon, fireOrigin, fireDirection, bot);
                                }
                            }
                        }
                    } else {
                        bot.target = null;
                    }
                } else {
                    if(bot.patrolPoints.length > 0) {
                        const currentTarget = bot.patrolPoints[bot.currentPatrolIndex];
                        const distToPoint = bot.mesh.position.distanceTo(currentTarget);
                        
                        if(distToPoint < 5) {
                            bot.currentPatrolIndex = (bot.currentPatrolIndex + 1) % bot.patrolPoints.length;
                            bot.moveCooldown = 1000 + Math.random() * 1000;
                        } else {
                            bot.mesh.lookAt(currentTarget.x, bot.mesh.position.y, currentTarget.z);
                            bot.mesh.translateZ(BOT_MOVE_SPEED * dt * 0.3);
                        }
                    } else {
                        bot.moveCooldown -= dt * 1000;
                        if (bot.moveCooldown <= 0) {
                            bot.currentDirection = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                            bot.mesh.lookAt(bot.mesh.position.clone().add(bot.currentDirection));
                            bot.moveCooldown = Math.random() * 2000 + 1000;
                        }
                        bot.mesh.translateZ(BOT_MOVE_SPEED * dt * 0.3);
                    }
                }
                
                if(bot.canJump && Math.random() < 0.01 && bot.mesh.position.y <= h + 1.1) {
                    bot.velocity.y = JUMP_FORCE * 0.7;
                }
                
                bot.velocity.y -= GRAVITY * dt;
                bot.mesh.position.y += bot.velocity.y * dt;
                
                if(bot.mesh.position.y <= h + 1) {
                    bot.mesh.position.y = h + 1;
                    bot.velocity.y = 0;
                }
                
                if(bot.isTakingCover) {
                    bot.coverTimer -= dt * 1000;
                    if(bot.coverTimer <= 0) {
                        bot.isTakingCover = false;
                    }
                }
            }
        }

        // ===============================================================
        // === ENHANCED VEHICLE LOGIC ====================================
        // ===============================================================

        function updateCars(dt) {
            for(const car of cars) {
                if(car.driving) {
                    const speed = inputs.w ? 15 : inputs.s ? -5 : 0;
                    car.speed = THREE.MathUtils.lerp(car.speed, speed, 0.1);

                    if (inputs.a || inputs.d) {
                        const rotationSpeed = dt * 1.5 * (inputs.d ? -1 : 1);
                        car.mesh.rotation.y += rotationSpeed * Math.sign(car.speed || 1);
                    }
                    
                    car.mesh.translateZ(car.speed * dt);
                    
                    if (Math.abs(car.speed) > 5) {
                        const currentPos = car.mesh.position;
                        
                        bots.forEach(bot => {
                            if (currentPos.distanceTo(bot.mesh.position) < 3) {
                                applyDamage(bot, 100, bot.mesh.position, player);
                            }
                        });
                    }

                    const h = getTerrainHeight(car.mesh.position.x, car.mesh.position.z);
                    car.mesh.position.y = h;

                    if(player.vehicle === car) {
                        camera.position.copy(car.mesh.position).add(new THREE.Vector3(0, PLAYER_HEIGHT + 1, 0));
                    }
                }
            }
        }

        // ===============================================================
        // === ENHANCED UI FUNCTIONS =====================================
        // ===============================================================
        
        function updateUI() {
            player.health = Math.max(0, Math.min(100, player.health));
            player.shield = Math.max(0, Math.min(100, player.shield));
            player.overshield = Math.max(0, Math.min(OVER_SHIELD_MAX, player.overshield));
            
            document.getElementById('health-value').innerText = Math.ceil(player.health);
            document.getElementById('shield-value').innerText = Math.ceil(player.shield);
            document.getElementById('overshield-value').innerText = Math.ceil(player.overshield);
            document.getElementById('wood-value').innerText = player.wood;
            
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('shield-bar').style.width = player.shield + '%';
            document.getElementById('overshield-bar').style.width = (player.overshield / OVER_SHIELD_MAX) * 100 + '%';
            
            player.inventory.forEach((item, i) => {
                const slot = document.getElementById(`slot-${i}`);
                slot.innerHTML = '';
                
                if(item) {
                    const icon = item.category === 'weapon' ? item.stats.icon : item.icon;
                    const name = item.name; 
                    const count = item.category === 'consumable' ? item.count : '';
                    
                    slot.innerHTML = `
                        <div class="slot-key">${i+1}</div>
                        <div class="slot-icon">${icon}</div>
                        <div class="slot-name">${name}</div>
                        ${count ? `<div class="slot-count">${count}</div>` : ''}
                    `;
                    
                    let rarityKey = '';
                    if (item.rarity && item.rarity.color) {
                        const rarityEntry = Object.entries(RARITY_MULTIPLIERS).find(([, value]) => value === item.rarity);
                        if (rarityEntry) {
                            rarityKey = rarityEntry[0].toLowerCase(); 
                        } else if (typeof item.rarity === 'string') {
                            rarityKey = item.rarity.toLowerCase();
                        }
                    }
                    
                    slot.className = `inventory-slot ${i===player.slot ? 'active' : ''} rarity-${rarityKey}`;
                } else {
                    slot.className = `inventory-slot ${i===player.slot ? 'active' : ''}`;
                    slot.innerHTML = `<div class="slot-key">${i+1}</div>`;
                }
            });
            
            let msg = "Interact (E)";
            const pos = camera.position;
            const nearestChest = chests.some(c => pos.distanceTo(c.position) < 6);
            const nearestLoot = loot.some(l => pos.distanceTo(l.mesh.position) < 4);
            const nearestDoor = doors.some(d => pos.distanceTo(d.mesh.position) < 5);
            const nearestCar = cars.some(c => pos.distanceTo(c.mesh.position) < 5);

            const showInteract = nearestChest || nearestLoot || nearestDoor || nearestCar || player.vehicle;
            
            if (!showInteract) {
                const currentItem = player.inventory[player.slot];
                if (currentItem && currentItem.category === 'consumable' && currentItem.count > 0 && 
                    ((currentItem.type === 'shield' && (player.shield < 100 || player.overshield < OVER_SHIELD_MAX)) || (currentItem.type === 'health' && player.health < 100) || currentItem.type === 'continuous')) {
                     msg = player.isHealing ? `Cancel Healing (E)` : `Use ${currentItem.name} (E)`;
                     document.getElementById('interact-prompt').style.display = 'block';
                } else {
                    document.getElementById('interact-prompt').style.display = 'none';
                }
            } else {
                 if (player.vehicle) msg = "Exit Vehicle (E)";
                 else if (nearestChest) msg = "Open Chest (E)";
                 else if (nearestLoot) msg = "Pickup/Swap (E)";
                 else if (nearestDoor) msg = "Open Door (E)";
                 else if (nearestCar) msg = "Enter Vehicle (E)";
                 document.getElementById('interact-prompt').style.display = 'block';
            }
            
            document.getElementById('interact-prompt').innerText = msg;
            
            const item = player.inventory[player.slot];
            const isWeapon = item && item.category === 'weapon';
            const showReload = isWeapon && item.stats.currentMag < item.stats.mag;
            document.getElementById('btn-reload').style.display = gameMode === 'mobile' && isWeapon && showReload && !player.isReloading ? 'flex' : 'none';
        }
        
        function switchSlot(idx) {
            if (player.isHealing) {
                const currentHealingSlot = player.inventory.findIndex(i => i === player.healingItem);
                if (currentHealingSlot === player.slot && !player.healingItem.continuous) {
                    finishHealing();
                } else if (currentHealingSlot !== player.slot) {
                    finishHealing();
                }
            }

            if(idx < 0 || idx > 4) return;
            player.slot = idx;
            
            document.querySelectorAll('.inventory-slot').forEach((el, i) => {
                el.classList.toggle('active', i === idx);
            });
            
            if(viewModel) weaponScene.remove(viewModel);
            const item = player.inventory[idx];
            
            if(item && item.category === 'weapon') {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
                const color = item.rarity && item.rarity.color ? item.rarity.color : '#FFFFFF'; 
                const mat = new THREE.MeshStandardMaterial({ color: color });
                viewModel = new THREE.Mesh(geo, mat);
                viewModel.position.set(0.2, -0.2, -0.5);
                weaponScene.add(viewModel);
                
                toggleADS(player.ads); 
            } else {
                document.getElementById('crosshair').style.display = 'block';
                toggleADS(false);
            }
            
            updateUI(); 
        }
        
        function selectSlotMobile(idx) {
            if (gameMode === 'mobile') {
                switchSlot(idx);
            }
        }

        // ===============================================================
        // === ENHANCED INPUT & CONTROL MANAGEMENT ========================
        // ===============================================================
        
        function setGameMode(mode) {
            gameMode = mode;
            const mobileControls = document.getElementById('mobile-controls');
            const gameContainer = document.getElementById('game-container');

            if (mode === 'mobile') {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'block';
                gameContainer.removeEventListener('mousedown', lockPointer);
                
                initMobileControls();
            } else if (mode === 'controller') {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'none';
                gameContainer.removeEventListener('mousedown', lockPointer);
            } else {
                if (controls) controls.enabled = true;
                mobileControls.style.display = 'none';
                gameContainer.addEventListener('mousedown', lockPointer);
            }
        }
        
        function lockPointer() {
            if (controls && gameMode === 'desktop') {
                controls.lock();
                inputs.fire = false; 
            }
        }

        function setupPCLock() {
            if (controls) controls.enabled = true;
            document.getElementById('game-container').addEventListener('mousedown', lockPointer);
        }

        // === ENHANCED MOBILE CONTROLS WITH HIGH SENSITIVITY ===
        function initMobileControls() {
            const touchLeft = document.getElementById('touch-left');
            const touchRight = document.getElementById('touch-right');
            const joystickThumb = document.getElementById('joystick-thumb');
            const movementZone = document.getElementById('movement-zone');
            
            // Movement joystick (left 50%)
            let touchStartX = 0;
            let touchStartY = 0;
            let isTouchingLeft = false;
            let joystickActive = false;
            
            touchLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isTouchingLeft = true;
                joystickActive = true;
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                
                const rect = touchLeft.getBoundingClientRect();
                movementZone.style.left = `${touch.clientX - rect.left - 100}px`;
                movementZone.style.bottom = '140px';
                movementZone.style.display = 'block';
            });
            
            touchLeft.addEventListener('touchmove', (e) => {
                if (!isTouchingLeft) return;
                e.preventDefault();
                const touch = e.touches[0];
                const rect = movementZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const maxDist = rect.width / 2;
                
                if(dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio;
                    dy *= ratio;
                }
                
                joystickThumb.style.transform = `translate(${dx}px, ${dy}px)`;
                
                inputs.w = dy < -20;
                inputs.s = dy > 20;
                inputs.a = dx < -20;
                inputs.d = dx > 20;
                inputs.sprint = dist > 50;
            });
            
            touchLeft.addEventListener('touchend', (e) => {
                isTouchingLeft = false;
                joystickActive = false;
                joystickThumb.style.transform = `translate(-50%, -50%)`;
                inputs.w = inputs.s = inputs.a = inputs.d = inputs.sprint = false;
                movementZone.style.display = 'none';
            });
            
            // Camera controls (right 50%) - HIGH SENSITIVITY
            let lastCameraTouchX = 0;
            let lastCameraTouchY = 0;
            let isTouchingCamera = false;
            
            touchRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isTouchingCamera = true;
                const touch = e.touches[0];
                lastCameraTouchX = touch.clientX;
                lastCameraTouchY = touch.clientY;
                touchDeltaX = 0;
                touchDeltaY = 0;
            });
            
            touchRight.addEventListener('touchmove', (e) => {
                if (!isTouchingCamera) return;
                e.preventDefault();
                const touch = e.touches[0];
                
                const deltaX = touch.clientX - lastCameraTouchX;
                const deltaY = touch.clientY - lastCameraTouchY;
                
                // ENHANCED: Much higher sensitivity
                touchDeltaX = touchDeltaX * (1 - MOBILE_SMOOTHING) + deltaX * MOBILE_SMOOTHING * 2;
                touchDeltaY = touchDeltaY * (1 - MOBILE_SMOOTHING) + deltaY * MOBILE_SMOOTHING * 2;
                
                camera.rotation.y -= touchDeltaX * MOBILE_SENSITIVITY;
                camera.rotation.x -= touchDeltaY * MOBILE_SENSITIVITY;
                
                camera.rotation.x = Math.max(-MAX_CAMERA_ANGLE, Math.min(MAX_CAMERA_ANGLE, camera.rotation.x));
                
                lastCameraTouchX = touch.clientX;
                lastCameraTouchY = touch.clientY;
            });
            
            touchRight.addEventListener('touchend', (e) => {
                isTouchingCamera = false;
                touchDeltaX = 0;
                touchDeltaY = 0;
            });
            
            // Mobile button handlers
            document.getElementById('btn-fire').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                inputs.fire = true; 
            });
            document.getElementById('btn-fire').addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                inputs.fire = false; 
            });
            
            document.getElementById('btn-jump').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                inputs.jump = true; 
            });
            document.getElementById('btn-jump').addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                inputs.jump = false; 
            });
            
            document.getElementById('btn-interact').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                tryInteract(); 
            });
            
            document.getElementById('btn-build').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                buildWall(); 
            });
            
            // MOVED AIM BUTTON: Now at top right
            document.getElementById('btn-ads').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                toggleADS(true); 
            });
            document.getElementById('btn-ads').addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                toggleADS(false); 
            });
            
            document.getElementById('btn-reload').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                reload(); 
            });
        }

        // Controller input handling
        function setupControllerInputs() {
            window.addEventListener("gamepadconnected", (e) => {
                console.log("Gamepad connected:", e.gamepad);
                gamepad = e.gamepad;
                controllerConnected = true;
                showControllerNotification();
                vibrateController('medium');
            });

            window.addEventListener("gamepaddisconnected", (e) => {
                console.log("Gamepad disconnected:", e.gamepad);
                gamepad = null;
                controllerConnected = false;
            });

            function updateControllerState() {
                if (!controllerConnected || !gamepad) return;
                
                const gp = navigator.getGamepads()[gamepad.index];
                if (!gp) return;
                
                controllerMapping.leftStick.x = gp.axes[0];
                controllerMapping.leftStick.y = gp.axes[1];
                
                controllerMapping.rightStick.x = gp.axes[2];
                controllerMapping.rightStick.y = gp.axes[3];
                
                controllerMapping.buttons.l1 = gp.buttons[4].pressed;
                controllerMapping.buttons.r1 = gp.buttons[5].pressed;
                controllerMapping.buttons.l2 = gp.buttons[6].value;
                controllerMapping.buttons.r2 = gp.buttons[7].value;
                controllerMapping.buttons.y = gp.buttons[3].pressed;
                controllerMapping.buttons.b = gp.buttons[1].pressed;
                controllerMapping.buttons.a = gp.buttons[0].pressed;
                controllerMapping.buttons.x = gp.buttons[2].pressed;
                
                controllerMapping.buttons.dpadUp = gp.buttons[12].pressed;
                controllerMapping.buttons.dpadDown = gp.buttons[13].pressed;
                controllerMapping.buttons.dpadLeft = gp.buttons[14].pressed;
                controllerMapping.buttons.dpadRight = gp.buttons[15].pressed;
                
                if (gameMode === 'controller') {
                    inputs.w = controllerMapping.leftStick.y < -0.3;
                    inputs.s = controllerMapping.leftStick.y > 0.3;
                    inputs.a = controllerMapping.leftStick.x < -0.3;
                    inputs.d = controllerMapping.leftStick.x > 0.3;
                    
                    inputs.sprint = controllerMapping.buttons.a;
                    
                    if (Math.abs(controllerMapping.rightStick.x) > 0.1 || Math.abs(controllerMapping.rightStick.y) > 0.1) {
                        camera.rotation.y -= controllerMapping.rightStick.x * CONTROLLER_SENSITIVITY;
                        camera.rotation.x -= controllerMapping.rightStick.y * CONTROLLER_SENSITIVITY;
                        camera.rotation.x = Math.max(-MAX_CAMERA_ANGLE, Math.min(MAX_CAMERA_ANGLE, camera.rotation.x));
                    }
                    
                    if (controllerMapping.buttons.b && !inputs.jump) {
                        inputs.jump = true;
                        setTimeout(() => inputs.jump = false, 100);
                        vibrateController('jump');
                    }
                    
                    if (controllerMapping.buttons.y && !inputs.reload) {
                        inputs.reload = true;
                        setTimeout(() => inputs.reload = false, 100);
                    }
                    
                    if (controllerMapping.buttons.x && !inputs.use) {
                        inputs.use = true;
                        setTimeout(() => inputs.use = false, 100);
                        tryInteract();
                    }
                    
                    if (controllerMapping.buttons.l2 > 0.5) {
                        toggleADS(true);
                    } else if (player.ads) {
                        toggleADS(false);
                    }
                    
                    if (controllerMapping.buttons.r2 > 0.5) {
                        inputs.fire = true;
                    } else {
                        inputs.fire = false;
                    }
                    
                    if (controllerMapping.buttons.dpadLeft || controllerMapping.buttons.l1) {
                        const newSlot = (player.slot - 1 + 5) % 5;
                        switchSlot(newSlot);
                        vibrateController('light');
                    }
                    if (controllerMapping.buttons.dpadRight || controllerMapping.buttons.r1) {
                        const newSlot = (player.slot + 1) % 5;
                        switchSlot(newSlot);
                        vibrateController('light');
                    }
                }
            }
            
            setInterval(updateControllerState, 16);
        }

        function setupInputs() {
            const gameContainer = document.getElementById('game-container');
            
            // PC Keyboard Controls
            const onKey = (e, v) => {
                if (gameMode === 'desktop' && controls && controls.isLocked) {
                    if(e.code === 'KeyW') inputs.w = v;
                    if(e.code === 'KeyS') inputs.s = v;
                    if(e.code === 'KeyA') inputs.a = v;
                    if(e.code === 'KeyD') inputs.d = v;
                    if(e.code === 'ShiftLeft') inputs.sprint = v;
                    
                    if(e.code === 'Space' && v) inputs.jump = true; 
                    if(e.code === 'KeyR' && v) inputs.reload = true; 
                    if(e.code === 'KeyX' && v) useHealingItem();
                    
                    // Pause menu
                    if(e.code === 'Escape' && v) {
                        if (!player.dead) {
                            togglePauseMenu();
                        }
                    }
                }
            };
            
            document.addEventListener('keydown', e => {
                onKey(e, true);
                if(gameMode === 'desktop' && controls && controls.isLocked) {
                    if(e.code === 'Digit1') switchSlot(0);
                    if(e.code === 'Digit2') switchSlot(1);
                    if(e.code === 'Digit3') switchSlot(2);
                    if(e.code === 'Digit4') switchSlot(3);
                    if(e.code === 'Digit5') switchSlot(4);
                    if(e.code === 'KeyE') tryInteract();
                    if(e.code === 'KeyB') buildWall(); 
                }
            });
            
            document.addEventListener('keyup', e => onKey(e, false));
            
            // PC Mouse Controls with sensitivity
            document.addEventListener('mousemove', (e) => {
                if (player.dead || gameMode !== 'desktop' || !controls || !controls.isLocked || gamePaused) return;
                
                if (controls && controls.isLocked) {
                    const movementX = e.movementX || 0;
                    const movementY = e.movementY || 0;
                    
                    camera.rotation.y -= movementX * 0.002 * player.sensitivity;
                    camera.rotation.x -= movementY * 0.002 * player.sensitivity;
                    
                    camera.rotation.x = Math.max(-MAX_CAMERA_ANGLE, Math.min(MAX_CAMERA_ANGLE, camera.rotation.x));
                }
            });
            
            document.addEventListener('mousedown', e => {
                if(player.dead || gameMode !== 'desktop' || !controls || !controls.isLocked || gamePaused) return;
                if(e.button === 0) inputs.fire = true;
                if(e.button === 2) toggleADS(true);
            });
            
            document.addEventListener('mouseup', e => {
                if(player.dead || gameMode !== 'desktop' || gamePaused) return;
                if(e.button === 0) inputs.fire = false;
                if(e.button === 2) toggleADS(false);
            });
            
            document.addEventListener('contextmenu', e => e.preventDefault());
            
            // Settings sliders
            const sensitivitySlider = document.getElementById('sensitivity-slider');
            const volumeSlider = document.getElementById('volume-slider');
            
            sensitivitySlider.addEventListener('input', (e) => {
                player.sensitivity = parseFloat(e.target.value);
                document.getElementById('sensitivity-value').textContent = player.sensitivity.toFixed(1);
            });
            
            volumeSlider.addEventListener('input', (e) => {
                setVolume(parseFloat(e.target.value) / 100);
            });
            
            // Graphics settings
            document.querySelectorAll('input[name="graphics"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    player.graphicsQuality = e.target.value;
                    applyGraphicsSettings();
                });
            });
        }

        // ===============================================================
        // === NEW: SETTINGS AND PAUSE MENU FUNCTIONS ====================
        // ===============================================================

        function togglePauseMenu() {
            gamePaused = !gamePaused;
            if (gamePaused) {
                if (controls && controls.isLocked) controls.unlock();
                document.getElementById('pause-menu').style.display = 'flex';
            } else {
                if (controls && gameMode === 'desktop') controls.lock();
                document.getElementById('pause-menu').style.display = 'none';
            }
        }

        function resumeGame() {
            gamePaused = false;
            if (controls && gameMode === 'desktop') controls.lock();
            document.getElementById('pause-menu').style.display = 'none';
        }

        function openSettings() {
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('settings-menu').style.display = 'flex';
        }

        function closeSettings() {
            document.getElementById('settings-menu').style.display = 'none';
            if (!player.dead && !gamePaused) {
                if (controls && gameMode === 'desktop') controls.lock();
            } else if (gamePaused) {
                document.getElementById('pause-menu').style.display = 'flex';
            }
        }

        function applyGraphicsSettings() {
            // Apply graphics settings based on quality
            if (renderer) {
                switch(player.graphicsQuality) {
                    case 'low':
                        renderer.setPixelRatio(1);
                        renderer.shadowMap.enabled = false;
                        break;
                    case 'medium':
                        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFShadowMap;
                        break;
                    case 'high':
                        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        break;
                    case 'ultra':
                        renderer.setPixelRatio(window.devicePixelRatio);
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        break;
                }
            }
        }

        // ===============================================================
        // === ENHANCED INITIALIZATION ===================================
        // ===============================================================

        function init() {
            loadLevelData();
            updateLevelDisplay();
            
            initAudio();
            setupControllerInputs();
            
            // Clear objects array
            objects = [];
            
            // Scene Setup with enhanced graphics
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 100);

            // Enhanced renderer with graphics settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: player.graphicsQuality !== 'low',
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = player.graphicsQuality !== 'low';
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false; 
            
            applyGraphicsSettings();
            
            const gameContainer = document.getElementById('game-container');
            gameContainer.appendChild(renderer.domElement);
            
            // Enhanced Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = player.graphicsQuality !== 'low';
            
            if (player.graphicsQuality !== 'low') {
                sunLight.shadow.camera.right = 150; sunLight.shadow.camera.left = -150;
                sunLight.shadow.camera.top = 150; sunLight.shadow.camera.bottom = -150;
                sunLight.shadow.mapSize.width = player.graphicsQuality === 'ultra' ? 4096 : 
                                              player.graphicsQuality === 'high' ? 2048 : 1024;
                sunLight.shadow.mapSize.height = player.graphicsQuality === 'ultra' ? 4096 : 
                                               player.graphicsQuality === 'high' ? 2048 : 1024;
            }
            scene.add(sunLight);
            
            weaponScene.add(ambient.clone());
            weaponScene.add(sunLight.clone());
            
            // Controls
            controls = new PointerLockControls(camera, document.body);
            setupInputs(); 

            // Raycasters
            raycaster = new THREE.Raycaster();
            downRay = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, PLAYER_HEIGHT + 0.1);
            
            // Initialize mini-map
            miniMapCanvas = document.getElementById('mini-map-canvas');
            miniMapCtx = miniMapCanvas.getContext('2d');
            miniMapCanvas.width = 200;
            miniMapCanvas.height = 200;
            
            animate();
        }
        
        function updateMiniMap() {
            if (!miniMapCtx) return;
            
            // Clear mini-map
            miniMapCtx.fillStyle = 'rgba(0, 4, 40, 0.9)';
            miniMapCtx.fillRect(0, 0, 200, 200);
            
            // Draw storm circle
            const mapScale = 200 / WORLD_SIZE;
            const stormX = (stormCenter.x + WORLD_SIZE/2) * mapScale;
            const stormY = (stormCenter.y + WORLD_SIZE/2) * mapScale;
            const stormR = stormRadius * mapScale;
            
            miniMapCtx.beginPath();
            miniMapCtx.arc(stormX, stormY, stormR, 0, Math.PI * 2);
            miniMapCtx.fillStyle = 'rgba(157, 78, 221, 0.3)';
            miniMapCtx.fill();
            
            // Draw player
            const playerX = (camera.position.x + WORLD_SIZE/2) * mapScale;
            const playerY = (camera.position.z + WORLD_SIZE/2) * mapScale;
            
            miniMapCtx.beginPath();
            miniMapCtx.arc(playerX, playerY, 4, 0, Math.PI * 2);
            miniMapCtx.fillStyle = '#00ffff';
            miniMapCtx.fill();
            
            // Draw bots
            bots.forEach(bot => {
                const botX = (bot.mesh.position.x + WORLD_SIZE/2) * mapScale;
                const botY = (bot.mesh.position.z + WORLD_SIZE/2) * mapScale;
                
                miniMapCtx.beginPath();
                miniMapCtx.arc(botX, botY, 3, 0, Math.PI * 2);
                miniMapCtx.fillStyle = bot.health > 0 ? '#ff4d4d' : '#666666';
                miniMapCtx.fill();
            });
            
            // Draw buildings
            buildings.forEach(building => {
                const buildX = (building.mesh.position.x + WORLD_SIZE/2) * mapScale;
                const buildY = (building.mesh.position.z + WORLD_SIZE/2) * mapScale;
                
                miniMapCtx.fillStyle = '#8B4513';
                miniMapCtx.fillRect(buildX - 2, buildY - 2, 4, 4);
            });
        }

        window.startGame = (mode) => {
            document.getElementById('start-screen').style.display = 'none';
            gameStarted = true;
            
            setGameMode(mode);
            
            if (mode === 'desktop') {
                setupPCLock(); 
            }
            
            // Reset player stats
            player.health = 100;
            player.shield = 100;
            player.overshield = 50;
            player.wood = 0;
            player.inventory = [null, null, null, null, null];
            player.slot = 0;
            player.eliminations = 0;
            player.chestsOpened = 0;
            player.legendaryItemsHeld = 0;
            player.matchPoints = 0;
            player.shotsFired = 0;
            player.shotsHit = 0;
            player.damageDealt = 0;
            player.dead = false;
            
            generateTerrain(); 
            generatePOIs(); 
            spawnBots();
            spawnCars();

            camera.position.set(0, getTerrainHeight(0, 0) + PLAYER_HEIGHT + 2, 0);
            
            startStormTimer(); 
            switchSlot(0);
            
            updateUI();
        };

        // ===============================================================
        // === ENHANCED CORE GAME LOOP ==================================
        // ===============================================================

        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            // FPS Counter
            frameCount++;
            if (now - lastFpsUpdate > 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                document.getElementById('fps-counter').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = now;
            }

            if(!gameStarted || player.dead || gamePaused) {
                renderer.clear();
                renderer.render(scene, camera);
                return;
            }

            if (dt < 0.1) {
                if (player.isHealing && player.healingItem) {
                    if (player.healingItem.continuous) {
                        applyContinuousHealing(player.healingItem, dt);
                    } else if (!player.healingItem.instant) {
                        inputs.fire = false;
                        inputs.w = inputs.a = inputs.s = inputs.d = false;
                    }
                }
                overshieldRegen(dt);

                if(player.vehicle) {
                    updateCars(dt);
                } else {
                    const canMove = gameMode === 'mobile' || gameMode === 'controller' || (controls && controls.isLocked); 
                    if (canMove) {
                        const speedMultiplier = player.ads ? 0.5 : 1.0; 
                        const currentSpeed = (inputs.sprint ? SPRINT_SPEED : WALK_SPEED) * speedMultiplier;
                        
                        const direction = new THREE.Vector3();
                        direction.setFromMatrixColumn(camera.matrix, 0); 
                        direction.crossVectors(camera.up, direction);
                        direction.y = 0;
                        direction.normalize();
                        
                        const right = new THREE.Vector3(-direction.z, 0, direction.x);

                        const yVelocity = velocity.y; 
                        velocity.set(0, yVelocity, 0); 

                        if(inputs.w) velocity.add(direction.clone().multiplyScalar(currentSpeed));
                        if(inputs.s) velocity.add(direction.clone().multiplyScalar(-currentSpeed));
                        if(inputs.a) velocity.add(right.clone().multiplyScalar(-currentSpeed));
                        if(inputs.d) velocity.add(right.clone().multiplyScalar(currentSpeed));
                        
                        camera.position.x += velocity.x * dt;
                        camera.position.z += velocity.z * dt;
                        velocity.y -= GRAVITY * dt; 
                        
                        const groundY = getTerrainHeight(camera.position.x, camera.position.z);
                        let floorY = groundY;
                        
                        downRay.ray.origin.copy(camera.position);
                        const hits = downRay.intersectObjects(objects, false); 
                        
                        if(hits.length > 0) {
                            const closestHit = hits[0];
                            if (closestHit.point.y > groundY + 0.1) { 
                                floorY = closestHit.point.y;
                            }
                        }
                        
                        if (camera.position.y <= floorY + PLAYER_HEIGHT && velocity.y <= 0) {
                            camera.position.y = floorY + PLAYER_HEIGHT;
                            velocity.y = 0;
                            isGrounded = true;
                        } else {
                            isGrounded = false;
                        }
                        
                        if(inputs.jump && isGrounded) {
                            velocity.y = JUMP_FORCE;
                            isGrounded = false;
                            inputs.jump = false; 
                            playSound('jump');
                        }
                        
                        camera.position.y += velocity.y * dt;
                    } else {
                        velocity.x = 0; 
                        velocity.z = 0;
                    }
                }

                const canFire = gameMode === 'mobile' || gameMode === 'controller' || (controls && controls.isLocked); 
                if(inputs.fire && !player.vehicle && !player.isHealing && canFire) {
                    const item = player.inventory[player.slot];
                    if(item && item.category === 'weapon') {
                        if (item.stats.burst) {
                            if (now - lastShot > item.stats.burstDelay) {
                                shoot(item);
                            }
                        } else if(now - lastShot > item.stats.rate * 1000) {
                            shoot(item);
                        }
                    }
                } else if (inputs.reload) {
                    reload();
                    inputs.reload = false;
                }
                
                updateProjectiles(dt);
                updateBots(dt, now);
                updateStorm(now); 
                
                // Update mini-map
                updateMiniMap();
            }

            renderer.clear();
            renderer.render(scene, camera);
            renderer.clearDepth();
            renderer.render(weaponScene, weaponCamera);
            
            updateUI();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            weaponCamera.aspect = window.innerWidth / window.innerHeight;
            weaponCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.selectSlot = switchSlot;
        window.selectSlotMobile = selectSlotMobile;
        
        init();
    </script>
</body>
</html>
