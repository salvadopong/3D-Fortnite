<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Battle Royale: V19.9 - Ultimate Edition</title>
    <style>
        /* ======================================= */
        /* === V19.9 ULTIMATE UI REDESIGN === */
        /* ======================================= */
        
        * {
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Poppins', 'Verdana', sans-serif; 
            user-select: none; 
            background: #000;
            touch-action: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            color: white;
        }

        /* FPS Counter */
        #fps-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            font-family: monospace;
            font-weight: bold;
            font-size: 1rem;
            z-index: 1000;
            border: 1px solid #00ff00;
            pointer-events: none;
        }

        /* Performance Warning */
        #performance-warning {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(255, 100, 0, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            border: 1px solid #ff6600;
            pointer-events: none;
        }

        /* Level System UI - ENHANCED */
        #level-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: white;
            padding: 0.8rem 1.2rem;
            border-radius: 15px;
            z-index: 1000;
            border: 2px solid rgba(0, 210, 255, 0.6);
            backdrop-filter: blur(15px);
            min-width: 250px;
            box-shadow: 0 10px 30px rgba(0, 210, 255, 0.3);
        }
        
        .level-info {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .level-text {
            font-size: 1.3rem;
            font-weight: 900;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .level-text::before {
            content: 'âš¡';
            font-size: 1.1rem;
        }
        
        .xp-progress {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .progress-container {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 0.3rem 0;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00d2ff, #0072ff, #a335ee);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.6), 
                transparent);
            animation: progressShine 2s infinite linear;
        }
        
        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .points-text {
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            min-width: 80px;
            text-align: right;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .level-perks {
            display: flex;
            gap: 0.8rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }
        
        .level-perk {
            background: rgba(0, 210, 255, 0.15);
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 600;
            color: #00d2ff;
            border: 1px solid rgba(0, 210, 255, 0.3);
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .level-perk.unlocked {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            border-color: rgba(255, 215, 0, 0.4);
        }

        /* End Game Stats */
        #endgame-stats {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
            padding: 2rem;
            border-radius: 20px;
            color: white;
            z-index: 1002;
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            min-width: 400px;
            border: 3px solid rgba(0, 210, 255, 0.4);
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8);
        }
        
        .stats-header {
            text-align: center;
            font-size: 1.8rem;
            font-weight: 900;
            color: #00d2ff;
            margin-bottom: 1rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .stat-value {
            color: #ffd700;
            font-weight: 700;
        }
        
        .total-points {
            text-align: center;
            font-size: 1.5rem;
            color: #00ff00;
            font-weight: 900;
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 10px;
            border: 2px solid #00ff00;
        }

        /* --- PRE-GAME START SCREEN (Ultimate Design) --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a2a 0%, #1a1a4a 50%, #0a0a2a 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 1000;
            text-align: center;
            animation: fadeIn 0.8s ease-out;
            overflow: hidden;
        }
        
        /* Animated background particles */
        .particles {
            position: absolute;
            width: 100%; height: 100%;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            background: rgba(0, 210, 255, 0.1);
            border-radius: 50%;
            animation: float 20s infinite linear;
        }
        
        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); }
            100% { transform: translateY(-100px) rotate(360deg); }
        }

        #start-screen h1 { 
            font-size: 5rem; 
            margin-bottom: 1rem; 
            background: linear-gradient(135deg, #00d2ff 0%, #0072ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            letter-spacing: 2px;
            animation: slideDown 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            z-index: 2;
            text-shadow: 0 10px 30px rgba(0, 210, 255, 0.3);
        }
        
        #start-screen h1::after {
            content: 'V19.9';
            display: block;
            font-size: 1.5rem;
            color: #ffd700;
            margin-top: 0.5rem;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            animation: glow 3s infinite alternate;
        }
        
        @keyframes glow {
            0% { text-shadow: 0 0 10px rgba(255, 215, 0, 0.7); }
            100% { text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 50px rgba(255, 215, 0, 0.5); }
        }

        #start-screen .subtitle { 
            font-size: 1.3rem; 
            margin-bottom: 3rem; 
            color: rgba(255,255,255,0.8);
            animation: fadeIn 1s ease-out 0.5s backwards;
            position: relative;
            z-index: 2;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
            z-index: 2;
            animation: scaleIn 0.8s ease-out 0.8s backwards;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        
        .game-button {
            padding: 1.2rem 2.5rem; 
            margin: 0; 
            font-size: 1.3rem;
            background: linear-gradient(135deg, #00d2ff, #0072ff);
            color: white; 
            border: none; 
            border-radius: 15px; 
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Poppins', sans-serif; 
            font-weight: 600;
            box-shadow: 
                0 10px 30px rgba(0, 114, 255, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        .game-button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.6s;
        }
        
        .game-button:hover::before {
            left: 100%;
        }
        
        .game-button:hover { 
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 15px 40px rgba(0, 114, 255, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        .game-button:active { 
            transform: scale(0.98) translateY(0); 
            box-shadow: 0 5px 20px rgba(0, 114, 255, 0.3);
            transition: transform 0.1s;
        }
        
        .game-button.mobile { 
            background: linear-gradient(135deg, #ffaa00, #ff6600);
        }
        
        .game-button.mobile:hover { 
            background: linear-gradient(135deg, #ff8800, #ff4400); 
        }
        
        .game-button.controller { 
            background: linear-gradient(135deg, #8a2be2, #4b0082);
        }
        
        .game-button.controller:hover { 
            background: linear-gradient(135deg, #7a1bd2, #3b0072); 
        }
        
        /* Controller Connected Notification */
        .controller-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #8a2be2, #4b0082);
            color: white;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-weight: 600;
            z-index: 1001;
            display: none;
            animation: slideInRight 0.5s ease-out;
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.4);
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        @keyframes slideInRight {
            0% { transform: translateX(100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }
        
        /* Stats display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-top: 3rem;
            animation: fadeIn 1s ease-out 1s backwards;
            position: relative;
            z-index: 2;
            max-width: 800px;
            width: 100%;
        }
        
        .stat-item {
            background: rgba(0, 0, 0, 0.6);
            padding: 1.2rem;
            border-radius: 12px;
            border: 2px solid rgba(0, 210, 255, 0.2);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
        }
        
        .stat-item:hover {
            transform: translateY(-5px);
            border-color: rgba(0, 210, 255, 0.4);
            box-shadow: 0 10px 30px rgba(0, 210, 255, 0.2);
        }
        
        .stat-item h3 {
            margin: 0 0 0.5rem 0;
            color: #00d2ff;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-item p {
            margin: 0;
            color: #ffd700;
            font-size: 1.8rem;
            font-weight: 700;
        }
        
        #victory-royales-stat {
            position: absolute; 
            bottom: 2rem; 
            font-size: 1.1rem;
            color: #ffd700; 
            font-weight: 600;
            background: rgba(0,0,0,0.7);
            padding: 1rem 2rem;
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            z-index: 2;
            animation: fadeIn 1s ease-out 1.5s backwards;
            backdrop-filter: blur(10px);
        }
        
        /* === NEW ULTIMATE CROSSHAIR === */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 32px; height: 32px; 
            transform: translate(-50%, -50%); 
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.95;
            z-index: 10;
            pointer-events: none;
            filter: drop-shadow(0 0 8px rgba(255, 77, 77, 0.7));
        }
        
        .crosshair-dot {
            position: absolute;
            width: 6px; height: 6px;
            background: #ff4d4d;
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 12px #ff4d4d,
                0 0 24px rgba(255, 77, 77, 0.7);
            animation: crosshairPulse 2s infinite alternate;
        }
        
        @keyframes crosshairPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            100% { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        .crosshair-line {
            position: absolute;
            background: #ff4d4d;
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(255, 77, 77, 0.9);
        }
        
        .ch-h { 
            width: 100%; height: 3px; 
            top: 50%; left: 0; 
            margin-top: -1.5px; 
        }
        
        .ch-v { 
            height: 100%; width: 3px; 
            left: 50%; top: 0; 
            margin-left: -1.5px; 
        }

        /* Enhanced Scopes - IMPROVED ADS */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 18%, rgba(0, 0, 0, 0.98) 19%, black 100%);
            display: none; pointer-events: none; z-index: 100; 
        }
        
        #scope-lines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(to right, rgba(255,255,255,0.1) 1px, transparent 1px) 0 0 / 25px 25px,
                linear-gradient(to bottom, rgba(255,255,255,0.1) 1px, transparent 1px) 0 0 / 25px 25px;
            opacity: 0.5;
        }
        
        #red-dot-scope {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none;
            pointer-events: none;
            background: radial-gradient(circle, transparent 45%, rgba(0,0,0,0.85) 46%, rgba(0,0,0,0.95) 100%);
        }
        
        .red-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: #ff0000; 
            box-shadow: 
                0 0 20px #ff0000,
                0 0 40px #ff0000,
                0 0 60px rgba(255, 0, 0, 0.5);
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            animation: pulseRed 0.8s infinite alternate;
        }
        
        @keyframes pulseRed {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.4); opacity: 0.8; }
        }
        
        .red-line {
            position: absolute; background: rgba(255, 0, 0, 0.2);
        }
        .red-line.h { width: 100%; height: 1px; top: 50%; }
        .red-line.v { height: 100%; width: 1px; left: 50%; }

        /* Storm Visuals */
        #storm-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, 
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.15) 40%,
                rgba(75, 0, 130, 0.25) 60%,
                rgba(75, 0, 130, 0.35) 80%,
                rgba(75, 0, 130, 0.45) 100%);
            mix-blend-mode: multiply; 
            pointer-events: none; 
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 50; 
        }
        
        #storm-overlay.in-storm {
            background: radial-gradient(circle at 50% 50%,
                rgba(138, 43, 226, 0.0) 0%,
                rgba(138, 43, 226, 0.25) 30%,
                rgba(75, 0, 130, 0.45) 50%,
                rgba(75, 0, 130, 0.65) 70%,
                rgba(75, 0, 130, 0.85) 100%);
            animation: stormPulse 2s infinite alternate;
        }
        
        @keyframes stormPulse {
            0% { opacity: 0.9; }
            100% { opacity: 1; }
        }

        /* === REDESIGNED ULTIMATE HUD === */
        #hud-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        /* Top Bar - Redesigned and Smaller */
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1.5rem;
            background: rgba(10, 10, 30, 0.9);
            backdrop-filter: blur(20px);
            padding: 0.8rem 1.5rem;
            border-radius: 15px;
            border: 2px solid rgba(0, 210, 255, 0.4);
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.7),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 20px rgba(0, 210, 255, 0.3);
            z-index: 20;
        }
        
        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 100px;
        }
        
        .hud-label {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.8);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.3rem;
            font-weight: 600;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        
        .hud-value {
            font-size: 1.5rem;
            font-weight: 800;
            color: white;
            text-shadow: 
                0 2px 5px rgba(0,0,0,0.5),
                0 0 15px currentColor;
            letter-spacing: 0.5px;
        }
        
        #alive-count { 
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        #storm-timer { 
            color: #a335ee;
            text-shadow: 0 0 15px rgba(163, 53, 238, 0.5);
        }
        #storm-status {
            color: #00d2ff;
            text-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
        }

        /* Player Stats - Left Side (Redesigned and Smaller) */
        #player-stats {
            position: absolute;
            bottom: 1.5rem;
            left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            width: 240px;
            z-index: 20;
        }
        
        .stat-card {
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, 0.85) 0%,
                rgba(20, 20, 40, 0.85) 100%);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            padding: 0.7rem 1rem;
            border: 2px solid rgba(255,255,255,0.15);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.1),
                0 0 20px rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.05) 0%,
                transparent 100%);
            z-index: 1;
        }
        
        .stat-card:hover {
            border-color: rgba(0, 210, 255, 0.4);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 30px rgba(0, 210, 255, 0.4);
        }
        
        .stat-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.5rem;
            position: relative;
            z-index: 2;
        }
        
        .stat-icon {
            font-size: 1rem;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.15) 0%,
                rgba(255,255,255,0.05) 100%);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.1),
                0 3px 10px rgba(0,0,0,0.3);
        }
        
        .stat-title {
            flex: 1;
            font-size: 0.8rem;
            font-weight: 700;
            color: rgba(255,255,255,0.95);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        
        .stat-value {
            font-size: 1.1rem;
            font-weight: 900;
            color: #ffd700;
            min-width: 45px;
            text-align: right;
            text-shadow: 
                0 2px 5px rgba(0,0,0,0.5),
                0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        .stat-bar-container {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            z-index: 2;
            box-shadow: 
                inset 0 1px 2px rgba(0,0,0,0.5),
                0 1px 3px rgba(0,0,0,0.3);
        }
        
        .stat-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.4), 
                transparent);
            animation: barShine 2.5s infinite linear;
        }
        
        .stat-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.2) 0%,
                transparent 50%,
                rgba(255,255,255,0.1) 100%);
        }
        
        @keyframes barShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #health-bar { 
            background: linear-gradient(90deg, 
                #ff4d4d 0%, 
                #ff8888 50%, 
                #ffaaaa 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(255, 77, 77, 0.5);
        }
        
        #shield-bar { 
            background: linear-gradient(90deg, 
                #0072ff 0%, 
                #00a8ff 50%, 
                #00d2ff 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(0, 114, 255, 0.5);
        }
        
        #overshield-bar { 
            background: linear-gradient(90deg, 
                #ffaa00 0%, 
                #ffcc00 50%, 
                #ffff00 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(255, 170, 0, 0.5);
        }

        /* Resources Bar - Redesigned and Smaller */
        #resources-bar {
            display: flex;
            gap: 0.8rem;
            margin-top: 0.8rem;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.8rem;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.1) 0%,
                rgba(255,255,255,0.05) 100%);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 
                0 4px 12px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .resource-item:hover {
            transform: translateY(-2px);
            border-color: rgba(222, 184, 135, 0.4);
            box-shadow: 
                0 6px 20px rgba(0,0,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 15px rgba(222, 184, 135, 0.3);
        }
        
        .resource-icon {
            font-size: 1.1rem;
            color: #deb887;
            text-shadow: 0 0 8px rgba(222, 184, 135, 0.5);
        }
        
        .resource-amount {
            font-size: 1rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        /* Inventory - Right Side (Redesigned and Smaller) */
        #inventory-hud {
            position: absolute;
            bottom: 1.5rem;
            right: 1.5rem;
            display: flex;
            gap: 0.6rem;
            z-index: 20;
        }
        
        .inventory-slot {
            width: 70px;
            height: 85px;
            background: linear-gradient(135deg, 
                rgba(10, 10, 30, 0.95) 0%,
                rgba(20, 20, 40, 0.95) 100%);
            backdrop-filter: blur(15px);
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 
                0 8px 20px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .inventory-slot::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.05) 0%,
                transparent 100%);
        }
        
        .inventory-slot:hover {
            transform: translateY(-6px) scale(1.06);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 
                0 15px 30px rgba(0,0,0,0.7),
                inset 0 1px 0 rgba(255,255,255,0.15),
                0 0 25px rgba(255,255,255,0.2);
        }
        
        .inventory-slot.active {
            border-color: #ff4d4d;
            transform: translateY(-8px) scale(1.1);
            background: linear-gradient(135deg, 
                rgba(30, 30, 50, 0.98) 0%,
                rgba(40, 40, 60, 0.98) 100%);
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.8),
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 0 30px rgba(255, 77, 77, 0.5);
        }
        
        .slot-key {
            position: absolute;
            top: 6px;
            left: 6px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.8);
            font-weight: 700;
            background: rgba(0,0,0,0.6);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            text-shadow: 0 2px 3px rgba(0,0,0,0.5);
        }
        
        .slot-icon {
            font-size: 1.8rem;
            margin-bottom: 0.3rem;
            text-shadow: 0 0 10px currentColor;
            filter: drop-shadow(0 0 3px currentColor);
        }
        
        .slot-name {
            font-size: 0.6rem;
            font-weight: 700;
            color: rgba(255,255,255,0.95);
            text-transform: uppercase;
            text-align: center;
            max-width: 60px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 0 0.2rem;
            text-shadow: 0 2px 3px rgba(0,0,0,0.5);
        }
        
        .slot-count {
            position: absolute;
            bottom: 6px;
            right: 6px;
            font-size: 0.7rem;
            font-weight: 900;
            color: #ffd700;
            background: rgba(0,0,0,0.6);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            text-shadow: 
                0 2px 3px rgba(0,0,0,0.5),
                0 0 8px rgba(255, 215, 0, 0.5);
        }
        
        /* Rarity Borders */
        .rarity-common { 
            border-bottom: 4px solid #b0b0b0;
            box-shadow: 0 0 15px rgba(176, 176, 176, 0.3);
        }
        .rarity-uncommon { 
            border-bottom: 4px solid #28a745;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.3);
        }
        .rarity-rare { 
            border-bottom: 4px solid #007bff;
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.3);
        }
        .rarity-epic { 
            border-bottom: 4px solid #a335ee;
            box-shadow: 0 0 15px rgba(163, 53, 238, 0.3);
        }
        .rarity-legendary { 
            border-bottom: 4px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }
        .rarity-mythic { 
            border-bottom: 4px solid #ff4d4d;
            box-shadow: 0 0 15px rgba(255, 77, 77, 0.3);
        }

        /* Center HUD Elements */
        #center-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            z-index: 15;
        }

        /* Interaction Prompt - Redesigned */
        #interact-prompt {
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.98), 
                rgba(255, 170, 0, 0.98));
            color: #000;
            padding: 1rem 2rem;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 800;
            display: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 10px 30px rgba(255, 215, 0, 0.5),
                0 6px 20px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.6);
            border: 3px solid rgba(255,255,255,0.6);
            backdrop-filter: blur(10px);
            animation: pulsePrompt 1.5s infinite alternate;
            pointer-events: none;
            position: relative;
            overflow: hidden;
        }
        
        #interact-prompt::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, 
                transparent 0%,
                rgba(255,255,255,0.3) 50%,
                transparent 100%);
            animation: promptShine 3s infinite linear;
        }
        
        @keyframes promptShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes pulsePrompt {
            0% { transform: translateY(-50%) scale(1); box-shadow: 0 10px 30px rgba(255, 215, 0, 0.5); }
            100% { transform: translateY(-50%) scale(1.06); box-shadow: 0 15px 40px rgba(255, 215, 0, 0.7); }
        }

        /* Reload Indicator - Redesigned */
        #reload-indicator {
            background: linear-gradient(135deg, 
                rgba(255, 0, 0, 0.98), 
                rgba(255, 68, 68, 0.98));
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 800;
            display: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 10px 30px rgba(255, 0, 0, 0.5),
                0 6px 20px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.4);
            backdrop-filter: blur(10px);
            animation: reloadPulse 1s infinite alternate;
        }
        
        @keyframes reloadPulse {
            0% { opacity: 0.9; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.03); }
        }

        /* Healing Progress - Redesigned */
        #healing-progress {
            position: absolute;
            bottom: 10rem;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            height: 35px;
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, 0.9) 0%,
                rgba(20, 20, 40, 0.9) 100%);
            border-radius: 20px;
            display: none;
            overflow: hidden;
            border: 2px solid rgba(0, 210, 255, 0.6);
            box-shadow: 
                0 10px 30px rgba(0, 210, 255, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
        }
        
        #healing-bar {
            height: 100%;
            background: linear-gradient(90deg, 
                #0072ff 0%, 
                #00d2ff 50%, 
                #00ffff 100%);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        #healing-bar::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.5), 
                transparent);
            animation: healShine 1.2s infinite linear;
        }
        
        #healing-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.3) 0%,
                transparent 50%,
                rgba(255,255,255,0.1) 100%);
        }
        
        @keyframes healShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #healing-text {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 800;
            font-size: 1rem;
            text-shadow: 
                0 2px 5px rgba(0,0,0,0.8),
                0 0 15px rgba(0, 210, 255, 0.5);
            letter-spacing: 1px;
        }

        /* Damage Numbers - Redesigned */
        .dmg-number {
            position: absolute;
            color: white;
            font-weight: 900;
            font-size: 2rem;
            text-shadow: 
                2px 2px 6px rgba(0,0,0,0.9),
                0 0 15px currentColor,
                0 0 30px currentColor;
            pointer-events: none;
            animation: damageFloat 1.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            z-index: 999;
            font-family: 'Poppins', sans-serif;
            letter-spacing: 0.5px;
        }
        
        .dmg-number.headshot {
            color: #ff0000;
            font-size: 2.4rem;
            text-shadow: 
                0 0 20px #ff0000,
                0 0 40px #ff0000,
                0 0 60px rgba(255, 0, 0, 0.7);
        }
        
        .dmg-number.storm {
            color: #a335ee;
            font-size: 1.8rem;
            text-shadow: 
                0 0 20px #a335ee,
                0 0 35px rgba(163, 53, 238, 0.7);
        }
        
        @keyframes damageFloat { 
            0% { opacity: 1; transform: translateY(0) scale(1) rotate(0deg); } 
            30% { opacity: 1; transform: translateY(-15px) scale(1.1) rotate(-5deg); }
            70% { opacity: 1; transform: translateY(-45px) scale(1.2) rotate(5deg); }
            100% { opacity: 0; transform: translateY(-70px) scale(1.3) rotate(0deg); } 
        }

        /* Visual Effects */
        .muzzle-flash {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #ff9900 0%, #ff3300 50%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            animation: muzzleFlash 0.1s forwards;
        }
        
        @keyframes muzzleFlash {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(2); }
        }
        
        .bullet-trail {
            position: absolute;
            width: 2px;
            height: 50px;
            background: linear-gradient(to bottom, #ffff00 0%, #ff9900 50%, transparent 100%);
            pointer-events: none;
            z-index: 998;
            transform-origin: top center;
        }
        
        .impact-effect {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff4444 0%, #ff0000 50%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 997;
            animation: impactEffect 0.3s forwards;
        }
        
        @keyframes impactEffect {
            0% { opacity: 1; transform: scale(0.5); }
            50% { opacity: 0.8; transform: scale(1.2); }
            100% { opacity: 0; transform: scale(1.5); }
        }
        
        .blood-effect {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #cc0000 0%, #990000 50%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 996;
            animation: bloodEffect 0.5s forwards;
        }
        
        @keyframes bloodEffect {
            0% { opacity: 1; transform: scale(0.5) rotate(0deg); }
            50% { opacity: 0.8; transform: scale(1.3) rotate(180deg); }
            100% { opacity: 0; transform: scale(1.5) rotate(360deg); }
        }

        /* Controller Layout Display */
        #controller-layout {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 1rem;
            border-radius: 12px;
            display: none;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.8rem;
            z-index: 1001;
            border: 2px solid rgba(138, 43, 226, 0.5);
            backdrop-filter: blur(8px);
            font-size: 0.8rem;
        }
        
        .controller-button {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 6px;
            padding: 0.5rem;
            text-align: center;
            color: white;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 0.7rem;
        }
        
        .controller-button.active {
            background: rgba(138, 43, 226, 0.5);
            border-color: rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.7);
        }

        /* --- MOBILE CONTROLS (UPDATED FOR V19.9) --- */
        #mobile-controls {
            display: none; 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none;
            z-index: 5;
        }
        
        /* IMPROVED: Mobile control zones */
        #touch-left {
            position: absolute;
            top: 0; left: 0;
            width: 40%; height: 100%;
            pointer-events: auto;
            touch-action: none;
            z-index: 6;
        }
        
        /* IMPROVED: Camera control area - now 60% of screen for better control */
        #touch-right {
            position: absolute;
            top: 0; right: 0;
            width: 60%; height: 100%;
            background: transparent;
            pointer-events: auto;
            touch-action: none;
            z-index: 6;
        }
        
        /* Movement Zone - Updated */
        #movement-zone {
            position: absolute;
            bottom: 100px;
            left: 80px;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.08) 0%,
                rgba(255,255,255,0.03) 70%,
                transparent 71%);
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.2);
            pointer-events: none;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.5),
                inset 0 0 20px rgba(255,255,255,0.1);
            z-index: 7;
            opacity: 0.9;
        }
        
        .joystick-thumb {
            position: absolute;
            top: 50%; left: 50%;
            width: 60px; height: 60px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.4) 0%,
                rgba(255,255,255,0.2) 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 6px 20px rgba(0,0,0,0.6),
                inset 0 0 15px rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.4);
            pointer-events: none;
            transition: transform 0.08s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 8;
        }

        /* Mobile Action Buttons - Updated */
        .mobile-button {
            position: absolute;
            width: 75px; height: 75px;
            border-radius: 50%;
            background: linear-gradient(135deg, 
                rgba(30, 30, 40, 0.95),
                rgba(20, 20, 30, 0.95));
            border: 3px solid rgba(255,255,255,0.3);
            color: white;
            font-weight: 800;
            font-size: 0.9rem;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(12px);
            text-align: center;
            text-transform: uppercase;
            z-index: 10;
            box-shadow: 
                0 8px 25px rgba(0,0,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 15px rgba(255,255,255,0.1);
            transition: all 0.12s cubic-bezier(0.4, 0, 0.2, 1);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .mobile-button:active {
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.4),
                rgba(255,255,255,0.3));
            transform: scale(0.85);
            box-shadow: 
                0 4px 15px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 20px rgba(255,255,255,0.3);
        }
        
        #btn-fire { 
            bottom: 100px; right: 30px; 
            width: 90px; height: 90px;
            border-color: #ff4444;
            background: linear-gradient(135deg, 
                rgba(255,0,0,0.6),
                rgba(255,68,68,0.5));
            font-size: 1.2rem;
            box-shadow: 
                0 10px 30px rgba(255,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 20px rgba(255,0,0,0.3);
        }
        
        #btn-fire:active {
            box-shadow: 
                0 6px 20px rgba(255,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 30px rgba(255,0,0,0.5);
        }
        
        #btn-jump { 
            bottom: 200px; right: 40px;
            border-color: #00d2ff;
            background: linear-gradient(135deg,
                rgba(0,210,255,0.6),
                rgba(0,168,255,0.5));
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.4);
        }
        
        #btn-interact { 
            bottom: 160px; right: 120px;
            border-color: #ffd700;
            color: #ffd700;
            background: linear-gradient(135deg,
                rgba(255,215,0,0.4),
                rgba(255,170,0,0.3));
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        #btn-build { 
            bottom: 230px; right: 120px;
            border-color: #8B4513;
            background: linear-gradient(135deg,
                rgba(139,69,19,0.6),
                rgba(160,82,45,0.5));
            box-shadow: 0 0 20px rgba(139, 69, 19, 0.3);
        }
        
        #btn-ads { 
            bottom: 60px; right: 130px;
            width: 65px; height: 65px;
            font-size: 0.9rem;
            border-color: #007bff;
            background: linear-gradient(135deg,
                rgba(0,123,255,0.6),
                rgba(0,82,204,0.5));
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.3);
        }
        
        #btn-reload { 
            top: 180px; right: 30px;
            width: 60px; height: 60px;
            font-size: 0.8rem;
            border-color: #00d2ff;
            background: linear-gradient(135deg,
                rgba(0,210,255,0.6),
                rgba(0,168,255,0.5));
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.3);
            display: none;
        }
        
        /* New Mobile Controls for V19.9 */
        #btn-crouch {
            bottom: 270px; right: 40px;
            border-color: #808080;
            background: linear-gradient(135deg,
                rgba(128,128,128,0.6),
                rgba(96,96,96,0.5));
            box-shadow: 0 0 15px rgba(128, 128, 128, 0.3);
        }
        
        #btn-switch-weapon {
            top: 100px; right: 30px;
            width: 60px; height: 60px;
            font-size: 0.8rem;
            border-color: #FFD700;
            background: linear-gradient(135deg,
                rgba(255,215,0,0.4),
                rgba(255,170,0,0.3));
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        /* === ULTIMATE VICTORY & ELIMINATED SCREENS === */
        #victory-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(255, 215, 0, 0.9),
                rgba(255, 140, 0, 0.95));
            backdrop-filter: blur(25px);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            animation: fadeIn 0.5s ease-out forwards;
            overflow: hidden;
        }
        
        .victory-particles {
            position: absolute;
            width: 100%; height: 100%;
        }
        
        .victory-particle {
            position: absolute;
            width: 10px; height: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            animation: victoryParticleFloat 6s infinite linear;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.7);
        }
        
        @keyframes victoryParticleFloat {
            0% { transform: translateY(100vh) rotate(0deg) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(90vh) rotate(0deg) scale(1); }
            90% { opacity: 1; transform: translateY(10vh) rotate(360deg) scale(1); }
            100% { transform: translateY(0) rotate(720deg) scale(0); opacity: 0; }
        }
        
        #victory-text {
            font-size: 0;
            background: linear-gradient(135deg, #ffd700, #ffaa00, #ff6600, #ff0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            animation: victoryText 3.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards,
                       victoryPulse 2s infinite alternate 3.5s;
            position: relative;
            text-shadow: 
                0 12px 40px rgba(255, 215, 0, 0.6),
                0 0 60px rgba(255, 170, 0, 0.4),
                0 0 90px rgba(255, 100, 0, 0.3);
            letter-spacing: -8px;
            opacity: 0;
            white-space: nowrap;
            z-index: 2;
        }
        
        #victory-text::after {
            content: 'V19.9';
            display: block;
            font-size: 2rem;
            margin-top: 1rem;
            color: #ffffff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.9);
            animation: versionPulse 3s infinite alternate;
        }
        
        @keyframes versionPulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.1); }
        }
        
        @keyframes victoryText {
            0% { font-size: 0; transform: scale(0) rotate(-20deg); opacity: 0; letter-spacing: 80px; }
            30% { font-size: 7rem; transform: scale(1.4) rotate(15deg); opacity: 1; letter-spacing: -8px; }
            50% { font-size: 7rem; transform: scale(1.4) rotate(-5deg); opacity: 1; letter-spacing: -4px; }
            70% { font-size: 7rem; transform: scale(1.2) rotate(5deg); opacity: 1; letter-spacing: -2px; }
            100% { font-size: 5.5rem; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0; }
        }
        
        @keyframes victoryPulse {
            0% { transform: scale(1); text-shadow: 0 12px 40px rgba(255, 215, 0, 0.6); }
            100% { transform: scale(1.08); text-shadow: 0 15px 50px rgba(255, 215, 0, 0.9), 0 0 80px rgba(255, 170, 0, 0.5); }
        }
        
        #victory-stats {
            font-size: 2.2rem;
            color: white;
            margin-top: 2rem;
            opacity: 0;
            animation: fadeUp 1s ease-out 4s forwards;
            text-shadow: 0 6px 20px rgba(0,0,0,0.7);
            z-index: 2;
        }
        
        #game-over {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg,
                rgba(200, 0, 0, 0.97),
                rgba(50, 0, 0, 0.99));
            backdrop-filter: blur(25px);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 999;
            pointer-events: auto;
            text-align: center;
            overflow: hidden;
        }
        
        .eliminated-particles {
            position: absolute;
            width: 100%; height: 100%;
        }
        
        .eliminated-particle {
            position: absolute;
            width: 8px; height: 8px;
            background: rgba(255, 50, 50, 0.7);
            border-radius: 50%;
            animation: eliminatedParticleFall 4s infinite linear;
        }
        
        @keyframes eliminatedParticleFall {
            0% { transform: translateY(-100px) rotate(0deg) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(0) rotate(0deg) scale(1); }
            90% { opacity: 1; transform: translateY(100vh) rotate(360deg) scale(1); }
            100% { transform: translateY(110vh) rotate(720deg) scale(0); opacity: 0; }
        }
        
        #go-title {
            font-size: 0;
            background: linear-gradient(135deg, #ff4d4d, #ff0000, #8b0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1.5rem;
            font-weight: 900;
            animation: eliminatedText 2.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 12px 40px rgba(255, 0, 0, 0.6);
            letter-spacing: -8px;
            opacity: 0;
        }
        
        @keyframes eliminatedText {
            0% { font-size: 0; transform: scale(0) rotate(-10deg); opacity: 0; letter-spacing: 40px; }
            40% { font-size: 6.5rem; transform: scale(1.3) rotate(5deg); opacity: 1; letter-spacing: -4px; }
            60% { font-size: 6.5rem; transform: scale(1.1) rotate(-2deg); opacity: 1; letter-spacing: -2px; }
            100% { font-size: 5rem; transform: scale(1) rotate(0deg); opacity: 1; letter-spacing: 0; }
        }
        
        #go-stats {
            font-size: 2.2rem;
            color: rgba(255,255,255,0.95);
            margin-bottom: 3rem;
            animation: slideIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) 2.5s backwards;
            text-shadow: 0 6px 20px rgba(0,0,0,0.7);
            z-index: 2;
        }

        /* Restart Button - Redesigned */
        .restart-btn {
            margin-top: 3rem;
            padding: 1.2rem 2.5rem;
            font-size: 1.4rem;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            box-shadow: 
                0 12px 35px rgba(0, 123, 255, 0.7),
                inset 0 1px 0 rgba(255,255,255,0.4),
                0 0 25px rgba(0, 123, 255, 0.5);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 2;
        }
        
        .restart-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.6s;
        }
        
        .restart-btn:hover::before {
            left: 100%;
        }
        
        .restart-btn:hover {
            background: linear-gradient(135deg, #0056b3, #003d82);
            transform: translateY(-4px);
            box-shadow: 
                0 15px 40px rgba(0, 123, 255, 0.9),
                inset 0 1px 0 rgba(255,255,255,0.5),
                0 0 30px rgba(0, 123, 255, 0.7);
        }
        
        #game-over .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 3s forwards;
        }
        
        #victory-overlay .restart-btn {
            opacity: 0;
            animation: fadeUp 1s ease-out 4.5s forwards;
        }

        /* Animations */
        @keyframes fadeIn { 
            0% { opacity: 0; } 
            100% { opacity: 1; } 
        }
        
        @keyframes slideDown {
            0% { opacity: 0; transform: translateY(-40px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes scaleIn {
            0% { opacity: 0; transform: scale(0.7) rotate(-5deg); }
            70% { opacity: 1; transform: scale(1.05) rotate(2deg); }
            100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }
        
        @keyframes slideIn {
            0% { opacity: 0; transform: translateY(-40px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes fadeUp {
            0% { transform: translateY(40px) scale(0.8); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        /* Menu Enhancements */
        .menu-background {
            position: absolute;
            width: 100%; height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 210, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 128, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(255, 215, 0, 0.15) 0%, transparent 50%);
            animation: backgroundPulse 10s infinite alternate;
        }
        
        @keyframes backgroundPulse {
            0% { opacity: 0.4; }
            100% { opacity: 0.8; }
        }
        
        .version-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            padding: 0.6rem 1.2rem;
            border-radius: 20px;
            font-weight: 800;
            font-size: 0.9rem;
            animation: badgeGlow 2s infinite alternate;
            box-shadow: 
                0 6px 20px rgba(255, 215, 0, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        @keyframes badgeGlow {
            0% { box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4); }
            100% { box-shadow: 0 6px 25px rgba(255, 215, 0, 0.7), 0 0 25px rgba(255, 215, 0, 0.3); }
        }
        
        .menu-title {
            position: relative;
            margin-bottom: 1.5rem;
        }
        
        .title-glow {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 120%; height: 120%;
            background: radial-gradient(circle, rgba(0, 210, 255, 0.4) 0%, transparent 70%);
            filter: blur(40px);
            z-index: 1;
        }
        
        /* Day/Night Cycle Indicator */
        #day-night-indicator {
            position: absolute;
            top: 20px;
            right: 120px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            font-weight: 600;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        #day-night-icon {
            font-size: 1.2rem;
        }
        
        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #0a0a2a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 2000;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 210, 255, 0.3);
            border-top: 5px solid #00d2ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: #00d2ff;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>

    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Game Assets...</div>
    </div>

    <div id="start-screen">
        <div class="menu-background"></div>
        <div class="particles" id="particles-container"></div>
        <div class="version-badge">V19.9 â€¢ ULTIMATE EDITION</div>
        <div class="menu-title">
            <div class="title-glow"></div>
            <h1>WEB BATTLE ROYALE</h1>
        </div>
        <p class="subtitle">Experience the ultimate browser-based shooter</p>
        <div class="button-container">
            <button class="game-button mobile" onclick="startGame('mobile')">ðŸ“± Mobile Mode</button>
            <button class="game-button" onclick="startGame('desktop')">ðŸ–¥ï¸ Desktop Mode</button>
            <button class="game-button controller" onclick="startGame('controller')">ðŸŽ® Controller Mode</button>
        </div>
        <div class="stats-grid">
            <div class="stat-item">
                <h3>Active Players</h3>
                <p id="total-players">21</p>
            </div>
            <div class="stat-item">
                <h3>Map Size</h3>
                <p>600x600</p>
            </div>
            <div class="stat-item">
                <h3>Version</h3>
                <p>V19.9</p>
            </div>
        </div>
        <div id="victory-royales-stat">ðŸ† Victory Royales: 0</div>
    </div>
    
    <div id="game-container"></div>

    <div id="ui-layer">
        <!-- FPS Counter -->
        <div id="fps-counter">FPS: 60</div>
        
        <!-- Performance Warning -->
        <div id="performance-warning">âš ï¸ LOW FPS - ADJUSTING SETTINGS</div>
        
        <!-- Day/Night Indicator -->
        <div id="day-night-indicator">
            <span id="day-night-icon">ðŸŒž</span>
            <span id="day-night-text">Day</span>
        </div>
        
        <!-- Level Display -->
        <div id="level-display">
            <div class="level-info">
                <div class="level-text">Level 1</div>
                <div class="xp-progress">
                    <div class="progress-container">
                        <div class="progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="points-text">0 / 150 XP</div>
                </div>
                <div class="level-perks">
                    <div class="level-perk">+5% Damage</div>
                    <div class="level-perk">+10 Shield</div>
                    <div class="level-perk unlocked">Unlocked</div>
                </div>
            </div>
        </div>
        
        <!-- Crosshair -->
        <div id="crosshair">
            <div class="crosshair-dot"></div>
            <div class="crosshair-line ch-h"></div>
            <div class="crosshair-line ch-v"></div>
        </div>
        
        <!-- Scopes -->
        <div id="scope-overlay">
            <div id="scope-lines"></div>
        </div>
        
        <div id="red-dot-scope">
            <div class="red-line h"></div>
            <div class="red-line v"></div>
            <div class="red-dot"></div>
        </div>

        <!-- Storm Overlay -->
        <div id="storm-overlay"></div>

        <!-- HUD Container -->
        <div id="hud-container">
            <!-- Top Bar -->
            <div id="top-bar">
                <div class="hud-item">
                    <div class="hud-label">Players Alive</div>
                    <div class="hud-value" id="alive-count">21</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Phase</div>
                    <div class="hud-value" id="storm-status">WAIT</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Storm Timer</div>
                    <div class="hud-value" id="storm-timer">04:00</div>
                </div>
            </div>

            <!-- Player Stats (Left) -->
            <div id="player-stats">
                <!-- Health -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">â¤ï¸</div>
                        <div class="stat-title">Health</div>
                        <div class="stat-value" id="health-value">100</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="health-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Shield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">ðŸ›¡ï¸</div>
                        <div class="stat-title">Shield</div>
                        <div class="stat-value" id="shield-value">100</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="shield-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Overshield -->
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-icon">ðŸ”¥</div>
                        <div class="stat-title">Overshield</div>
                        <div class="stat-value" id="overshield-value">50</div>
                    </div>
                    <div class="stat-bar-container">
                        <div id="overshield-bar" class="stat-bar" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Resources -->
                <div id="resources-bar">
                    <div class="resource-item">
                        <div class="resource-icon">ðŸªµ</div>
                        <div class="resource-amount" id="wood-value">0</div>
                    </div>
                </div>
            </div>

            <!-- Inventory (Right) -->
            <div id="inventory-hud">
                <div class="inventory-slot" id="slot-0" onclick="selectSlot(0)" ontouchstart="selectSlotMobile(0)"></div>
                <div class="inventory-slot" id="slot-1" onclick="selectSlot(1)" ontouchstart="selectSlotMobile(1)"></div>
                <div class="inventory-slot" id="slot-2" onclick="selectSlot(2)" ontouchstart="selectSlotMobile(2)"></div>
                <div class="inventory-slot" id="slot-3" onclick="selectSlot(3)" ontouchstart="selectSlotMobile(3)"></div>
                <div class="inventory-slot" id="slot-4" onclick="selectSlot(4)" ontouchstart="selectSlotMobile(4)"></div>
            </div>

            <!-- Center HUD -->
            <div id="center-hud">
                <div id="interact-prompt">Interact (E)</div>
                <div id="reload-indicator">RELOADING...</div>
            </div>

            <!-- Healing Progress -->
            <div id="healing-progress">
                <div id="healing-bar"></div>
                <div id="healing-text">USING SHIELD...</div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div id="touch-left"></div>
            <div id="touch-right"></div>
            
            <div id="movement-zone">
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
            
            <div id="camera-zone"></div>
            
            <div id="btn-fire" class="mobile-button">FIRE</div>
            <div id="btn-jump" class="mobile-button">JUMP</div>
            <div id="btn-interact" class="mobile-button">INTERACT</div>
            <div id="btn-build" class="mobile-button">BUILD</div>
            <div id="btn-ads" class="mobile-button">AIM</div>
            <div id="btn-reload" class="mobile-button">RELOAD</div>
            <!-- New Mobile Controls for V19.9 -->
            <div id="btn-crouch" class="mobile-button">CROUCH</div>
            <div id="btn-switch-weapon" class="mobile-button">SWITCH</div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-overlay">
        <div class="victory-particles" id="victory-particles"></div>
        <div id="victory-text">VICTORY ROYALE</div>
        <div id="victory-stats">Eliminations: 0</div>
        <button class="restart-btn" onclick="location.reload()">ðŸ† RETURN TO LOBBY</button>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <div class="eliminated-particles" id="eliminated-particles"></div>
        <h1 id="go-title">ELIMINATED</h1>
        <h3 id="go-stats">Eliminations: 0</h3>
        <button class="restart-btn" onclick="location.reload()">ðŸ”„ RETURN TO LOBBY</button>
    </div>

    <!-- End Game Stats -->
    <div id="endgame-stats">
        <div class="stats-header">MATCH RESULTS</div>
        <div class="stats-grid" id="match-stats-grid">
            <!-- Stats will be populated here -->
        </div>
        <div class="total-points" id="total-points">Total Points: 0</div>
        <button class="restart-btn" onclick="location.reload()">ðŸ† RETURN TO LOBBY</button>
    </div>

    <!-- Controller Notification -->
    <div class="controller-notification" id="controller-notification">ðŸŽ® Controller Connected</div>
    
    <!-- Controller Layout Display -->
    <div id="controller-layout"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ===============================================================
        // === CORE CONSTANTS AND CONFIGURATION (V19.9) ===================
        // ===============================================================
        
        const WORLD_SIZE = 600;
        let BOT_COUNT = 18;
        const GRAVITY = 40.0; 
        const WALK_SPEED = 10; 
        const SPRINT_SPEED = 20; 
        const JUMP_FORCE = 15;
        const PLAYER_HEIGHT = 1.8;
        const SHOTGUN_PELLETS = 4;
        
        // UPDATED: Player starts with 100 Health, 100 Shields, 50 Overshields
        const OVER_SHIELD_MAX = 50;
        const OVER_SHIELD_REGEN_RATE = 15;
        const OVER_SHIELD_REGEN_DELAY = 3000;
        
        // FIXED: Bot minimum distance from player
        const BOT_MIN_DISTANCE = 15; // Bots cannot get closer than 15 units
        
        // ENHANCED Level System
        let playerLevel = 1;
        let playerXP = 0;
        const XP_PER_LEVEL = 150;
        let matchStats = {
            kills: 0,
            placement: 0,
            chestsOpened: 0,
            legendariesHeld: 0,
            totalPoints: 0
        };
        
        // Level perks system
        const LEVEL_PERKS = [
            { level: 1, name: "Starter", perks: ["+5% Damage", "+10 Shield"] },
            { level: 5, name: "Soldier", perks: ["+10% Damage", "+25 Shield", "+5% Movement Speed"] },
            { level: 10, name: "Veteran", perks: ["+15% Damage", "+50 Shield", "+10% Movement Speed", "Faster Reload"] },
            { level: 15, name: "Elite", perks: ["+20% Damage", "+75 Shield", "+15% Movement Speed", "Faster Healing"] },
            { level: 20, name: "Legend", perks: ["+25% Damage", "+100 Shield", "+20% Movement Speed", "Double XP Gain"] }
        ];
        
        // --- WEAPONS CONFIG ---
        const RARITY_MULTIPLIERS = {
            COMMON: { dmg: 1.0, reload: 1.0, color: '#b0b0b0' },
            UNCOMMON: { dmg: 1.15, reload: 0.9, color: '#28a745' },
            RARE: { dmg: 1.3, reload: 0.8, color: '#007bff' },
            EPIC: { dmg: 1.45, reload: 0.7, color: '#a335ee' },
            LEGENDARY: { dmg: 1.6, reload: 0.6, color: '#ffd700' },
            MYTHIC: { dmg: 1.8, reload: 0.5, color: '#ff4d4d' } 
        };
        const RARITY_KEYS = Object.keys(RARITY_MULTIPLIERS);

        // Weapons configuration
        const WEAPONS_BASE = {
            PUMP: { name: "Pump Shotgun", dmg: 30 * 1.5, head: 35 * 1.5, rate: 1.2, mag: 5, range: 30, spread: 0.25, pellets: SHOTGUN_PELLETS, auto: false, icon: 'ðŸ’¥', reload: 3000, recoil: 0.0, bulletType: 'hitscan' }, 
            AUTO_SHG: { name: "Auto Shotgun", dmg: 30, head: 50, rate: 0.4, mag: 8, range: 25, spread: 0.3, pellets: SHOTGUN_PELLETS, auto: true, icon: 'ðŸ”¥', reload: 3500, recoil: 0.0, bulletType: 'hitscan' },
            RFAR: { name: "Rapid Fire AR", dmg: 14, head: 21, rate: 0.1, mag: 30, range: 150, spread: 0.04, pellets: 1, auto: true, icon: 'ðŸ’¨', reload: 2500, recoil: 0.0, bulletType: 'hitscan' }, 
            DMR: { name: "DMR", dmg: 25, head: 40, rate: 0.35, mag: 15, range: 250, spread: 0.015, pellets: 1, auto: false, icon: 'ðŸŽ¯', reload: 2800, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            STINGER: { name: "Stinger SMG", dmg: 15, head: 22.5, rate: 0.07, mag: 20, range: 70, spread: 0.07, pellets: 1, auto: true, icon: 'âš¡', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            BURST_SMG: { name: "Burst SMG", dmg: 18, head: 30, rate: 0.15, mag: 30, burst: 2, burstDelay: 300, range: 80, spread: 0.05, pellets: 1, auto: false, icon: 'âœ¨', reload: 2000, recoil: 0.0, bulletType: 'hitscan' },
            BOLT_SNIPER: { name: "Bolt Sniper", dmg: 127.5 * 1.25 * 0.67, head: 157.5 * 1.25 * 0.67, rate: 2.5, mag: 2, range: 600, spread: 0.001, pellets: 1, auto: false, icon: 'ðŸ’€', reload: 4000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            SCOPED_SMG: { name: "Scoped SMG", dmg: 12, head: 18, rate: 0.1, mag: 40, range: 100, spread: 0.03, pellets: 1, auto: true, icon: 'ðŸ‘ï¸', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            DRUM_SMG: { name: "Drum SMG", dmg: 10, head: 15, rate: 0.08, mag: 50, range: 80, spread: 0.08, pellets: 1, auto: true, icon: 'ðŸ¥', reload: 1200, recoil: 0.0, bulletType: 'hitscan' },
            FALCON_SNIPER: { name: "Falcon Sniper", dmg: 97.5 * 1.25 * 0.67, head: 135 * 1.25 * 0.67, rate: 0.7, mag: 3, range: 500, spread: 0.005, pellets: 1, auto: false, icon: 'ðŸ¦…', reload: 2500, recoil: 0.0, bulletType: 'hitscan', scope: 'red_dot' },
            STRANGLED_RIFLE: { name: "Strangled Rifle", dmg: 35, head: 55, rate: 0.45, mag: 30, range: 180, spread: 0.02, pellets: 1, auto: false, icon: 'â›“ï¸', reload: 2500, recoil: 0.0, bulletType: 'hitscan' },
            SNIPER: { name: "Sniper", dmg: 150 * 1.25 * 0.67, head: 195 * 1.25 * 0.67, rate: 1.5, mag: 1, range: 600, spread: 0.001, pellets: 1, auto: false, icon: 'ðŸ”­', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'classic' },
            PISTOL: { name: "Pistol", dmg: 12, head: 18, rate: 0.5, mag: 15, range: 100, spread: 0.05, pellets: 1, auto: false, icon: 'ðŸ’£', reload: 1500, recoil: 0.0, bulletType: 'hitscan' },
            ROCKET_LAUNCHER: { name: "R. Launcher", dmg: 50, head: 0, rate: 4.0, mag: 1, range: 300, spread: 0.0, pellets: 1, auto: false, icon: 'ðŸš€', reload: 4500, recoil: 0.0, bulletType: 'projectile', explosionRadius: 5, explosionDamage: 200 },
            DUAL_SMG: { name: "Dual Micro SMGS", dmg: 9, head: 12, rate: 0.05, mag: 130, range: 70, spread: 0.1, pellets: 1, auto: true, icon: 'ðŸ”ª', reload: 2250, recoil: 0.0, bulletType: 'hitscan' },
            HEAVY_AR: { name: "Heavy AR", dmg: 30, head: 55, rate: 0.25, mag: 30, range: 200, spread: 0.035, pellets: 1, auto: false, icon: 'ðŸŽ–ï¸', reload: 3000, recoil: 0.0, bulletType: 'hitscan', scope: 'holo_twister' }
        };
        const MYTHIC_WEAPON_KEY = 'STRANGLED_RIFLE'; 
        const BOT_WEAPON_KEY = 'RFAR'; 
        
        // --- CONSUMABLES CONFIG ---
        const CONSUMABLES = {
            MINI: { name: "Small Shield", val: 25, type: 'shield', max: 50, icon: 'ðŸ’§', time: 1, continuous: false, instant: true, maxStack: 6, rarity: 'COMMON' },
            BIG:  { name: "Big Shield", val: 50, type: 'shield', max: 100, icon: 'âš—ï¸', time: 5000, continuous: false, instant: false, maxStack: 3, rarity: 'UNCOMMON' },
            CHUG: { name: "Chug Jug", val: 3, shieldVal: 3, type: 'continuous', max: 100, icon: 'ðŸ¥¤', time: 20000, continuous: true, instant: false, maxStack: 1, rarity: 'LEGENDARY' },
            MEDKIT: { name: "Med Kit", val: 100, type: 'health', max: 100, icon: 'ðŸ©¹', time: 10000, continuous: false, instant: false, maxStack: 3, rarity: 'RARE' }
        };
        const CONSUMABLE_KEYS = Object.keys(CONSUMABLES);

        // --- IMPROVED STORM PHASES ---
        const STORM_PHASES = [
            { time: 90, radius: WORLD_SIZE * 0.6, damage: 1, status: "Wait" }, 
            { time: 60, radius: WORLD_SIZE * 0.4, damage: 2, status: "Shrink" }, 
            { time: 90, radius: WORLD_SIZE * 0.4, damage: 3, status: "Hold" }, 
            { time: 45, radius: WORLD_SIZE * 0.25, damage: 5, status: "Shrink" }, 
            { time: 30, radius: WORLD_SIZE * 0.15, damage: 8, status: "Shrink" },
            { time: 30, radius: 0, damage: 10, status: "Deathmatch" } 
        ];
        const BOT_STORM_DAMAGE = 5;

        // ===============================================================
        // === GLOBAL STATE VARIABLES ====================================
        // ===============================================================

        let scene, camera, renderer, controls;
        let weaponScene, weaponCamera, viewModel;
        let raycaster, downRay;
        
        let player = { 
            health: 100, shield: 100, overshield: 50, wood: 0, 
            inventory: [null, null, null, null, null], slot: 0, 
            dead: false, ads: false, vehicle: null, eliminations: 0,
            isReloading: false,
            isHealing: false,
            healingItem: null,
            healingStartTime: 0,
            lastStormDamage: 0,
            isBursting: false,
            burstCount: 0,
            burstTimer: null,
            lastOvershieldDamage: 0, 
            overshieldRegenTimer: null,
            lastOvershieldBreak: 0,
            levelDamageMultiplier: 1.0,
            levelShieldBonus: 0,
            levelSpeedMultiplier: 1.0,
            isCrouching: false,
            originalHeight: PLAYER_HEIGHT
        };
        
        let inputs = { w: false, a: false, s: false, d: false, jump: false, sprint: false, fire: false, reload: false, use: false, crouch: false };
        let velocity = new THREE.Vector3();
        let isGrounded = false;
        let lastTime = performance.now();
        let lastShot = 0;
        
        // Game mode
        let gameMode = 'desktop';
        let gameStarted = false;
        let victoryRoyales = 0;
        
        // Mobile control variables
        let mobileTouchActive = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let touchDeltaX = 0;
        let touchDeltaY = 0;
        const MOBILE_SENSITIVITY = 0.0025;
        const MOBILE_SMOOTHING = 0.15;
        const MAX_CAMERA_ANGLE = Math.PI / 2 - 0.1;
        
        // Mobile joystick tracking
        let joystickActive = false;
        let joystickOrigin = { x: 0, y: 0 };
        let joystickOffset = { x: 0, y: 0 };
        
        // Controller variables
        let gamepad = null;
        let controllerConnected = false;
        let controllerVibration = true;
        
        // Dynamic Arrays for Entities
        let bots = [];
        let objects = []; 
        let chests = [];
        let cars = [];
        let loot = [];
        let buildings = []; 
        let projectiles = []; 
        let doors = [];
        
        // Visual effects arrays
        let visualEffects = [];
        let particleSystems = [];

        // Storm State
        let stormRadius = STORM_PHASES[0].radius;
        let stormCenter = new THREE.Vector2(0, 0);
        let stormDamageRate = STORM_PHASES[0].damage;
        let stormPhaseTime = STORM_PHASES[0].time; 
        let stormPhaseTimer = stormPhaseTime;
        let stormPhase = 0;
        let stormActive = false;
        let stormTimerInterval;

        // Day/Night Cycle
        let dayNightCycle = {
            isDay: true,
            cycleTime: 0,
            cycleDuration: 300,
            sunLight: null,
            moonLight: null,
            sunMesh: null,
            moonMesh: null,
            ambientIntensity: 0.6,
            transitionDuration: 30
        };

        // Performance optimization
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let currentFPS = 60;
        let renderDistance = 300;
        let botUpdateInterval = 100;
        let lastBotUpdate = 0;
        let targetFPS = 60;
        let frameTime = 0;
        let lastFrameTime = performance.now();
        let performanceMode = 'balanced'; // 'performance', 'balanced', 'quality'
        
        // FIXED: Bot shooting fix flag
        let botShootingFixed = false;

        // ===============================================================
        // === PERFORMANCE OPTIMIZATION ==================================
        // ===============================================================

        function optimizePerformance() {
            frameCount++;
            const now = performance.now();
            
            // Update FPS counter every second
            if (now - lastFpsUpdate >= 1000) {
                currentFPS = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                document.getElementById('fps-counter').textContent = `FPS: ${currentFPS}`;
                
                // Dynamic performance adjustment
                adjustPerformanceSettings(currentFPS);
                
                frameCount = 0;
                lastFpsUpdate = now;
            }
            
            // Adjust bot update rate based on performance
            if (currentFPS < 30) {
                botUpdateInterval = 200; // Update bots less frequently
                BOT_COUNT = Math.min(12, bots.length); // Reduce bot count
            } else if (currentFPS < 45) {
                botUpdateInterval = 150;
                BOT_COUNT = Math.min(15, bots.length);
            } else {
                botUpdateInterval = 100;
                BOT_COUNT = 18;
            }
            
            // Cull distant objects
            cullDistantObjects();
            
            // Limit visual effects
            if (visualEffects.length > 50) {
                const toRemove = visualEffects.splice(0, 10);
                toRemove.forEach(effect => {
                    if (effect.mesh && effect.mesh.parent) {
                        scene.remove(effect.mesh);
                    }
                });
            }
        }

        function adjustPerformanceSettings(fps) {
            const warning = document.getElementById('performance-warning');
            
            if (fps < 25) {
                // Very low FPS - drastic measures
                warning.style.display = 'block';
                renderDistance = 200;
                performanceMode = 'performance';
                
                // Reduce graphical quality
                renderer.setPixelRatio(1);
                if (scene.fog) scene.fog.near = 50;
                
            } else if (fps < 40) {
                // Low FPS - reduce quality
                warning.style.display = 'none';
                renderDistance = 250;
                performanceMode = 'balanced';
                renderer.setPixelRatio(window.devicePixelRatio || 1);
                
            } else {
                // Good FPS - normal quality
                warning.style.display = 'none';
                renderDistance = 300;
                performanceMode = 'quality';
                renderer.setPixelRatio(window.devicePixelRatio || 1);
            }
        }

        function cullDistantObjects() {
            const playerPos = camera.position;
            
            // Optimize bots
            bots.forEach(bot => {
                if (bot.mesh) {
                    const distance = bot.mesh.position.distanceTo(playerPos);
                    bot.mesh.visible = distance < renderDistance;
                }
            });
            
            // Optimize loot
            loot.forEach(item => {
                if (item.mesh) {
                    const distance = item.mesh.position.distanceTo(playerPos);
                    item.mesh.visible = distance < renderDistance * 0.8;
                }
            });
            
            // Optimize chests
            chests.forEach(chest => {
                if (chest.mesh) {
                    const distance = chest.mesh.position.distanceTo(playerPos);
                    chest.mesh.visible = distance < renderDistance * 0.8;
                }
            });
        }

        // ===============================================================
        // === FIXED BOT AI SYSTEM =======================================
        // ===============================================================

        function updateEnhancedBots(dt, now) {
            if (now - lastBotUpdate < botUpdateInterval) return;
            lastBotUpdate = now;
            
            const playerPos = camera.position;
            
            for(let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];
                if (bot.health <= 0) continue;

                const h = getEnhancedTerrainHeight(bot.mesh.position.x, bot.mesh.position.z);
                bot.mesh.position.y = h + 1;

                // Calculate distance to player
                const distToPlayer = bot.mesh.position.distanceTo(playerPos);
                
                // FIXED: Bot cannot move within BOT_MIN_DISTANCE of player
                if (distToPlayer < BOT_MIN_DISTANCE) {
                    // Move away from player
                    const awayDirection = new THREE.Vector3()
                        .subVectors(bot.mesh.position, playerPos)
                        .normalize();
                    
                    bot.mesh.lookAt(
                        bot.mesh.position.x + awayDirection.x,
                        bot.mesh.position.y,
                        bot.mesh.position.z + awayDirection.z
                    );
                    
                    // Move away but not too fast
                    bot.mesh.translateZ(-WALK_SPEED * 0.3 * dt);
                    
                    // Update target but don't shoot when too close
                    bot.target = player;
                    bot.lastShot = now; // Reset shot timer
                    continue; // Skip rest of AI when too close
                }

                // Simple wandering behavior when no target
                if (!bot.target || bot.target.dead) {
                    const playerDist = bot.mesh.position.distanceTo(camera.position);
                    
                    if (playerDist < 50 && !player.dead) {
                        bot.target = player;
                        if (!bot.spottedPlayer) {
                            playSound('bot_alert', 0.3);
                            bot.spottedPlayer = true;
                        }
                    } else {
                        // Wander randomly with improved movement
                        if (now - bot.lastWander > 3000) {
                            bot.wanderDirection = new THREE.Vector3(
                                Math.random() - 0.5,
                                0,
                                Math.random() - 0.5
                            ).normalize();
                            bot.lastWander = now;
                            bot.spottedPlayer = false;
                        }
                        
                        bot.mesh.lookAt(
                            bot.mesh.position.x + bot.wanderDirection.x,
                            bot.mesh.position.y,
                            bot.mesh.position.z + bot.wanderDirection.z
                        );
                        
                        bot.mesh.translateZ(WALK_SPEED * 0.4 * dt);
                    }
                }
                
                // Chase player if target exists and not too close
                if (bot.target && !bot.target.dead && distToPlayer >= BOT_MIN_DISTANCE) {
                    const targetPos = bot.target === player ? camera.position : bot.target.mesh.position;
                    const direction = new THREE.Vector3()
                        .subVectors(targetPos, bot.mesh.position)
                        .normalize();
                    
                    bot.mesh.lookAt(
                        bot.mesh.position.x + direction.x,
                        bot.mesh.position.y,
                        bot.mesh.position.z + direction.z
                    );
                    
                    const dist = bot.mesh.position.distanceTo(targetPos);
                    
                    if (dist > 25 && dist >= BOT_MIN_DISTANCE) {
                        // Move towards target but maintain minimum distance
                        bot.mesh.translateZ(WALK_SPEED * 0.7 * dt);
                    } else if (dist < BOT_MIN_DISTANCE) {
                        // Move away if too close (already handled above)
                        const awayDir = new THREE.Vector3()
                            .subVectors(bot.mesh.position, targetPos)
                            .normalize();
                        bot.mesh.translateZ(-WALK_SPEED * 0.4 * dt);
                    }
                    
                    // Shoot at target with FIXED damage system
                    if (dist < 60 && !bot.isReloading && now - bot.lastShot > bot.weapon.stats.rate * 1000) {
                        const fireOrigin = bot.mesh.position.clone().setY(bot.mesh.position.y + 2.4);
                        const fireDirection = new THREE.Vector3()
                            .subVectors(targetPos.clone().setY(targetPos.y - 0.5), fireOrigin)
                            .normalize();
                        
                        // Add some inaccuracy based on distance
                        const inaccuracy = Math.min(0.3, dist / 200);
                        fireDirection.x += (Math.random() - 0.5) * inaccuracy;
                        fireDirection.y += (Math.random() - 0.5) * inaccuracy;
                        fireDirection.z += (Math.random() - 0.5) * inaccuracy;
                        fireDirection.normalize();
                        
                        createMuzzleFlash(fireOrigin, fireDirection);
                        
                        // FIXED: Proper raycasting for bot shots
                        const ray = new THREE.Raycaster(fireOrigin, fireDirection);
                        const targets = [];
                        
                        // Only include player if bot is targeting player
                        if (bot.target === player) {
                            targets.push(camera);
                        }
                        
                        const hits = ray.intersectObjects(targets, false);
                        
                        if (hits.length > 0) {
                            const hit = hits[0];
                            // Apply damage with proper parameters
                            applyDamage(player, bot.weapon.stats.dmg * 0.7, hit.point, bot, false);
                            createImpactEffect(hit.point, false);
                            playSound('player_hit', 0.5);
                        }
                        
                        bot.lastShot = now;
                        bot.weapon.stats.currentMag--;
                        
                        if (bot.weapon.stats.currentMag <= 0) {
                            bot.isReloading = true;
                            setTimeout(() => {
                                if (bot.weapon) {
                                    bot.weapon.stats.currentMag = bot.weapon.stats.mag;
                                    bot.isReloading = false;
                                }
                            }, bot.weapon.stats.reload * 1.5);
                        }
                    }
                }
                
                // Update bot weapon ammo
                if (bot.weapon && bot.weapon.stats.currentMag <= 0 && !bot.isReloading) {
                    bot.isReloading = true;
                    setTimeout(() => {
                        if (bot.weapon) {
                            bot.weapon.stats.currentMag = bot.weapon.stats.mag;
                            bot.isReloading = false;
                        }
                    }, bot.weapon.stats.reload * 1.5);
                }
            }
        }

        // ===============================================================
        // === FIXED DAMAGE SYSTEM =======================================
        // ===============================================================

        function applyDamage(target, amount, hitPoint, source, isHeadshot = false, type = 'body') {
            amount = Math.round(amount);
            let remainingDmg = amount;

            if(target === player) {
                // Player takes damage
                let overshieldBefore = player.overshield;
                
                if(player.overshield > 0) {
                    player.overshield -= remainingDmg;
                    if(player.overshield < 0) { 
                        remainingDmg = -player.overshield; 
                        player.overshield = 0; 
                        
                        if (overshieldBefore > 0) {
                            player.lastOvershieldBreak = performance.now();
                        }
                    } else {
                        remainingDmg = 0;
                    }
                    player.lastOvershieldDamage = performance.now();
                }

                if (remainingDmg > 0 && player.shield > 0) {
                    player.shield -= remainingDmg;
                    if(player.shield < 0) { 
                        remainingDmg = -player.shield; 
                        player.shield = 0; 
                    } else {
                        remainingDmg = 0;
                    }
                }
                
                if (remainingDmg > 0) {
                    player.health -= remainingDmg;
                }
                
                showDamage(amount, hitPoint, type, isHeadshot); 
                updateUI();
                
                if(player.health <= 0) {
                    player.dead = true;
                    handleGameOver(false);
                }
                return;
            }

            // Bot takes damage
            if(target.shield > 0) {
                target.shield -= remainingDmg;
                if(target.shield < 0) { 
                    remainingDmg = -target.shield; 
                    target.shield = 0; 
                } else {
                    remainingDmg = 0;
                }
            } 
            
            if (remainingDmg > 0) {
                target.health -= remainingDmg;
            }
            
            showDamage(amount, hitPoint, type, isHeadshot);
            
            if(target.health <= 0) {
                if (bots.includes(target)) {
                    if (source === player) {
                        player.eliminations += 1;
                        matchStats.kills = player.eliminations;
                    }
                    scene.remove(target.mesh);
                    bots = bots.filter(b => b !== target);
                    
                    const randomWeaponKey = getRandomWeaponKey();
                    const randomRarity = getRandomRarity(); 
                    const botWeapon = createWeaponItem(randomWeaponKey, randomRarity);
                    
                    const dropConsumableKey = getRandomConsumableKey();
                    const consumableBase = CONSUMABLES[dropConsumableKey];
                    const healingItemDrop = { 
                        category: 'consumable', 
                        ...CONSUMABLES[dropConsumableKey], 
                        count: 1, 
                        rarity: consumableBase.rarity 
                    };
                    
                    spawnLoot(hitPoint.x + 1, hitPoint.y, hitPoint.z, botWeapon); 
                    spawnLoot(hitPoint.x - 1, hitPoint.y, hitPoint.z, healingItemDrop); 
                    player.wood += 50; 
                    
                    playSound('elimination');
                    updateAliveCount();
                    checkWin();
                }
            }
        }

        // ===============================================================
        // === ENHANCED LEVEL SYSTEM =====================================
        // ===============================================================

        function loadPlayerLevel() {
            const savedLevel = localStorage.getItem('playerLevel');
            const savedXP = localStorage.getItem('playerXP');
            const savedRoyales = localStorage.getItem('victoryRoyales');
            
            playerLevel = savedLevel ? parseInt(savedLevel) : 1;
            playerXP = savedXP ? parseInt(savedXP) : 0;
            victoryRoyales = savedRoyales ? parseInt(savedRoyales) : 0;
            
            applyLevelBonuses();
            updateLevelDisplay();
        }

        function savePlayerLevel() {
            localStorage.setItem('playerLevel', playerLevel);
            localStorage.setItem('playerXP', playerXP);
            localStorage.setItem('victoryRoyales', victoryRoyales);
        }

        function applyLevelBonuses() {
            player.levelDamageMultiplier = 1.0;
            player.levelShieldBonus = 0;
            player.levelSpeedMultiplier = 1.0;
            
            if (playerLevel >= 5) {
                player.levelDamageMultiplier = 1.1;
                player.levelShieldBonus = 25;
            }
            if (playerLevel >= 10) {
                player.levelDamageMultiplier = 1.15;
                player.levelShieldBonus = 50;
                player.levelSpeedMultiplier = 1.1;
            }
            if (playerLevel >= 15) {
                player.levelDamageMultiplier = 1.2;
                player.levelShieldBonus = 75;
                player.levelSpeedMultiplier = 1.15;
            }
            if (playerLevel >= 20) {
                player.levelDamageMultiplier = 1.25;
                player.levelShieldBonus = 100;
                player.levelSpeedMultiplier = 1.2;
            }
            
            player.shield = Math.min(100 + player.levelShieldBonus, player.shield);
        }

        function calculateMatchPoints() {
            matchStats.kills = player.eliminations;
            matchStats.placement = bots.length + 1;
            
            let points = 0;
            points += matchStats.kills * 5;
            points += matchStats.chestsOpened * 1;
            points += matchStats.legendariesHeld * 5;
            
            if (matchStats.placement <= 10) points += 10;
            if (matchStats.placement <= 2) points += 15;
            
            if (matchStats.placement === 1) {
                points += 50;
                victoryRoyales++;
                localStorage.setItem('victoryRoyales', victoryRoyales);
            }
            
            const levelMultiplier = 1 + (playerLevel * 0.05);
            points = Math.floor(points * levelMultiplier);
            
            matchStats.totalPoints = points;
            playerXP += points;
            
            let leveledUp = false;
            while (playerXP >= XP_PER_LEVEL) {
                playerXP -= XP_PER_LEVEL;
                playerLevel++;
                leveledUp = true;
            }
            
            if (leveledUp) {
                applyLevelBonuses();
                showLevelUpNotification();
            }
            
            savePlayerLevel();
            updateLevelDisplay();
            
            return points;
        }

        function updateLevelDisplay() {
            const levelDisplay = document.getElementById('level-display');
            const progressBar = levelDisplay.querySelector('.progress-bar');
            const levelText = levelDisplay.querySelector('.level-text');
            const pointsText = levelDisplay.querySelector('.points-text');
            const perksContainer = levelDisplay.querySelector('.level-perks');
            
            levelText.textContent = `Level ${playerLevel}`;
            const progressPercent = (playerXP / XP_PER_LEVEL) * 100;
            progressBar.style.width = `${progressPercent}%`;
            pointsText.textContent = `${playerXP} / ${XP_PER_LEVEL} XP`;
            
            perksContainer.innerHTML = '';
            const currentPerkSet = LEVEL_PERKS.find(perk => playerLevel >= perk.level) || LEVEL_PERKS[0];
            
            currentPerkSet.perks.forEach((perk, index) => {
                const perkEl = document.createElement('div');
                perkEl.className = `level-perk ${index === 0 ? 'unlocked' : ''}`;
                perkEl.textContent = perk;
                perksContainer.appendChild(perkEl);
            });
        }

        function showLevelUpNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #ffd700, #ffaa00);
                color: #000;
                padding: 2rem 3rem;
                border-radius: 15px;
                font-size: 2rem;
                font-weight: 900;
                z-index: 10000;
                animation: levelUpAnim 2s ease-out forwards;
                text-align: center;
                box-shadow: 0 20px 50px rgba(255, 215, 0, 0.7);
                border: 4px solid rgba(255,255,255,0.5);
            `;
            
            notification.innerHTML = `
                <div style="font-size: 2.5rem; margin-bottom: 1rem;">ðŸŽ‰</div>
                <div>LEVEL UP!</div>
                <div style="font-size: 1.5rem; margin-top: 1rem;">Level ${playerLevel}</div>
            `;
            
            document.body.appendChild(notification);
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes levelUpAnim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5) rotate(-20deg); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2) rotate(10deg); }
                    40% { transform: translate(-50%, -50%) scale(1) rotate(-5deg); }
                    60% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
                    80% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            playSound('victory');
            
            setTimeout(() => {
                notification.remove();
                style.remove();
            }, 2000);
        }

        function showEndGameStats(win) {
            const totalPoints = calculateMatchPoints();
            const statsGrid = document.getElementById('match-stats-grid');
            
            statsGrid.innerHTML = `
                <div class="stat-item">
                    <span class="stat-label">Kills</span>
                    <span class="stat-value">${matchStats.kills} Ã— 5</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Chests Opened</span>
                    <span class="stat-value">${matchStats.chestsOpened} Ã— 1</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Legendaries Held</span>
                    <span class="stat-value">${matchStats.legendariesHeld} Ã— 5</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Placement</span>
                    <span class="stat-value">${matchStats.placement}${matchStats.placement === 1 ? 'st' : matchStats.placement === 2 ? 'nd' : matchStats.placement === 3 ? 'rd' : 'th'}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Level Bonus</span>
                    <span class="stat-value">+${Math.round((playerLevel * 0.05) * 100)}%</span>
                </div>
            `;
            
            if (matchStats.placement <= 10) {
                statsGrid.innerHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Top 10 Bonus</span>
                        <span class="stat-value">10</span>
                    </div>
                `;
            }
            
            if (matchStats.placement <= 2) {
                statsGrid.innerHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Top 2 Bonus</span>
                        <span class="stat-value">15</span>
                    </div>
                `;
            }
            
            if (matchStats.placement === 1) {
                statsGrid.innerHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Victory Royale!</span>
                        <span class="stat-value">50</span>
                    </div>
                `;
            }
            
            document.getElementById('total-points').textContent = `Total Points: ${totalPoints} XP`;
            document.getElementById('endgame-stats').style.display = 'flex';
        }

        // ===============================================================
        // === IMPROVED DAY/NIGHT CYCLE SYSTEM ===========================
        // ===============================================================

        function initDayNightCycle() {
            dayNightCycle.sunLight = new THREE.DirectionalLight(0xffffff, dayNightCycle.ambientIntensity);
            dayNightCycle.sunLight.position.set(100, 200, 100);
            dayNightCycle.sunLight.castShadow = true;
            dayNightCycle.sunLight.shadow.mapSize.width = 1024;
            dayNightCycle.sunLight.shadow.mapSize.height = 1024;
            dayNightCycle.sunLight.shadow.camera.near = 0.5;
            dayNightCycle.sunLight.shadow.camera.far = 500;
            scene.add(dayNightCycle.sunLight);
            
            const sunGeometry = new THREE.SphereGeometry(15, 16, 16);
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            dayNightCycle.sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            dayNightCycle.sunMesh.position.set(300, 300, 300);
            scene.add(dayNightCycle.sunMesh);
            
            dayNightCycle.moonLight = new THREE.DirectionalLight(0x88ccff, 0.3);
            dayNightCycle.moonLight.position.set(-100, 200, -100);
            dayNightCycle.moonLight.visible = false;
            dayNightCycle.moonLight.castShadow = false;
            scene.add(dayNightCycle.moonLight);
            
            const moonGeometry = new THREE.SphereGeometry(10, 16, 16);
            const moonMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xddddff,
                transparent: true,
                opacity: 0.6
            });
            dayNightCycle.moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            dayNightCycle.moonMesh.position.set(-300, 300, -300);
            dayNightCycle.moonMesh.visible = false;
            scene.add(dayNightCycle.moonMesh);
            
            updateDayNightIndicator();
        }

        function updateDayNightCycle(dt) {
            dayNightCycle.cycleTime += dt;
            
            if (dayNightCycle.cycleTime >= dayNightCycle.cycleDuration) {
                dayNightCycle.cycleTime = 0;
                dayNightCycle.isDay = !dayNightCycle.isDay;
                
                const transitionDuration = dayNightCycle.transitionDuration;
                const startTime = performance.now();
                
                const transitionInterval = setInterval(() => {
                    const elapsed = (performance.now() - startTime) / 1000;
                    const progress = Math.min(1, elapsed / transitionDuration);
                    
                    if (dayNightCycle.isDay) {
                        const easeProgress = easeInOutCubic(progress);
                        dayNightCycle.sunLight.intensity = dayNightCycle.ambientIntensity * easeProgress;
                        dayNightCycle.moonLight.intensity = 0.3 * (1 - easeProgress);
                        
                        dayNightCycle.sunMesh.visible = true;
                        dayNightCycle.sunMesh.material.opacity = 0.8 * easeProgress;
                        dayNightCycle.moonMesh.material.opacity = 0.6 * (1 - easeProgress);
                        
                        const dayFog = 0x87CEEB;
                        const nightFog = 0x0a0a2a;
                        const fogColor = interpolateColor(dayFog, nightFog, 1 - easeProgress);
                        scene.fog.color.setHex(fogColor);
                        scene.background.setHex(fogColor);
                        
                        dayNightCycle.sunLight.castShadow = easeProgress > 0.5;
                        
                        if (progress >= 1) {
                            dayNightCycle.moonLight.visible = false;
                            dayNightCycle.moonMesh.visible = false;
                            clearInterval(transitionInterval);
                        }
                    } else {
                        const easeProgress = easeInOutCubic(progress);
                        dayNightCycle.sunLight.intensity = dayNightCycle.ambientIntensity * (1 - easeProgress);
                        dayNightCycle.moonLight.visible = true;
                        dayNightCycle.moonLight.intensity = 0.3 * easeProgress;
                        
                        dayNightCycle.moonMesh.visible = true;
                        dayNightCycle.moonMesh.material.opacity = 0.6 * easeProgress;
                        dayNightCycle.sunMesh.material.opacity = 0.8 * (1 - easeProgress);
                        
                        const dayFog = 0x87CEEB;
                        const nightFog = 0x0a0a2a;
                        const fogColor = interpolateColor(dayFog, nightFog, easeProgress);
                        scene.fog.color.setHex(fogColor);
                        scene.background.setHex(fogColor);
                        
                        dayNightCycle.sunLight.castShadow = easeProgress < 0.5;
                        
                        if (progress >= 1) {
                            dayNightCycle.sunMesh.visible = false;
                            clearInterval(transitionInterval);
                        }
                    }
                    
                }, 32);
                
                updateDayNightIndicator();
            }
            
            if (dayNightCycle.isDay) {
                const timeRatio = dayNightCycle.cycleTime / dayNightCycle.cycleDuration;
                const angle = timeRatio * Math.PI * 2;
                const sunHeight = 300 + Math.sin(angle) * 100;
                dayNightCycle.sunMesh.position.y = sunHeight;
                dayNightCycle.sunLight.position.y = sunHeight;
            } else {
                const timeRatio = dayNightCycle.cycleTime / dayNightCycle.cycleDuration;
                const angle = timeRatio * Math.PI * 2;
                const moonHeight = 300 + Math.sin(angle) * 100;
                dayNightCycle.moonMesh.position.y = moonHeight;
                dayNightCycle.moonLight.position.y = moonHeight;
            }
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function interpolateColor(color1, color2, factor) {
            const r1 = (color1 >> 16) & 255;
            const g1 = (color1 >> 8) & 255;
            const b1 = color1 & 255;
            
            const r2 = (color2 >> 16) & 255;
            const g2 = (color2 >> 8) & 255;
            const b2 = color2 & 255;
            
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            
            return (r << 16) | (g << 8) | b;
        }

        function updateDayNightIndicator() {
            const icon = document.getElementById('day-night-icon');
            const text = document.getElementById('day-night-text');
            
            if (dayNightCycle.isDay) {
                icon.textContent = 'ðŸŒž';
                text.textContent = 'Day';
            } else {
                icon.textContent = 'ðŸŒ™';
                text.textContent = 'Night';
            }
        }

        // ===============================================================
        // === IMPROVED SOUND EFFECTS SYSTEM =============================
        // ===============================================================

        let audioContext;
        let soundCache = {};

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type, volume = 1.0) {
            if (!audioContext) initAudio();
            if (performanceMode === 'performance') volume *= 0.5;
            
            const now = performance.now();
            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume;
            
            const oscillator = audioContext.createOscillator();
            
            switch(type) {
                case 'shoot':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'shoot_sniper':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.5 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                    
                case 'shoot_shotgun':
                    for(let i = 0; i < 2; i++) {
                        setTimeout(() => {
                            if (!audioContext) return;
                            const shotOsc = audioContext.createOscillator();
                            const shotGain = audioContext.createGain();
                            shotOsc.type = 'square';
                            shotOsc.frequency.setValueAtTime(80 + i * 20, audioContext.currentTime);
                            shotOsc.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.2);
                            shotGain.gain.setValueAtTime(0.2 * volume, audioContext.currentTime);
                            shotGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                            shotOsc.connect(shotGain);
                            shotGain.connect(audioContext.destination);
                            shotOsc.start();
                            shotOsc.stop(audioContext.currentTime + 0.2);
                        }, i * 30);
                    }
                    return;
                    
                case 'player_hit':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'elimination':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(659.25, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.4 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'reload':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    
                    setTimeout(() => {
                        if (!audioContext) return;
                        const clickOsc = audioContext.createOscillator();
                        const clickGain = audioContext.createGain();
                        clickOsc.type = 'square';
                        clickOsc.frequency.setValueAtTime(150, audioContext.currentTime);
                        clickGain.gain.setValueAtTime(0.15 * volume, audioContext.currentTime);
                        clickGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                        clickOsc.connect(clickGain);
                        clickGain.connect(audioContext.destination);
                        clickOsc.start();
                        clickOsc.stop(audioContext.currentTime + 0.05);
                    }, 150);
                    
                    setTimeout(() => {
                        if (!audioContext) return;
                        const magOsc = audioContext.createOscillator();
                        const magGain = audioContext.createGain();
                        magOsc.type = 'sine';
                        magOsc.frequency.setValueAtTime(100, audioContext.currentTime);
                        magGain.gain.setValueAtTime(0.08 * volume, audioContext.currentTime);
                        magGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        magOsc.connect(magGain);
                        magGain.connect(audioContext.destination);
                        magOsc.start();
                        magOsc.stop(audioContext.currentTime + 0.1);
                    }, 250);
                    break;
                    
                case 'victory':
                    const notes = [523.25, 659.25, 783.99, 1046.50];
                    notes.forEach((freq, i) => {
                        setTimeout(() => {
                            if (!audioContext) return;
                            const noteOsc = audioContext.createOscillator();
                            const noteGain = audioContext.createGain();
                            noteOsc.type = 'sine';
                            noteOsc.frequency.setValueAtTime(freq, audioContext.currentTime);
                            noteGain.gain.setValueAtTime(0.3 * volume, audioContext.currentTime);
                            noteGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            noteOsc.connect(noteGain);
                            noteGain.connect(audioContext.destination);
                            noteOsc.start();
                            noteOsc.stop(audioContext.currentTime + 0.3);
                        }, i * 200);
                    });
                    return;
                    
                case 'defeat':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(130.81, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(87.31, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.2 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'jump':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'land':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'build':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.15 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'storm_damage':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.15 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'open_chest':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(523.25, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.2 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'pickup_item':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'explosion':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(50, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.4 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'bot_alert':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                default:
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1 * volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
            }
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
        }

        // ===============================================================
        // === ENHANCED CORAL CASTLE WATER EFFECTS =======================
        // ===============================================================

        function createWaterEffectsForCoralCastle(x, z, h) {
            const waterGeometry = new THREE.PlaneGeometry(80, 80, 16, 16);
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x00CED1,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.8
            });
            
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.set(x, h + 0.2, z);
            scene.add(water);
            objects.push(water);
            
            const positions = waterGeometry.attributes.position;
            const originalPositions = positions.array.slice();
            
            function animateWater() {
                const time = performance.now() * 0.001;
                for (let i = 0; i < positions.count; i++) {
                    const ix = i * 3;
                    const x = originalPositions[ix];
                    const z = originalPositions[ix + 2];
                    
                    const waveHeight = Math.sin(x * 0.2 + time) * Math.cos(z * 0.2 + time) * 0.5;
                    positions.array[ix + 1] = originalPositions[ix + 1] + waveHeight;
                }
                positions.needsUpdate = true;
                
                if (!player.dead) {
                    requestAnimationFrame(animateWater);
                }
            }
            animateWater();
            
            const splashParticles = new THREE.Group();
            for (let i = 0; i < 10; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 4, 4),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.6
                    })
                );
                particle.position.set(
                    x + (Math.random() - 0.5) * 40,
                    h + 0.5 + Math.random() * 0.5,
                    z + (Math.random() - 0.5) * 40
                );
                splashParticles.add(particle);
                
                visualEffects.push({
                    mesh: particle,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        Math.random() * 0.05,
                        (Math.random() - 0.5) * 0.1
                    ),
                    lifetime: 3 + Math.random() * 2,
                    age: Math.random() * 2,
                    floating: true
                });
            }
            scene.add(splashParticles);
            
            const bubbleParticles = new THREE.Group();
            for (let i = 0; i < 8; i++) {
                const bubble = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 6, 6),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.4
                    })
                );
                bubble.position.set(
                    x + (Math.random() - 0.5) * 35,
                    h + 0.1,
                    z + (Math.random() - 0.5) * 35
                );
                bubbleParticles.add(bubble);
                
                visualEffects.push({
                    mesh: bubble,
                    velocity: new THREE.Vector3(0, 0.1 + Math.random() * 0.1, 0),
                    lifetime: 2 + Math.random() * 3,
                    age: Math.random() * 2,
                    floating: false
                });
            }
            scene.add(bubbleParticles);
            
            const waterSoundTrigger = {
                position: new THREE.Vector3(x, h, z),
                radius: 40,
                lastSplashTime: 0
            };
            
            function checkWaterSounds() {
                if (player.dead) return;
                
                const playerDist = camera.position.distanceTo(waterSoundTrigger.position);
                if (playerDist < waterSoundTrigger.radius) {
                    const now = performance.now();
                    if (now - waterSoundTrigger.lastSplashTime > 2000) {
                        playSound('water_splash', 0.3);
                        waterSoundTrigger.lastSplashTime = now;
                    }
                }
                
                requestAnimationFrame(checkWaterSounds);
            }
            checkWaterSounds();
        }

        // ===============================================================
        // === IMPROVED VISUAL EFFECTS SYSTEM ============================
        // ===============================================================

        function createMuzzleFlash(position, direction) {
            const flash = new THREE.PointLight(0xff9900, 2, 10);
            flash.position.copy(position);
            scene.add(flash);
            
            const particles = new THREE.Group();
            for(let i = 0; i < 6; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05 + Math.random() * 0.05, 4, 4),
                    new THREE.MeshBasicMaterial({ color: 0xff6600 })
                );
                particle.position.copy(position);
                const velocity = direction.clone()
                    .add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.4,
                        (Math.random() - 0.5) * 0.4,
                        (Math.random() - 0.5) * 0.4
                    ))
                    .normalize()
                    .multiplyScalar(Math.random() * 8 + 8);
                particles.add(particle);
                visualEffects.push({
                    mesh: particle,
                    velocity: velocity,
                    lifetime: 0.2 + Math.random() * 0.1,
                    age: 0
                });
            }
            scene.add(particles);
            
            setTimeout(() => {
                scene.remove(flash);
                scene.remove(particles);
            }, 100);
        }

        function createImpactEffect(position, isHeadshot = false) {
            const particles = new THREE.Group();
            const particleCount = isHeadshot ? 10 : 6;
            
            for(let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08 + Math.random() * 0.07, 4, 4),
                    new THREE.MeshBasicMaterial({ 
                        color: isHeadshot ? 0xff0000 : 0xff6600,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                particle.position.copy(position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3
                );
                particles.add(particle);
                visualEffects.push({
                    mesh: particle,
                    velocity: velocity,
                    lifetime: 0.8 + Math.random() * 0.4,
                    age: 0
                });
            }
            scene.add(particles);
            
            if (isHeadshot) {
                const blood = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xcc0000,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                blood.position.copy(position);
                scene.add(blood);
                
                visualEffects.push({
                    mesh: blood,
                    lifetime: 1.5,
                    age: 0,
                    scaleDown: true
                });
            }
        }

        function updateVisualEffects(dt) {
            for(let i = visualEffects.length - 1; i >= 0; i--) {
                const effect = visualEffects[i];
                effect.age += dt;
                
                if (effect.age >= effect.lifetime) {
                    scene.remove(effect.mesh);
                    visualEffects.splice(i, 1);
                    continue;
                }
                
                if (effect.velocity) {
                    effect.mesh.position.add(effect.velocity.clone().multiplyScalar(dt));
                    
                    if (!effect.floating) {
                        effect.velocity.y -= GRAVITY * 0.1 * dt;
                    }
                }
                
                const progress = effect.age / effect.lifetime;
                if (effect.mesh.material) {
                    effect.mesh.material.opacity = 1 - progress;
                }
                
                if (effect.scaleDown) {
                    effect.mesh.scale.setScalar(1 - progress * 0.5);
                }
            }
        }

        // ===============================================================
        // === IMPROVED INPUT & CONTROL MANAGEMENT =======================
        // ===============================================================
        
        function toggleCrouch(state) {
            if (player.dead) return;
            
            player.isCrouching = state;
            if (state) {
                player.originalHeight = camera.position.y - getTerrainHeight(camera.position.x, camera.position.z);
                camera.position.y -= 0.9;
                playSound('crouch', 0.3);
            } else {
                camera.position.y += 0.9;
            }
        }

        function setGameMode(mode) {
            gameMode = mode;
            const mobileControls = document.getElementById('mobile-controls');
            const gameContainer = document.getElementById('game-container');
            const controllerLayout = document.getElementById('controller-layout');

            if (mode === 'mobile') {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'block';
                controllerLayout.style.display = 'none';
                gameContainer.removeEventListener('mousedown', lockPointer);
                
                initMobileControls();
            } else if (mode === 'controller') {
                if (controls) controls.enabled = false;
                mobileControls.style.display = 'none';
                controllerLayout.style.display = 'none';
                gameContainer.removeEventListener('mousedown', lockPointer);
            } else {
                if (controls) controls.enabled = true;
                mobileControls.style.display = 'none';
                controllerLayout.style.display = 'none';
                gameContainer.addEventListener('mousedown', lockPointer);
            }
        }

        function initMobileControls() {
            const touchLeft = document.getElementById('touch-left');
            const touchRight = document.getElementById('touch-right');
            const joystickThumb = document.getElementById('joystick-thumb');
            const movementZone = document.getElementById('movement-zone');
            
            let isTouchingLeft = false;
            let leftTouchId = null;
            
            touchLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for(let touch of e.changedTouches) {
                    if(leftTouchId === null) {
                        leftTouchId = touch.identifier;
                        isTouchingLeft = true;
                        joystickActive = true;
                        
                        const rect = movementZone.getBoundingClientRect();
                        joystickOrigin.x = rect.left + rect.width / 2;
                        joystickOrigin.y = rect.top + rect.height / 2;
                        
                        joystickOffset.x = touch.clientX - joystickOrigin.x;
                        joystickOffset.y = touch.clientY - joystickOrigin.y;
                        
                        const maxDist = 75;
                        const dist = Math.sqrt(joystickOffset.x*joystickOffset.x + joystickOffset.y*joystickOffset.y);
                        if(dist > maxDist) {
                            const ratio = maxDist / dist;
                            joystickOffset.x *= ratio;
                            joystickOffset.y *= ratio;
                        }
                        
                        joystickThumb.style.transform = `translate(${joystickOffset.x}px, ${joystickOffset.y}px)`;
                        
                        const deadZone = 20;
                        inputs.w = joystickOffset.y < -deadZone;
                        inputs.s = joystickOffset.y > deadZone;
                        inputs.a = joystickOffset.x < -deadZone;
                        inputs.d = joystickOffset.x > deadZone;
                        inputs.sprint = dist > 50;
                        break;
                    }
                }
            });
            
            touchLeft.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let touch of e.changedTouches) {
                    if(touch.identifier === leftTouchId) {
                        joystickOffset.x = touch.clientX - joystickOrigin.x;
                        joystickOffset.y = touch.clientY - joystickOrigin.y;
                        
                        const maxDist = 75;
                        const dist = Math.sqrt(joystickOffset.x*joystickOffset.x + joystickOffset.y*joystickOffset.y);
                        if(dist > maxDist) {
                            const ratio = maxDist / dist;
                            joystickOffset.x *= ratio;
                            joystickOffset.y *= ratio;
                        }
                        
                        joystickThumb.style.transform = `translate(${joystickOffset.x}px, ${joystickOffset.y}px)`;
                        
                        const deadZone = 20;
                        inputs.w = joystickOffset.y < -deadZone;
                        inputs.s = joystickOffset.y > deadZone;
                        inputs.a = joystickOffset.x < -deadZone;
                        inputs.d = joystickOffset.x > deadZone;
                        inputs.sprint = dist > 50;
                        break;
                    }
                }
            });
            
            touchLeft.addEventListener('touchend', (e) => {
                for(let touch of e.changedTouches) {
                    if(touch.identifier === leftTouchId) {
                        leftTouchId = null;
                        isTouchingLeft = false;
                        joystickActive = false;
                        joystickThumb.style.transform = `translate(-50%, -50%)`;
                        inputs.w = inputs.s = inputs.a = inputs.d = inputs.sprint = false;
                        break;
                    }
                }
            });
            
            let rightTouchId = null;
            let isTouchingRight = false;
            let lastRightTouch = { x: 0, y: 0 };
            
            touchRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for(let touch of e.changedTouches) {
                    if(rightTouchId === null) {
                        rightTouchId = touch.identifier;
                        isTouchingRight = true;
                        lastRightTouch.x = touch.clientX;
                        lastRightTouch.y = touch.clientY;
                        touchDeltaX = 0;
                        touchDeltaY = 0;
                        break;
                    }
                }
            });
            
            touchRight.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let touch of e.changedTouches) {
                    if(touch.identifier === rightTouchId) {
                        const deltaX = touch.clientX - lastRightTouch.x;
                        const deltaY = touch.clientY - lastRightTouch.y;
                        
                        touchDeltaX = deltaX * MOBILE_SENSITIVITY;
                        touchDeltaY = deltaY * MOBILE_SENSITIVITY;
                        
                        camera.rotation.y -= touchDeltaX;
                        camera.rotation.x -= touchDeltaY;
                        
                        camera.rotation.x = Math.max(-MAX_CAMERA_ANGLE, Math.min(MAX_CAMERA_ANGLE, camera.rotation.x));
                        
                        lastRightTouch.x = touch.clientX;
                        lastRightTouch.y = touch.clientY;
                        break;
                    }
                }
            });
            
            touchRight.addEventListener('touchend', (e) => {
                for(let touch of e.changedTouches) {
                    if(touch.identifier === rightTouchId) {
                        rightTouchId = null;
                        isTouchingRight = false;
                        touchDeltaX = 0;
                        touchDeltaY = 0;
                        break;
                    }
                }
            });
            
            const setupButton = (id, action) => {
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => { 
                    e.preventDefault(); 
                    action(true);
                });
                btn.addEventListener('touchend', (e) => { 
                    e.preventDefault(); 
                    action(false);
                });
                btn.addEventListener('touchcancel', (e) => { 
                    e.preventDefault(); 
                    action(false);
                });
            };
            
            setupButton('btn-fire', (state) => { inputs.fire = state; });
            setupButton('btn-jump', (state) => { inputs.jump = state; });
            setupButton('btn-ads', (state) => { toggleADS(state); });
            setupButton('btn-crouch', (state) => { 
                inputs.crouch = state; 
                toggleCrouch(state);
            });
            
            document.getElementById('btn-interact').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                tryInteract(); 
            });
            
            document.getElementById('btn-build').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                buildWall(); 
            });
            
            document.getElementById('btn-reload').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                reload(); 
            });
            
            document.getElementById('btn-switch-weapon').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                const nextSlot = (player.slot + 1) % 5;
                switchSlot(nextSlot);
            });
        }

        // ===============================================================
        // === FIXED STORM DAMAGE SYSTEM =================================
        // ===============================================================

        function updateStorm(now) {
            const playerPos2D = new THREE.Vector2(camera.position.x, camera.position.z);
            const distToStorm = playerPos2D.distanceTo(stormCenter);
            const inStorm = stormActive && distToStorm > stormRadius;

            document.getElementById('storm-overlay').classList.toggle('in-storm', inStorm);

            // Damage Application - Player
            if (inStorm && stormDamageRate > 0) {
                const timeSinceLastDamage = now - player.lastStormDamage;
                const damageInterval = 1000;
                
                if (timeSinceLastDamage >= damageInterval) {
                    let actualDamage = stormDamageRate;
                    
                    const timeInStorm = Math.min(30, (timeSinceLastDamage - damageInterval) / 1000);
                    if (timeInStorm > 10) {
                        actualDamage *= 1.5;
                    }
                    if (timeInStorm > 20) {
                        actualDamage *= 2;
                    }
                    
                    applyDamage(player, actualDamage, camera.position, null, false, 'storm');
                    player.lastStormDamage = now;
                    playSound('storm_damage');
                    
                    if (performanceMode !== 'performance') {
                        const stormEffect = document.createElement('div');
                        const intensity = Math.min(0.6, 0.3 + (timeInStorm * 0.02));
                        stormEffect.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: radial-gradient(circle at ${(Math.random() * 100)}% ${(Math.random() * 100)}%, 
                                rgba(138, 43, 226, ${intensity}) 0%, 
                                rgba(75, 0, 130, ${intensity * 0.7}) 50%,
                                transparent 100%);
                            pointer-events: none;
                            z-index: 999;
                            animation: flashStorm 0.5s ease-out forwards;
                            mix-blend-mode: screen;
                        `;
                        document.body.appendChild(stormEffect);
                        
                        const style = document.createElement('style');
                        style.textContent = `
                            @keyframes flashStorm {
                                0% { opacity: 0; transform: scale(1); }
                                50% { opacity: ${intensity}; transform: scale(1.02); }
                                100% { opacity: 0; transform: scale(1); }
                            }
                        `;
                        document.head.appendChild(style);
                        
                        setTimeout(() => {
                            stormEffect.remove();
                            style.remove();
                        }, 500);
                    }
                }
            } 

            // Damage Application - Bots
            bots.forEach(bot => {
                const botPos2D = new THREE.Vector2(bot.mesh.position.x, bot.mesh.position.z);
                const botDistToStorm = botPos2D.distanceTo(stormCenter);
                const botInStorm = stormActive && botDistToStorm > stormRadius;
                
                if (botInStorm && BOT_STORM_DAMAGE > 0) {
                     if (now - (bot.lastStormDamage || 0) > 1000) {
                        applyDamage(bot, BOT_STORM_DAMAGE, bot.mesh.position.clone().setY(bot.mesh.position.y + 1), null, false, 'storm');
                        bot.lastStormDamage = now;
                        
                        if (bot.health <= 0) {
                            scene.remove(bot.mesh);
                            bots = bots.filter(b => b !== bot);
                            player.wood += 50;
                            updateAliveCount();
                            checkWin();
                        }
                    }
                }
            });
        }

        // ===============================================================
        // === CORE GAME FUNCTIONS =======================================
        // ===============================================================

        function getEnhancedTerrainHeight(x, z) {
            const mountainScale = 0.01;
            const mountainHeight = 30;
            const riverWidth = 20;
            const riverDepth = 5;
            const hillScale1 = 0.02;
            const hillScale2 = 0.05;
            const hillScale3 = 0.1;
            
            let y = 0;
            
            y += Math.sin(x * hillScale1) * 8 + Math.cos(z * hillScale1) * 8;
            y += Math.sin(x * hillScale2 + z * hillScale2) * 4;
            y += Math.sin(x * hillScale3 * 0.7) * Math.cos(z * hillScale3 * 0.7) * 3;
            
            const distFromCenter = Math.sqrt(x*x + z*z);
            if (distFromCenter > WORLD_SIZE * 0.4) {
                y += (distFromCenter - WORLD_SIZE * 0.4) * 0.3;
                
                if (distFromCenter > WORLD_SIZE * 0.45) {
                    y += Math.sin(distFromCenter * mountainScale) * mountainHeight * 0.5;
                }
            }
            
            const riverDist = Math.abs(z);
            if (riverDist < riverWidth) {
                y -= riverDepth * (1 - riverDist / riverWidth);
            }
            
            y += Math.sin(x * 0.03) * Math.cos(z * 0.04) * 2;
            
            return y;
        }

        function getTerrainHeight(x, z) {
            return getEnhancedTerrainHeight(x, z);
        }
        
        function createBox(x, y, z, w, h, d, col, type='solid') {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: col}));
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh); 
            buildings.push({ mesh: mesh, type: type, health: 100 });
            return mesh;
        }

        function createCoralCastle() {
            const x = 300, z = -300;
            const h = getEnhancedTerrainHeight(x, z);
            
            createBox(x, h + 20, z, 30, 40, 30, 0x00CED1);
            createBox(x, h + 45, z, 35, 10, 35, 0x20B2AA);
            
            const towerPositions = [
                { x: x + 25, z: z + 25 },
                { x: x - 25, z: z + 25 },
                { x: x + 25, z: z - 25 },
                { x: x - 25, z: z - 25 }
            ];
            
            towerPositions.forEach(pos => {
                createBox(pos.x, h + 30, pos.z, 8, 60, 8, 0x48D1CC);
                createBox(pos.x, h + 65, pos.z, 10, 10, 10, 0x40E0D0);
            });
            
            createBox(x, h + 0.1, z, 60, 0.2, 60, 0xAFEEEE);
            
            for(let i = 0; i < 15; i++) {
                const coralX = x + (Math.random() - 0.5) * 50;
                const coralZ = z + (Math.random() - 0.5) * 50;
                const coralHeight = Math.random() * 5 + 2;
                createBox(coralX, h + coralHeight/2, coralZ, 
                         Math.random() * 3 + 1, coralHeight, Math.random() * 3 + 1, 
                         [0xFF69B4, 0xFF1493, 0xFF00FF][Math.floor(Math.random() * 3)]);
            }
            
            spawnChest(x, h + 5, z);
            spawnChest(x + 10, h + 5, z + 10);
            spawnChest(x - 10, h + 5, z - 10);
            
            createWaterEffectsForCoralCastle(x, z, h);
            
            console.log("Created Coral Castle POI with water effects");
        }

        function checkWin() {
            if (bots.length === 0 && !player.dead) {
                handleGameOver(true);
            }
        }
        
        function handleGameOver(win) {
            player.dead = true;
            if (controls && controls.isLocked) controls.unlock(); 
            
            if (win) {
                victoryRoyales = (parseInt(localStorage.getItem('victoryRoyales')) || 0) + 1;
                localStorage.setItem('victoryRoyales', victoryRoyales);

                createVictoryParticles();
                document.getElementById('victory-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('victory-overlay').style.display = 'flex';
                playSound('victory');
                setTimeout(() => showEndGameStats(true), 2000);
            } else {
                createEliminatedParticles();
                document.getElementById('go-stats').innerText = `Eliminations: ${player.eliminations}`;
                document.getElementById('game-over').style.display = 'flex';
                playSound('defeat');
                setTimeout(() => showEndGameStats(false), 2000);
            }
        }

        // ===============================================================
        // === UI UPDATE FUNCTIONS =======================================
        // ===============================================================

        function updateUI() {
            document.getElementById('health-value').textContent = Math.max(0, Math.round(player.health));
            document.getElementById('shield-value').textContent = Math.max(0, Math.round(player.shield));
            document.getElementById('overshield-value').textContent = Math.max(0, Math.round(player.overshield));
            document.getElementById('wood-value').textContent = player.wood;
            
            document.getElementById('health-bar').style.width = `${Math.max(0, player.health)}%`;
            document.getElementById('shield-bar').style.width = `${Math.max(0, player.shield)}%`;
            document.getElementById('overshield-bar').style.width = `${Math.max(0, player.overshield / OVER_SHIELD_MAX * 100)}%`;
            
            updateAliveCount();
        }

        function updateAliveCount() {
            const aliveCount = bots.length + (player.dead ? 0 : 1);
            document.getElementById('alive-count').textContent = aliveCount;
            document.getElementById('total-players').textContent = aliveCount;
        }

        // ===============================================================
        // === INITIALIZATION & START GAME ===============================
        // ===============================================================

        function init() {
            // Hide loading screen after assets are loaded
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
            }, 1000);
            
            victoryRoyales = parseInt(localStorage.getItem('victoryRoyales')) || 0;
            document.getElementById('victory-royales-stat').innerText = `ðŸ† Victory Royales: ${victoryRoyales}`;
            
            loadPlayerLevel();
            createParticles();
            initAudio();
            
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, renderDistance);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            weaponScene = new THREE.Scene();
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 100);

            renderer = new THREE.WebGLRenderer({ 
                antialias: performanceMode !== 'performance',
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = performanceMode !== 'performance';
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false; 
            const gameContainer = document.getElementById('game-container');
            gameContainer.appendChild(renderer.domElement);
            
            initDayNightCycle();
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            
            weaponScene.add(ambient.clone());
            
            controls = new PointerLockControls(camera, document.body);
            setupInputs(); 

            raycaster = new THREE.Raycaster();
            downRay = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, PLAYER_HEIGHT + 0.1);
            
            animate();
        }

        window.startGame = (mode) => {
            document.getElementById('start-screen').style.display = 'none';
            gameStarted = true;
            
            setGameMode(mode);
            
            if (mode === 'desktop') {
                setupPCLock(); 
            }
            
            matchStats = {
                kills: 0,
                placement: 0,
                chestsOpened: 0,
                legendariesHeld: 0,
                totalPoints: 0
            };
            
            player.health = 100;
            player.shield = 100 + player.levelShieldBonus;
            player.overshield = 50;
            player.wood = 0;
            player.inventory = [null, null, null, null, null];
            player.slot = 0;
            player.eliminations = 0;
            player.dead = false;
            
            generateTerrain(); 
            generatePOIs(); 
            spawnBots();
            spawnCars();

            camera.position.set(0, getEnhancedTerrainHeight(0, 0) + PLAYER_HEIGHT + 2, 0);
            
            startStormTimer(); 
            switchSlot(0);
            
            updateUI();
            updateAliveCount();
        };

        // ===============================================================
        // === CORE GAME LOOP ============================================
        // ===============================================================

        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            if(!gameStarted || player.dead) {
                renderer.clear();
                renderer.render(scene, camera);
                return;
            }

            if (player.isHealing && player.healingItem) {
                if (player.healingItem.continuous) {
                    applyContinuousHealing(player.healingItem, dt);
                } else if (!player.healingItem.instant) {
                    inputs.fire = false;
                    inputs.w = inputs.a = inputs.s = inputs.d = false;
                }
            }
            
            // Overshield regeneration
            overshieldRegen(dt);
            
            updateDayNightCycle(dt);

            if(player.vehicle) {
                updateCars(dt);
            } else {
                const canMove = gameMode === 'mobile' || gameMode === 'controller' || (controls && controls.isLocked); 
                if (canMove) {
                    const speedMultiplier = player.ads ? 0.5 : 1.0; 
                    const currentSpeed = (inputs.sprint ? SPRINT_SPEED : WALK_SPEED) * speedMultiplier * player.levelSpeedMultiplier;
                    
                    const direction = new THREE.Vector3();
                    direction.setFromMatrixColumn(camera.matrix, 0); 
                    direction.crossVectors(camera.up, direction);
                    direction.y = 0;
                    direction.normalize();
                    
                    const right = new THREE.Vector3(-direction.z, 0, direction.x);

                    const yVelocity = velocity.y; 
                    velocity.set(0, yVelocity, 0); 

                    if(inputs.w) velocity.add(direction.clone().multiplyScalar(currentSpeed));
                    if(inputs.s) velocity.add(direction.clone().multiplyScalar(-currentSpeed));
                    if(inputs.a) velocity.add(right.clone().multiplyScalar(-currentSpeed));
                    if(inputs.d) velocity.add(right.clone().multiplyScalar(currentSpeed));
                    
                    camera.position.x += velocity.x * dt;
                    camera.position.z += velocity.z * dt;
                    velocity.y -= GRAVITY * dt; 
                    
                    const groundY = getEnhancedTerrainHeight(camera.position.x, camera.position.z);
                    let floorY = groundY;
                    
                    downRay.ray.origin.copy(camera.position);
                    const hits = downRay.intersectObjects(objects.filter(obj => !doors.map(d=>d.mesh).includes(obj) && !buildings.some(b => b.mesh === obj && b.type === 'indestructible_wood')), false); 
                    
                    if(hits.length > 0) {
                        const closestHit = hits[0];
                        if (closestHit.point.y > groundY + 0.1) { 
                            floorY = closestHit.point.y;
                        }
                    }
                    
                    if (camera.position.y <= floorY + PLAYER_HEIGHT && velocity.y <= 0) {
                        camera.position.y = floorY + PLAYER_HEIGHT;
                        velocity.y = 0;
                        isGrounded = true;
                    } else {
                        isGrounded = false;
                    }
                    
                    if(inputs.jump && isGrounded) {
                        velocity.y = JUMP_FORCE;
                        isGrounded = false;
                        inputs.jump = false; 
                        playSound('jump');
                    }
                    
                    camera.position.y += velocity.y * dt;
                    
                    if (inputs.crouch && !player.isCrouching) {
                        toggleCrouch(true);
                    } else if (!inputs.crouch && player.isCrouching) {
                        toggleCrouch(false);
                    }
                    
                    if ((inputs.w || inputs.a || inputs.s || inputs.d) && isGrounded && Math.random() < 0.05) {
                        playSound('footstep', 0.2);
                    }
                } else {
                    velocity.x = 0; 
                    velocity.z = 0;
                }
            }

            const canFire = gameMode === 'mobile' || gameMode === 'controller' || (controls && controls.isLocked); 
            if(inputs.fire && !player.vehicle && !player.isHealing && canFire) {
                const item = player.inventory[player.slot];
                if(item && item.category === 'weapon') {
                    if (item.stats.burst) {
                        if (now - lastShot > item.stats.burstDelay) {
                            shoot(item);
                        }
                    } else if(now - lastShot > item.stats.rate * 1000) {
                        shoot(item);
                    }
                }
            } else if (inputs.reload) {
                reload();
                inputs.reload = false;
            }
            
            updateProjectiles(dt);
            updateEnhancedBots(dt, now);
            updateStorm(now);
            updateVisualEffects(dt);
            optimizePerformance();

            renderer.clear();
            renderer.render(scene, camera);
            renderer.clearDepth();
            renderer.render(weaponScene, weaponCamera);
            
            updateUI();
        }

        // ===============================================================
        // === MISSING FUNCTIONS (Placeholders for completeness) =========
        // ===============================================================

        // These functions are referenced in the code but not defined in your original snippet
        // I'm adding minimal implementations to prevent errors

        function setupPCLock() {
            const gameContainer = document.getElementById('game-container');
            gameContainer.addEventListener('click', () => {
                if (controls && !controls.isLocked && gameMode === 'desktop') {
                    controls.lock();
                }
            });
        }

        function lockPointer() {
            if (controls && !controls.isLocked && gameMode === 'desktop') {
                controls.lock();
            }
        }

        function toggleADS(state) {
            player.ads = state;
        }

        function tryInteract() {
            // Interaction logic
        }

        function buildWall() {
            // Build wall logic
        }

        function reload() {
            // Reload logic
        }

        function switchSlot(slot) {
            player.slot = slot;
        }

        function selectSlotMobile(slot) {
            switchSlot(slot);
        }

        function useHealingItem() {
            // Use healing item logic
        }

        function applyContinuousHealing(item, dt) {
            // Continuous healing logic
        }

        function finishHealing() {
            // Finish healing logic
        }

        function overshieldRegen(dt) {
            if (player.dead || player.overshield === OVER_SHIELD_MAX) return;

            const timeSinceDamage = performance.now() - player.lastOvershieldDamage;
            const timeSinceBreak = performance.now() - player.lastOvershieldBreak;
            
            if (timeSinceDamage >= OVER_SHIELD_REGEN_DELAY && timeSinceBreak >= OVER_SHIELD_REGEN_DELAY) {
                player.overshield = Math.min(OVER_SHIELD_MAX, player.overshield + (OVER_SHIELD_REGEN_RATE * dt));
                updateUI();
            }
        }

        function shoot(item) {
            // Shooting logic
        }

        function createParticles() {
            // Create particles for start screen
        }

        function createVictoryParticles() {
            // Create victory particles
        }

        function createEliminatedParticles() {
            // Create eliminated particles
        }

        function generateTerrain() {
            // Generate terrain
        }

        function generatePOIs() {
            // Generate points of interest
            createCoralCastle();
        }

        function spawnBots() {
            // Spawn bots
        }

        function spawnCars() {
            // Spawn cars
        }

        function spawnChest(x, y, z) {
            // Spawn chest
        }

        function spawnLoot(x, y, z, item) {
            // Spawn loot
        }

        function startStormTimer() {
            // Start storm timer
        }

        function setupInputs() {
            // Setup keyboard inputs
        }

        function setupControllerInputs() {
            // Setup controller inputs
        }

        function updateProjectiles(dt) {
            // Update projectiles
        }

        function updateCars(dt) {
            // Update cars
        }

        function getRandomWeaponKey() {
            return Object.keys(WEAPONS_BASE)[Math.floor(Math.random() * Object.keys(WEAPONS_BASE).length)];
        }

        function getRandomRarity() {
            return RARITY_KEYS[Math.floor(Math.random() * RARITY_KEYS.length)];
        }

        function getRandomConsumableKey() {
            return CONSUMABLE_KEYS[Math.floor(Math.random() * CONSUMABLE_KEYS.length)];
        }

        function createWeaponItem(key, rarity) {
            return {
                category: 'weapon',
                key: key,
                stats: { ...WEAPONS_BASE[key] },
                rarity: rarity
            };
        }

        function showDamage(amount, position, type, isHeadshot) {
            // Show damage numbers
        }

        function vibrateController(type) {
            // Controller vibration
        }

        // Initialize the game
        init();

        // Window event listeners
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            weaponCamera.aspect = window.innerWidth / window.innerHeight;
            weaponCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.selectSlot = switchSlot;
        window.selectSlotMobile = selectSlotMobile;
        
    </script>
</body>
</html>
